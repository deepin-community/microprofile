Description: Add free microprofile.html files
 The microprofile.html and microprofilelive.html upstream files contain
 some non-free JavaScript code; this patch re-adds them after being
 excluded by d/copyright, but with the non-free bits replaced by free
 ones.
Author: Andrea Pappacoda <andrea@pappacoda.it>
Bug: https://github.com/jonasmr/microprofile/issues/81
Bug-Debian: https://bugs.debian.org/1023178
Forwarded: https://github.com/jonasmr/microprofile/pull/82
Last-Update: 2022-11-03

--- /dev/null
+++ microprofile-4.0+dfsg/src/microprofile.html
@@ -0,0 +1,8677 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<title>MicroProfile Capture</title>
+<style>
+/* about css: http://bit.ly/1eMQ42U */
+body {margin: 0px;padding: 0px; font: 12px Courier New;background-color:#343434; color:white;overflow:hidden;}
+ul {list-style-type: none;margin: 0;padding: 0;}
+li{display: inline; float:left;border:5px; position:relative;text-align:center;}
+a {
+    float:left;
+    text-decoration:none;
+    display: inline;
+    text-align: center;
+	padding:5px;
+	padding-bottom:0px;
+	padding-top:0px;
+    color: #FFFFFF;
+    background-color: #343434;
+}
+a:hover, a:active{
+	background-color: #000000;
+}
+
+ul ul {
+    position:absolute;
+    left:0;
+    top:100%;
+    margin-left:-999em;
+}
+li:hover ul {
+    margin-left:0;
+    margin-right:0;
+}
+ul li ul{ display:block;float:none;}
+ul li ul li{ display:block;float:none;}
+li li a{ display:block;float:none;text-align:left;word-break: keep-all;white-space: nowrap;}
+#nav li:hover div {margin-left:0;}
+.dropzone {display:flex;justify-content:center;align-items:center;font-size:50px;position: fixed; top: 0; left: 0; z-index: 9999999999; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);transition: visibility 175ms, opacity 175ms;}
+.help {position:absolute;z-index:5;text-align:left;padding:2px;background-color: #313131;width:300px;}
+.helpstart {position:absolute;z-index:5;text-align:left;padding:2px;background-color: #313131;width:300px;display:none}
+.root {z-index:1;position:absolute;top:0px;left:0px;}
+.filterinput0{position:fixed;bottom:10px;left:25px;background-color: #313131}
+.filterinput1{position:fixed;bottom:10px;left:175px;background-color: #313131}
+.filterinputsearchdiv{position:fixed; background-color: #313131;display:none;}
+.filterinputsearchdivmenu{position:absolute; background-color: #313131;display:none;}
+.filterinputsearch{width:100px;}
+.filtersearchdiv{position:fixed;top:71px;right:75px; display:block;}
+.filterinputsearch2{width:100px;}
+</style>
+</head>
+<body style="">	
+<input type="file" id="file-input" style="display:none"/>
+<div style="visibility:hidden; opacity:0" class="dropzone" ondrop="DropHandler(event);" ondragover="DragOverHandler(event);">drop .html file to compare</div>
+<div class="filtersearchdiv" id="filtersearchdiv"><input type="text" id="FilterInputSearch2" class="filterinputsearch2"></div>
+<div id='filterinput'>
+<div class="filterinput0">Group<br><input type="text" id="filtergroup"></div>
+<div class="filterinput1">Timer/Thread<br><input type="text" id="filtertimer"></div>
+</div>
+<div class="filterinputsearchdiv" id="FilterInputDiv">Filter<br><input type="text" id="FilterInput" class="filterinputsearch"></div>
+<div class="filterinputsearchdivmenu" id="FilterInputMenuDiv">Filter<br><input type="text" id="FilterInputMenu" class="filterinputsearch"></div>
+<canvas id="History" height="70" style="background-color:#343434;margin:0px;padding:0px;"></canvas>
+<canvas id="DetailedView" height="200" style="background-color:#343434;margin:0px;padding:0px;"></canvas>
+<canvas id="CanvasMenu" style="pointer-events:none;position:absolute;top:0;left:0;margin:0px;padding:0px;zIndex:1" height="500" width="500"></canvas>
+<div class="help" id="divFrameInfo" style="display:none;left:20px;top:300px;width:auto;"></div>
+<div class="helpstart" id="helpwindow" style="left:20px;top:20px">
+History View:<br>
+Click + Drag: Pan View<br>
+Right Click + Drag : Zoom on region<br>
+Click Frame : Center on frame<br>
+<hr>
+Main View:<br>
+Ctrl + Mouse up/down: Zoom<br>
+Mousewheel : Zoom<br>
+Right Click + Drag: Select region<br>
+Ctrl + Shift + Drag: Select region<br>
+Space: Zoom to Selection<br>
+Ctrl + Drag: Pan<br>
+Click + Drag: Pan<br>
+hold alt: Show tooltip from timer view in detailed, detailed in timer<br>
+x : Toggle View<br>
+\ : Switch color mode<br>
+c : toggle collapse mode<br>
+tab : go to filter view<br>
+<hr>
+Detailed View:<br>
+Tab: Go To Worst Instance<br>
+Left/Right Arror: Next/Prev Instance<br>
+Enter: Search for timer in view<br>
+<hr>
+Timer Views:<br>
+Tab: go to filtering<br>
+Esc: Exit &amp; Clear filter
+<hr>
+<table style="width:100%">
+<tr>
+<td width="50%" align="left"><a href='javascript:void(0)' onclick="ShowHelp(0, 0);">Close</a></td>
+<td width="50%" align="right"><a href='javascript:void(0)' onclick="ShowHelp(0, 1);">Close, Never Show</a></td>
+</tr>
+</table>
+</div>
+<script>
+/**
+ * From https://gist.github.com/vahidk/05184faf3d92a0aa1b46aeaa93b07786
+ *
+ * @param {string} hexTripletColor
+ */
+function ConvertRgbToHsl(hexTripletColor) {
+	const color = parseInt(hexTripletColor.substring(1), 16);
+	const r = ((color >> 16) % 256)/255.0;
+	const g = ((color >> 8) % 256)/255.0;
+	const b = ((color >> 0) % 256)/255.0;
+	const max = Math.max(r, g, b);
+	const min = Math.min(r, g, b);
+	const d = max - min;
+	var h;
+	if (d === 0) h = 0;
+	else if (max === r) h = (g - b) / d % 6;
+	else if (max === g) h = (b - r) / d + 2;
+	else if (max === b) h = (r - g) / d + 4;
+	const l = (min + max) / 2;
+	const s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
+	return [h * 60, s, l];
+}
+
+/**
+ * From https://gist.github.com/vahidk/05184faf3d92a0aa1b46aeaa93b07786
+ *
+ * @param {number} h
+ * @param {number} s
+ * @param {number} l
+ */
+function ConvertHslToColor(h, s, l) {
+	const c = (1 - Math.abs(2 * l - 1)) * s;
+	const hp = h / 60.0;
+	const x = c * (1 - Math.abs((hp % 2) - 1));
+	let rgb1;
+	if (isNaN(h)) rgb1 = [0, 0, 0];
+	else if (hp <= 1) rgb1 = [c, x, 0];
+	else if (hp <= 2) rgb1 = [x, c, 0];
+	else if (hp <= 3) rgb1 = [0, c, x];
+	else if (hp <= 4) rgb1 = [0, x, c];
+	else if (hp <= 5) rgb1 = [x, 0, c];
+	else if (hp <= 6) rgb1 = [c, 0, x];
+	const m = l - c * 0.5;
+	const color = (Math.round(255 * (rgb1[0] + m)) << 16)
+		| (Math.round(255 * (rgb1[1] + m)) << 8)
+		| Math.round(255 * (rgb1[2] + m));
+	return '#' + ("000000" + color.toString(16)).slice(-6);
+}
+
+
+function ConvertColorDark(hexTripletColor)
+{
+	var color = hexTripletColor;
+	color = color.substring(1); // remove #
+	color = parseInt(color, 16); // convert to integer
+	// console.log(color.toString(16));
+	color = (color >> 1);
+	// console.log(color.toString(16));
+	color = color & 0x7f7f7f;
+	// console.log(color.toString(16));
+	return '#' + ("000000" + color.toString(16)).slice(-6);
+}
+function InvertColor(hexTripletColor)
+{
+	var color = hexTripletColor;
+	color = color.substring(1); // remove #
+	color = parseInt(color, 16); // convert to integer
+	var R = ((color >> 16) % 256)/255.0;
+	var G = ((color >> 8) % 256)/255.0;
+	var B = ((color >> 0) % 256)/255.0;
+	var lum = (0.2126*R + 0.7152*G + 0.0722*B);
+	if(lum < 0.7)
+	{
+		return '#ffffff';
+	}
+	else
+	{
+		return '#333333';
+	}
+}
+function InvertColorIndex(hexTripletColor) {
+	var color = hexTripletColor;
+	color = color.substring(1); // remove #
+	color = parseInt(color, 16); // convert to integer
+	var R = ((color >> 16) % 256)/255.0;
+	var G = ((color >> 8) % 256)/255.0;
+	var B = ((color >> 0) % 256)/255.0;
+	var lum = (0.2126*R + 0.7152*G + 0.0722*B);
+	if(lum < 0.7)
+	{
+		return 0;
+	}
+	else
+	{
+		return 1;
+	}
+}
+
+function MakeGroup(id, name, category, numtimers, isgpu, total, average, max, color)
+{
+	if(color == "")
+	{
+		color = ColorFromString(name, 40, 50);
+	}
+	var cid = GetColorIndex(color);
+	var group = {"id":id, "name":name, "category":category, "numtimers":numtimers, "isgpu":isgpu, "total": total, "average" : average, "max" : max, "cid":cid};
+	return group;
+}
+
+function MakeGroupCid(id, name, category, numtimers, isgpu, total, average, max, color, cid)
+{
+	var group = {"id":id, "name":name, "category":category, "numtimers":numtimers, "isgpu":isgpu, "total": total, "average" : average, "max" : max, "cid":cid};
+	return group;
+}
+
+function MakeTimer(id, name, group, color, colordark, average, max, min, exclaverage, exclmax, callaverage, callcount, total, meta, metaavg, metamax, flags)
+{
+	if(color == "#000000")
+	{
+		color = ColorFromString(name + "x" + group, 40, 50);
+		colordark = ColorFromString(name + "x" + group, 25, 50);
+	}
+	var spike = max <= 0 || average <= 0 ? 0 : (100 * max / average);
+	var cid = GetColorIndex(color);
+	var timer = {"id":id, "name":name, "len":name.length, "cid":cid, "timercid":cid, "group":group, "average":average, "max":max, "min":min, "exclaverage":exclaverage, "exclmax":exclmax, "callaverage":callaverage, "callcount":callcount, "spike":spike,"total":total, "meta":meta, "metaavg":metaavg, "metamax":metamax, "worst":0, "worststart":0, "worstend":0, "search":cid, "flags":flags};
+	return timer;
+}
+
+function MakeTimerCid(id, name, group, cid, average, max, min, exclaverage, exclmax, callaverage, callcount, total, meta, metaavg, metamax)
+{
+	var spike = max <= 0 || average <= 0 ? 0 : (100 * max / average);
+	var timer = {"id":id, "name":name, "len":name.length, "cid":cid, "timercid":cid, "group":group, "average":average, "max":max, "min":min, "exclaverage":exclaverage, "exclmax":exclmax, "callaverage":callaverage, "callcount":callcount, "spike":spike,"total":total, "meta":meta, "metaavg":metaavg, "metamax":metamax, "worst":0, "worststart":0, "worstend":0};
+	return timer;
+}
+
+function CloneTimer(T)
+{
+	return MakeTimerCid(T.id, T.name, T.group, T.cid, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
+}
+function CloneGroup(G)
+{
+	return MakeGroupCid(G.id, G.name, G.category, G.numtimers, G.isgpu, G.total, G.average, G.max, G.cid);
+}
+
+function MakeFrame(id, framestart, frameend, framestartgpu, frameendgpu, ts, tt, ti)
+{
+	var frame = {"id":id, "framestart":framestart, "frameend":frameend, "framestartgpu":framestartgpu, "frameendgpu":frameendgpu, "ts":ts, "tt":tt, "ti":ti};
+	return frame;
+}
+function MakeCounterHistory(id, history, prc)
+{
+	var counterhistory = {"id":id, "history":history, "prc":prc};
+	return counterhistory;
+}
+function MakeCounter(id, parent, sibling, firstchild, level, name, value, minvalue, maxvalue, formatted, limit, formattedlimit, counterprc, boxprc, format, counterhistory)
+{
+	var counter = { "id":id, "parent":parent, "sibling":sibling, "firstchild":firstchild, "level": level, "name":name, "value":value, "formatted":formatted, "limit":limit, "formattedlimit":formattedlimit, "counterprc":counterprc, "boxprc":boxprc, "counterhistory":counterhistory, "format":format, "minvalue":minvalue, "maxvalue":maxvalue};
+	return counter;
+}
+function Clamp(v, low, high)
+{
+	return v < low ? low : (v > high ? high : v);
+}
+function FormatTime(Time)
+{
+	return Time.toFixed(2);
+}
+
+
+
+var g_ColorMap = {};
+var g_Colors = new Array();
+var g_ColorsDark = new Array();
+var g_ColorsTextIndex = new Array();
+var g_ColorH = new Array();
+var g_ColorS = new Array();
+var g_ColorL = new Array();
+
+function GetColorIndex(color)
+{
+	if(g_ColorMap[color])
+	{
+		return g_ColorMap[color];
+	}
+	else
+	{
+		var idx = g_Colors.length;
+		g_ColorMap[color] = idx;
+		g_Colors.push(color);
+		g_ColorsDark.push(ConvertColorDark(color));
+		g_ColorsTextIndex.push(InvertColorIndex(color));
+		var hsl = ConvertRgbToHsl(color);
+		g_ColorH.push(hsl[0]);
+		g_ColorS.push(hsl[1]);
+		g_ColorL.push(hsl[2]);
+		return idx;
+	}
+}
+//color index 0 reserved for blinking
+var cidhovercolor = 0;
+g_Colors.push('#000000');
+g_ColorsDark.push('#000000');
+g_ColorsTextIndex.push(0);
+g_ColorH.push(0);
+g_ColorS.push(0);
+g_ColorL.push(0);
+
+const CIDMatch = GetColorIndex("#AA3333");
+const CIDFail = GetColorIndex("#555555");
+
+var S = {};
+var S2 = {};
+var Timeline = {};
+S.TimelineArray = [];
+S.TimelineIdArray = [];
+S.TimelineNames = [];
+S.TimelineColorArray = [];
+
+
+
+//EBEGIN
+____embed____
+//EEND
+
+var G_DEBUG = 0;
+
+
+const MP_LOG_LEAVE=0x0;
+const MP_LOG_ENTER=0x1;
+const MP_LOG_EXTENDED=0x2;
+const MP_LOG_EXTENDED_NO_DATA=0x3;
+
+const ETOKEN_GPU_CPU_TIMESTAMP=0x3fff;
+const ETOKEN_GPU_CPU_SOURCE_THREAD=0x3ffe;
+const ETOKEN_META_MARKER=0x3ffd;
+const ETOKEN_CUSTOM_NAME=0x3ffc;
+const ETOKEN_CUSTOM_COLOR=0x3ffb;
+const ETOKEN_CUSTOM_ID=0x3ffa;
+
+const ETOKEN_CSTR_PTR = 0x2000;
+const ETOKEN_MAX = 0x2000;
+
+
+
+var CanvasDetailedView = document.getElementById('DetailedView');
+var CanvasHistory = document.getElementById('History');
+var CanvasMenu = document.getElementById('CanvasMenu');
+var CanvasDetailedOffscreen = document.createElement('canvas');
+var FilterInputGroup = document.getElementById('filtergroup');
+var FilterInputTimer = document.getElementById('filtertimer');
+
+var FilterInput = document.getElementById('FilterInput');
+var FilterInputDiv = document.getElementById('FilterInputDiv');
+var FilterInputDivPos = {"x":-1,"y":-1,"w":-1,"h":-1};
+var FilterInputMenu = document.getElementById('FilterInputMenu');
+var FilterInputMenuDiv = document.getElementById('FilterInputMenuDiv');
+var FilterInputMenuDivPos = {"x":-1,"y":-1,"w":-1,"h":-1};
+var FilterInputMenuValueLast = '';
+
+var FilterInputSearch2 = document.getElementById('FilterInputSearch2');
+var FilterInputSearchValue = '';
+let FilterInputSearchActive2 = 0;
+
+const FLAGS_SECTION = 1;
+
+
+let LastDropTarget = null;
+
+var FilterInputGroupString = null;
+var FilterInputTimerString = null;
+var FilterInputArray = [FilterInputGroup, FilterInputTimer];
+var FilterGroup = null;
+var FilterTimer = null;
+var g_Msg = '0';
+
+var RedrawRequested = 0;
+var InsideDraw = 0;
+
+
+
+var Initialized = 0;
+var fDetailedOffset = S.Frames[0].framestart;
+var fDetailedOffsetSecond = 0;
+var fDetailedRange = S.Frames[S.Frames.length-1].frameend - fDetailedOffset;
+var nWidth = CanvasDetailedView.width;
+var nHeight = CanvasDetailedView.height;
+var ReferenceTimeString = 'auto';
+var ReferenceTimeAutoString = 'auto';
+var ReferenceTime = 33;
+var TargetTime = 16;
+var TargetTimeString = '16ms';
+var nHistoryHeight = 70;
+var nOffsetY = 0;
+var nOffsetBarsX = 0;
+var nOffsetBarsY = 0;
+var nOffsetCountersY = 0;
+var nOffsetFilterSearch = 0;
+var nOffsetMenuThreads = 0;
+var nOffsetMenuGroups = 0;
+var FilterInputSearchLast = '';
+var nBarsWidth = 80;
+var MouseButtonState = [0,0,0,0,0,0,0,0];
+var KeyShiftDown = 0;
+var KeyAltDown = 0;
+var KeyCtrlDown = 0;
+var MouseDragButton = 0;
+var ToolTipFlip = 0;
+var ToolTipCorner = 1;
+let ToolTipImmediate = null;
+var DetailedViewMouseX = 0;
+var DetailedViewMouseY = 0;
+var DetailedMouseOverButton = 0;
+var DetailedMouseEvent = null;
+var HistoryViewMouseX = -1;
+var HistoryViewMouseY = -1;
+var GlobalMouseX = -1;
+var GlobalMouseY = -1;
+var MouseReleased = false;
+var MouseHistory = 0;
+var MouseDetailed = 0;
+const FontName = 'Courier New';
+const FontHeight = 10;
+const FontHeightLarge = 22;
+const FontHeightFlash = 35;
+let FontWidth = 1;
+const FontAscent = 3; //Set manually
+const Font = 'Bold ' + FontHeight + 'px ' + FontName;
+const FontLarge = 'Bold ' + FontHeightLarge + 'px ' + FontName;
+const FontFlash = 'Bold ' + FontHeightFlash + 'px ' + FontName;
+const BoxHeight = FontHeight + 2;
+let ThreadsHidden = {};
+var GroupsDisabled = new Object();
+var nMinWidth = 0.01;//subpixel width
+var nMinWidthPan = 1.0;//subpixel width when panning
+var nContextSwitchEnabled = 1;
+var DisableLod = 0;
+var DisableMerge = 0;
+var GroupColors = 0;
+var DrawDetailedFlameMode = 0;
+var DrawDetailedNewDraw = 0;
+var DrawDetailedCompareReverse = 1;
+var nModDown = 0;
+var g_MSG = 'no';
+var nDrawCount = 0;
+var nBackColors = ['#292929', '#343434' ];
+var nBackColorsDark = ['#292929', '#272727' ];
+var nBackColorOffset = '#404040';
+var CSwitchColors =["#9DD8AF","#D7B6DA","#EAAC76","#DBDA61","#8AD5E1","#8CE48B","#C4D688","#57E5C4"];//generated by http://tools.medialab.sciences-po.fr/iwanthue/index.php
+var CSwitchHeight = 5;
+var FRAME_HISTORY_COLOR_CPU = '#ff7f27';
+var FRAME_HISTORY_COLOR_GPU = '#ffffff';
+var ZOOM_TIME = 0.5;
+var AnimationActive = false;
+var nHoverCSCpu = -1;
+var nHoverCSCpuNext = -1;
+var nHoverCSToolTip = null;
+var nHoverToken = -1;
+var HoverTokenOwner = null;
+//var nHoverFrame = -1;
+var nHoverTokenIndex = -1;
+var nHoverTokenLogIndex = -1;
+var nHoverCounter = 0;
+var nHoverCounterDelta = 8;
+var nHoverTokenNext = -1;
+var nHoverTokenLogIndexNext = -1;
+var nHoverTokenIndexNext = -1;
+var HoverTokenNextOwner = null;
+var nHoverCounter = -1;
+var nHoverTokenDrawn = -1;
+var nHideHelp = 0;
+var fFrameScale = 33.33;
+var SortColumn = 0;
+var SortColumnOrderFlip = 0;
+var SortColumnMouseOver = null;
+var SortColumnMouseOverNext = null;
+var ColumnsWidth = [];
+var ColumnsEnabled = [];
+let ColumnNames =["Average", "Max", "Total", "Min", "Spike", "Call Average", "Call Count", "Excl Average", "Excl Max"];
+let NumColumns = ColumnNames.length;
+while(ColumnsEnabled.length < NumColumns)
+{
+	ColumnsEnabled.push(1);
+	ColumnsWidth.push(20);
+}
+var FilterSearchActive = 0;
+var FilterSearchSelection = -1;
+var FilterSearchSelectionMax = 0;
+var FilterSearchPassIndex = -1;
+FilterSearchReset();
+var FilterSearchStartTime = new Date();
+var IgnoreInput = 0;
+function RangeInit()
+{
+	return {"Begin":-1, "End":-1, "YBegin":-1, "YEnd":-1, "Thread": -1 , "Index": -1, "Off": 0, "Second":0};
+}
+function RangeValid(Range)
+{
+	return Range.Begin < Range.End;
+}
+function RangeCopy(Dst, Src)
+{
+	Dst.Begin = Src.Begin;
+	Dst.End = Src.End;
+	Dst.YBegin = Src.YBegin;
+	Dst.YEnd = Src.YEnd;
+	Dst.Thread = Src.Thread;
+	Dst.Off = Src.Off;
+	Dst.Second = Src.Second;
+}
+var RangeCpu = RangeInit();
+var RangeGpu = RangeInit();
+var RangeSelect = RangeInit();
+
+var RangeCpuNext = RangeInit();
+var RangeGpuNext = RangeInit();
+
+var RangeCpuHistory = RangeInit();
+var RangeGpuHistory = RangeInit();
+
+var fRangeBegin = 0;
+var fRangeEnd = -1;
+var fRangeThreadId = -1;
+var fRangeThreadIdNext = -1;
+var fRangeBeginNext = 0;
+var fRangeEndNext = 0;
+var fRangeBeginGpuNext = 0;
+var fRangeEndGpuNext = 0;
+var fRangeBeginHistory = -1;
+var fRangeEndHistory = -1;
+var fRangeBeginHistoryGpu = -1;
+var fRangeEndHistoryGpu = -1;
+var fRangeBeginSelect = 0;
+var fRangeEndSelect = -1;
+var ThreadYBegin;
+var ThreadYEnd;
+
+var ModeDetailed = 0;
+var ModeTimers = 1;
+var ModeTimers_Threads = 2;
+var ModeTimers_Groups = 3;
+var ModeCounters = 4;
+var ModeCount = 5;
+var Mode = ModeDetailed;
+
+var DebugDrawQuadCount = 0;
+var DebugDrawTextCount = 0;
+var ProfileMode = 0;
+var ProfileRedraw0 = 0;
+var ProfileRedraw1 = 0;
+var ProfileRedraw2 = 0;
+var ProfileFps = 0;
+var ProfileFpsAggr = 0;
+var ProfileFpsCount = 0;
+var ProfileLastTimeStamp = new Date();
+
+var ProfileData = {};
+var ProfileStackTime = {};
+var ProfileStackName = {};
+let ProfileDrawStartLast = new Date();
+let ProfileDrawEndLast = new Date();
+function CreateEmptyFloatArray(Size)
+{
+	let a = Array(Size);
+	for(let i = 0; i < Size; ++i)
+		a[i] = 0.0;
+	return a;
+}
+let ProfileDrawTime = CreateEmptyFloatArray(120);
+let ProfileDeltaTime = CreateEmptyFloatArray(120);
+let ProfileDraw2Draw = CreateEmptyFloatArray(120);
+
+var Debug = 1;
+
+var ThreadLogAutoHide = 0;
+var NumLodSplits = 10;
+var SplitMin = 100;
+var SPLIT_LIMIT = 1e20;
+var DPR = 1;
+var DetailedRedrawState = {};
+var OffscreenData;
+var DetailedFrameCounter = 0;
+var Invalidate = 0;
+var GroupOrder = Array();
+var ThreadOrder = Array();
+var ThreadOrderNames = Array();
+var ThreadOrderT = Array();
+var MetaLengths = Array();
+var MetaLengthsAvg = Array();
+var MetaLengthsMax = Array();
+
+var ZoomActive = 0;
+
+var StrGroup = "Group";
+var StrThread = "Thread";
+var StrTimer = "Timer";
+var StrAverage = "Average";
+var StrMax = "Max";
+var StrTotal = "Total";
+var StrMin = "Min";
+var StrSpike = "Spike%";
+var StrCallAverage = "Call Average";
+var StrCount = "Count";
+var StrExclAverage = "Excl Average";
+var StrExclMax = "Excl Max";
+
+var GroupRemapReverse = [];
+var TimerRemapReverse = [];
+var ThreadRemapReverse = [];
+
+let SubMenuHelp = 0;
+let SubMenuMode = 1;
+let SubMenuReference = 2;
+let SubMenuTarget = 3;
+let SubMenuThreads = 4;
+let SubMenuGroups = 5;
+let SubMenuColumns = 6;
+let SubMenuOptions = 7;
+let SubMenuCompare = 8;
+
+let MenuRedraw = 0;
+let SubMenuActive = -1;
+let SubMenuTimeoutBase = 0.7;
+let SubMenuMouseX = 0;
+let SubMenuMouseY = 0;
+let SubMenuTimeout = new Date();
+let MenuItems = [];
+let FilterInputMenuThreadsValue = '';
+let FilterInputMenuGroupsValue = '';
+let MouseMoveTime = new Date();
+let ReferenceTimes = [-1, 5, 10, 15, 16, 20, 30, 33, 50, 100, 250, 500, 1000];
+let TargetTimes = [5, 10, 15, 16, 20, 30, 33, 50, 100, 250, 500, 1000];
+let ModeItems = ["Detailed", "Timers", "Threads", "Groups", "Counters"];
+let HideModeFullyHidden = 0;
+let HideModeCollapsed = 1;
+let HideMode = HideModeCollapsed;
+
+
+function ProfileModeClear()
+{
+	if(ProfileMode)
+	{
+		ProfileData = new Object();
+		ProfileStackTime = new Array();
+		ProfileStackName = new Array();
+	}
+}
+function ProfileEnter(Name)
+{
+	if(ProfileMode)
+	{
+		ProfileStackTime.push(new Date());
+		ProfileStackName.push(Name);
+	}
+}
+function ProfileLeave()
+{
+	if(ProfileMode)
+	{
+		var Time = new Date();
+		var Delta = Time - ProfileStackTime.pop();
+		var Name = ProfileStackName.pop();
+		var Obj = ProfileData[Name];
+		if(!Obj)
+		{
+			Obj = new Object();
+			Obj.Count = 0;
+			Obj.Name = Name;
+			Obj.Time = 0;
+			ProfileData[Name] = Obj;
+		}
+		Obj.Time += Delta;
+		Obj.Count += 1;
+	}
+}
+
+function ProfilePlot(s)
+{
+	if(ProfileMode)
+	{
+		var A = ProfileData.Plot;
+		if(!A)
+		{
+			ProfileData.Plot = Array();
+			A = ProfileData.Plot;
+		}
+		if(A.length<10)
+		{
+			A.push(s);
+		}
+	}
+}
+function ProfileModeDump()
+{
+	for(var idx in ProfileData)
+	{
+		var Timer = ProfileData[idx];
+		console.log(Timer.Name + " " + Timer.Time + "ms " + Timer.Count);
+	}
+}
+
+function ProfileDrawFrameTimeGraph(context)
+{
+	if(ProfileMode)
+	{
+		let Params = CreateDrawGraphParameters();
+		let Mouse = {};
+		Mouse.X = DetailedViewMouseX;
+		Mouse.Y = DetailedViewMouseY;
+		Params.RangeMin = 0;
+		Params.RangeMax = 50;
+
+		let DrawTimeData = CreateGraphData(ProfileDrawTime, "DrawTime", "#ff2288");
+		let DeltaTimeData = CreateGraphData(ProfileDeltaTime, "DeltaTime", "#2288ee");
+		let Draw2DrawData = CreateGraphData(ProfileDraw2Draw, "Draw2Draw", "#11aa33");
+
+		{
+			Params.Rect = WindowRect(0, nHeight-200, 200, 200);
+
+			DrawGraph(context, Params, [DrawTimeData], Mouse);
+		}
+		{
+			Params.Rect = WindowRect(200, nHeight-200, 200, 200);
+
+			DrawGraph(context, Params, [DeltaTimeData], Mouse);
+		}
+		{
+			Params.Rect = WindowRect(400, nHeight-200, 200, 200);
+			DrawGraph(context, Params, [Draw2DrawData], Mouse);
+		}
+		{
+			Params.Rect = WindowRect(610, nHeight-200, 200, 200);
+			DrawGraph(context, Params, [DrawTimeData, DeltaTimeData,Draw2DrawData], Mouse);
+		}
+	}
+}
+
+function ProfileModeDraw(Canvas)
+{
+	if(ProfileMode)
+	{
+		var StringArray = [];
+		for(var idx in ProfileData)
+		{
+			if(idx == "Plot")
+				continue;
+			var Timer = ProfileData[idx];
+			StringArray.push(Timer.Name);
+			StringArray.push(Timer.Time + "ms");
+			StringArray.push("#");
+			StringArray.push("" + Timer.Count);
+		}
+		StringArray.push("debug");
+		StringArray.push(Debug);
+		var Time = new Date();
+		var Delta = Time - ProfileLastTimeStamp;
+		ProfileLastTimeStamp = Time;
+		StringArray.push("Frame Delta");
+		StringArray.push(Delta + "ms");
+		if(ProfileMode == 2)
+		{
+			ProfileFpsAggr += Delta;
+			ProfileFpsCount ++ ;
+			var AggrFrames = 10;
+			if(ProfileFpsCount == AggrFrames)
+			{
+				ProfileFps = 1000 / (ProfileFpsAggr / AggrFrames);
+				ProfileFpsAggr = 0;
+				ProfileFpsCount = 0;
+			}
+			StringArray.push("FPS");
+			StringArray.push("" + ProfileFps.toFixed(2));
+		}
+		StringArray.push("ProfileRedraw0");
+		StringArray.push("" + ProfileRedraw0);
+		StringArray.push("ProfileRedraw1");
+		StringArray.push("" + ProfileRedraw1);
+		StringArray.push("ProfileRedraw2");
+		StringArray.push("" + ProfileRedraw2);
+		ProfileRedraw0 = 0;
+		ProfileRedraw1 = 0;
+		ProfileRedraw2 = 0;
+
+
+		for(var i = 0; i < ProfileData.Plot; ++i)
+		{
+			StringArray.push("");
+			StringArray.push(ProfileData.Plot[i]);
+		}
+		ProfileData.Plot = Array();
+		DrawToolTip(StringArray, Canvas, 0, 200);
+	}
+}
+
+function ToggleDebugMode()
+{
+	ProfileMode = (ProfileMode+1)%4;
+	console.log('Toggle Debug Mode ' + ProfileMode);
+}
+
+function DetailedTotal(S)
+{
+	var Total = 0;
+	for(var i = 0; i < S.Frames.length; i++)
+	{
+		var frfr = S.Frames[i];
+		Total += frfr.frameend - frfr.framestart;
+	}
+	return Total;
+}
+
+
+function InitFrameInfo()
+{
+
+	var div = document.getElementById('divFrameInfo');
+	var txt = '';
+	txt = txt + 'Timers View' + '<br>';
+	txt = txt + 'Frames:' + S.AggregateInfo.Frames +'<br>';
+	txt = txt + 'Time:' + S.AggregateInfo.Time.toFixed(2) +'ms<br>';
+	txt = txt + '<hr>';
+	txt = txt + 'Detailed View' + '<br>';
+	txt = txt + 'Frames:' + S.Frames.length +'<br>';
+	txt = txt + 'Time:' + DetailedTotal(S).toFixed(2) +'ms<br>';
+	div.innerHTML = txt;
+}
+function InitGroups()
+{
+	for(groupid in S.GroupInfo)
+	{
+		var TimerArray = Array();
+		for(timerid in S.TimerInfo)
+		{
+			if(S.TimerInfo[timerid].group == groupid)
+			{
+				TimerArray.push(timerid);
+			}
+		}
+		S.GroupInfo[groupid].TimerArray = TimerArray;
+	}
+}
+
+
+function ThreadOrderMove(Name, Dir, Top)
+{
+	let idx = ThreadOrderNames.indexOf(Name);
+	let base = idx;
+	idx += Dir;
+	let found = -1;
+	while(idx >= 0 && idx <= ThreadOrderNames.length)
+	{
+		let n = S.ThreadNames.indexOf(ThreadOrderNames[idx]);
+		if(n != -1)
+		{
+			found = idx;
+			if(!Top)
+				break;
+		}
+		idx += Dir;
+	}
+	Dir = -Dir;
+	while(found >= 0 && found <= ThreadOrderNames.length && (Dir > 0 ? (found <= base) : (found >= base)))
+	{
+		let Tmp = ThreadOrderNames[found];
+		ThreadOrderNames[found] = Name;
+		Name = Tmp;
+		found += Dir;
+	}
+	ThreadOrderSort();
+}
+function ThreadOrderMoveUp(Name, Top)
+{
+	ThreadOrderMove(Name, -1, Top);
+	WriteCookie();
+}
+function ThreadOrderMoveDown(Name, Top)
+{
+	ThreadOrderMove(Name, 1, Top);
+	WriteCookie();
+}
+function ThreadOrderSort()
+{
+	for(let i = 0; i < S.ThreadNames.length; ++i)
+	{
+		var name = S.ThreadNames[i];
+		var idx = ThreadOrderNames.indexOf(name);
+		if(idx == -1)
+		{
+			ThreadOrderNames.push(name);
+		}
+	}
+
+	//clear all that are not present??
+	let ThreadOrderX = Array(S.ThreadNames.length);
+	for(let i = 0; i < S.ThreadNames.length; ++i)
+	{
+		let isgpu = S.ISGPU[i]?1:0;
+		var n = ThreadOrderNames.indexOf(S.ThreadNames[i]);
+		if(n == -1)
+		{
+			debugger;
+		}
+		ThreadOrderX[i] = {"i":i, "n": n, "g":isgpu};
+	}
+	ThreadOrderX.sort(function(l,r){if(l.g!=r.g)return r.g-l.g;return l.n-r.n;}); //sort gpu first
+	ThreadOrderT = Array(S.ThreadNames.length);
+	for(let i = 0; i < S.ThreadNames.length; ++i)
+	{
+		ThreadOrderT[i] = ThreadOrderX[i].i;
+	}
+}
+function IsThreadActive(ThreadName)
+{
+	return !ThreadsHidden[ThreadName];
+}
+
+function ToggleThread(ThreadName, All, FilterArray, State)
+{
+	if(ThreadName)
+	{
+		if(ThreadsHidden[ThreadName])
+		{
+			delete ThreadsHidden[ThreadName];
+		}
+		else
+		{
+			ThreadsHidden[ThreadName] = 1;
+		}
+	}
+	else
+	{
+		let Names = All ? S.ThreadNames : FilterArray;
+
+		for(let i in Names)
+		{
+			switch(State)
+			{
+				case 0: if(!ThreadsHidden[Names[i]]){ ThreadsHidden[Names[i]] = 1;} break;
+				case 1: ThreadsHidden[Names[i]] = ThreadsHidden[Names[i]] ? 0 : 1; break;
+				case 2: if(ThreadsHidden[Names[i]]){ delete ThreadsHidden[Names[i]];} break;
+			}
+		}
+	}
+	RequestRedraw();
+	Invalidate = 0;
+	FilterSearchReset();
+	WriteCookie();
+}
+
+
+function CreateOrderArray(Source, NameFunc)
+{
+	var Temp = Array(Source.length);
+	for(var i = 0; i < Source.length; ++i)
+	{
+		Temp[i] = {};
+		Temp[i].index = i;
+		Temp[i].namezz = NameFunc(Source[i]).toLowerCase();
+	}
+	Temp.sort(function(l, r)
+	{
+		if(r.namezz<l.namezz)
+			{return 1;}
+		if(l.namezz<r.namezz)
+			{return -1;}
+		return 0;
+	} );
+	var OrderArray = Array(Source.length);
+	for(var i = 0; i < Source.length; ++i)
+	{
+		OrderArray[i] = Temp[i].index;
+	}
+	return OrderArray;
+}
+
+function InitOrderArrays()
+{
+	ThreadOrder = [];
+	ThreadOrder = CreateOrderArray(S.ThreadNames, function(a){return a;});
+
+
+	let MaxLen = 7;
+	let MenuArray = Array();
+	for(let i = 0; i < S.GroupInfo.length; ++i)
+	{
+		let x = {};
+		x.IsCategory = 0;
+		x.category = S.GroupInfo[i].category;
+		x.name = S.GroupInfo[i].name;
+		x.index = i;
+		MenuArray.push(x);
+	}
+	for(let i = 0; i < S.CategoryInfo.length; ++i)
+	{
+		let x = {};
+		x.IsCategory = 1;
+		x.category = i;
+		x.name = S.CategoryInfo[i];
+		x.index = i;
+		MenuArray.push(x);
+	}
+	let OrderFunction = function(a){ return a.category + "__" + a.name; };
+	let OrderFunctionMenu = function(a){ return a.IsCategory ? (a.category + '') : (a.category + "__" + a.name); };
+	GroupOrder = CreateOrderArray(S.GroupInfo, OrderFunction);
+}
+
+function CategoryIndex(CategoryName)
+{
+	for(var i = 0; i < S.CategoryInfo.length; ++i)
+	{
+		if(S.CategoryInfo[i] == CategoryName)
+		{
+			return i;
+		}
+	}
+	return -1;
+}
+function IsCategoryActive(CategoryIdx)
+{
+	for(var i = 0; i < S.GroupInfo.length; ++i)
+	{
+		if(S.GroupInfo[i].category == CategoryIdx)
+		{
+			var Name = S.GroupInfo[i].name;
+			if(!GroupsActive[Name])
+			{
+				return false;
+			}
+		}
+	}
+	return true;
+
+}
+function ToggleCategory(CategoryName, WantRedraw)
+{
+	var CategoryIdx = CategoryIndex(CategoryName);
+	if(CategoryIdx < 0)
+		return;
+	var CategoryActive = IsCategoryActive(CategoryIdx);
+	for(var i = 0; i < S.GroupInfo.length; ++i)
+	{
+		if(S.GroupInfo[i].category == CategoryIdx)
+		{
+			var Name = S.GroupInfo[i].name;
+			if(CategoryActive)
+			{
+				delete GroupsDisabled[Name];
+			}
+			else
+			{
+				GroupsDisabled[Name] = 1;
+			}
+		}
+	}
+	WriteCookie();
+	if(WantRedraw)
+	{
+		RequestRedraw();
+	}
+}
+
+function ToggleGroup(GroupName, All, FilterArray, State)
+{
+	if(GroupName)
+	{
+		if(GroupsDisabled[GroupName])
+		{
+			delete GroupsDisabled[GroupName];
+		}
+		else
+		{
+			GroupsDisabled[GroupName] = 1;
+		}
+	}
+	else
+	{
+		let Names = FilterArray;
+		if(All)
+		{
+			Names = [];
+			for(let i in S.GroupInfo)
+			{
+				Names.push(S.GroupInfo[i].name);
+			}
+		}
+
+		for(let i in Names)
+		{
+			let N = Names[i];
+			switch(State)
+			{
+				case 2: if(GroupsDisabled[N]){ delete GroupsDisabled[N];} break;
+				case 1:
+					if(GroupsDisabled[N])
+					{
+						delete GroupsDisabled[N];
+					}
+					else
+					{
+						GroupsDisabled[N] = 1;
+					}
+
+					break;
+				case 0: if(!GroupsDisabled[N]){ GroupsDisabled[N] = 1;} break;
+			}
+		}
+	}
+	WriteCookie();
+}
+
+function UpdateGroupColors()
+{
+	for(var i = 0; i < S.TimerInfo.length; ++i)
+	{
+		if(GroupColors == 1)
+		{
+			S.TimerInfo[i].cid = S.GroupInfo[S.TimerInfo[i].group].cid;
+		}
+		else
+		{
+			S.TimerInfo[i].cid = S.TimerInfo[i].timercid;
+		}
+	}
+}
+function ToggleDetailedFlameMode(WantRedraw)
+{
+	DrawDetailedFlameMode = (DrawDetailedFlameMode+1)%3;
+	WriteCookie();
+	if(WantRedraw)
+	{
+		RequestRedraw();
+	}
+}
+
+function ToggleDetailedNewDraw()
+{
+	DrawDetailedNewDraw = DrawDetailedNewDraw ? 0 : 1;
+	WriteCookie();
+	RequestRedraw();
+}
+
+
+
+function ToggleDetailedSecondReverse(WantRedraw)
+{
+	DrawDetailedCompareReverse = 1-DrawDetailedCompareReverse;
+	WriteCookie();
+	if(WantRedraw)
+	{
+		RequestRedraw();
+	}
+}
+
+function ToggleGroupColors(WantRedraw)
+{
+	GroupColors = (GroupColors+1)%4;
+	UpdateGroupColors();
+	WriteCookie();
+	if(WantRedraw)
+	{
+		RequestRedraw();
+	}
+}
+
+function ShowHelp(Show, Forever)
+{
+	var HelpWindow = document.getElementById('helpwindow');
+	if(Show)
+	{
+		HelpWindow.style['display'] = 'block';
+	}
+	else
+	{
+		HelpWindow.style['display'] = 'none';
+	}
+	if(Forever)
+	{
+		nHideHelp = Show ? 0 : 1;
+		WriteCookie();
+	}
+}
+function ToggleMode()
+{
+	Mode = (Mode + 1) % ModeCount;
+	SetMode(Mode);
+}
+
+function SetMode(NewMode, WantRedraw)
+{
+	ResetColumnWidth();
+	Mode = NewMode;
+	if(Mode == ModeTimers || Mode == ModeTimers_Groups || Mode == ModeTimers_Threads)
+	{
+		SetFilterInput(FilterInputGroupString, FilterInputTimerString);
+	}
+	else
+	{
+		ShowFilterInput(0);
+	}
+	ShowDetailedSearch(Mode == ModeDetailed);
+
+	WriteCookie();
+	if(WantRedraw)
+	{
+		RequestRedraw();
+	}
+}
+
+
+function UpdateReferenceTime()
+{
+	S.CaptureStartTime = S.Frames[0].framestart;
+	S.CaptureEndTime = S.Frames[S.Frames.length-1].frameend;
+
+	if('auto' == ReferenceTimeString.substring(0,4))
+	{
+		let Max = 0.1;
+		for(var i = 0; i < S.Frames.length; ++i)
+		{
+			let T = S.Frames[i].frameend - S.Frames[i].framestart;
+			Max = Math.max(T, Max);
+		}
+		ReferenceTime = Max*1.20;
+		if(TargetTime>0)
+		{
+			ReferenceTime = Math.max(ReferenceTime, TargetTime * 1.33);
+		}
+		ReferenceTimeAutoString = 'auto [' + Max.toFixed(2) + 'ms]';
+	}
+	else
+	{
+		ReferenceTime = parseInt(ReferenceTimeString);
+	}
+}
+
+function SetReferenceTime(TimeString, WantRedraw)
+{
+	ReferenceTimeString = TimeString;
+	UpdateReferenceTime();
+	WriteCookie();
+	if(WantRedraw)
+	{
+		RequestRedraw();
+	}
+}
+
+function SetTargetTime(TimeString, WantRedraw)
+{
+	TargetTimeString = TimeString;
+	TargetTime = parseInt(TargetTimeString);
+	WriteCookie();
+	if(WantRedraw)
+	{
+		RequestRedraw();
+	}
+}
+
+function ToggleContextSwitch()
+{
+	SetContextSwitch(nContextSwitchEnabled ? 0 : 1);
+}
+
+function SetContextSwitch(Enabled, WantRedraw)
+{
+	nContextSwitchEnabled = Enabled ? 1 : 0;
+	WriteCookie();
+	if(WantRedraw)
+	{
+		RequestRedraw();
+	}
+}
+function PushIntoArray(A, v)
+{
+	A.shift();
+	A.push(v);
+}
+function ToggleDebug()
+{
+	Debug = (Debug + 1) % 2;
+}
+
+function ToggleDisableMerge()
+{
+	DisableMerge = DisableMerge ? 0 : 1;
+}
+function ToggleDisableLod()
+{
+	DisableLod = DisableLod ? 0 : 1;
+}
+
+function GatherHoverMetaCounters(TimerIndex, StartIndex, nLog, nFrameLast)
+{
+	var HoverInfo = new Object();
+	return HoverInfo;
+	var StackPos = 1;
+	//search backwards, count meta counters
+	for(var i = nFrameLast; i >= 0; i--)
+	{
+		var fr = S.Frames[i];
+		var ts = fr.ts[nLog];
+		var ti = fr.ti[nLog];
+		var tt = fr.tt[nLog];
+		var start = i == nFrameLast ? StartIndex-1-fr.LogStart[nLog] : ts.length-1;
+
+		for(var j = start; j >= 0; j--)
+		{
+			var type = tt[j];
+			var index = ti[j];
+			var time = ts[j];
+			if(type == 1)
+			{
+				StackPos--;
+				if(StackPos == 0 && index == TimerIndex)
+				{
+					return HoverInfo;
+				}
+			}
+			else if(type == 0)
+			{
+				StackPos++;
+			}
+			else if(type > 1)
+			{
+				// var nMetaCount = type - 3;
+				// var nMetaIndex = MetaNames[index];
+				// if(nMetaIndex in HoverInfo)
+				// {
+				// 	HoverInfo[nMetaIndex] += nMetaCount;
+				// }
+				// else
+				// {
+				// 	HoverInfo[nMetaIndex] = nMetaCount;
+				// }
+			}
+		}
+	}
+}
+function CalculateAllTimers(fBegin, fEnd)
+{
+	var Sum = [];
+	var Count = [];
+	var Sorted = [];
+	for(var i = 0; i < S.TimerInfo.length; ++i)
+	{
+		Sum.push(0.0);
+		Count.push(0);
+		Sorted.push(i);
+	}
+	var nFrameFirst = 0;
+	var nFrameLast = S.Frames.length;
+
+	var nNumLogs = S.Frames[0].ts.length;
+	var StackPosArray = Array(nNumLogs);
+	var StackArray = Array(nNumLogs);
+	for(var i = 0; i < nNumLogs; ++i)
+	{
+		StackPosArray[i] = 0;
+		StackArray[i] = Array(20);
+	}
+
+	for(var i = nFrameFirst; i < nFrameLast; i++)
+	{
+		var fr = S.Frames[i];
+		for(nLog = 0; nLog < nNumLogs; nLog++)
+		{
+			var StackPos = StackPosArray[nLog];
+			var Stack = StackArray[nLog];
+			var ts = fr.ts[nLog];
+			var ti = fr.ti[nLog];
+			var tt = fr.tt[nLog];
+			var count = ts.length;
+			for(j = 0; j < count; j++)
+			{
+				var type = tt[j];
+				var index = ti[j];
+				var time = ts[j];
+				if(type == 1 && time < fEnd) //enter
+				{
+					Stack[StackPos] = time < fBegin ? fBegin : time;
+					if(StackArray[nLog][StackPos] != time)
+					{
+						console.log('fail fail fail');
+					}
+					StackPos++;
+				}
+				else if(type == 0) // leave
+				{
+					if(StackPos>0)
+					{
+						var timeend = time;
+						StackPos--;
+						timestart = Stack[StackPos];
+						var TimeDelta = timeend - timestart;
+						Sum[index] += TimeDelta;
+						Count[index]++;
+					}
+				}
+			}
+			StackPosArray[nLog] = StackPos;
+		}
+	}
+	Sorted.sort(function(a,b){ return Sum[b] - Sum[a]; } );
+	var Result = {"Sorted" : Sorted, "Sum" : Sum, "Count" : Count};
+	return Result;
+}
+
+function CalculateTimers2(Result, TimerIndex, Time, SContext)
+{
+	let nFrame = -1;
+	for(var i = 0; i < SContext.Frames.length; ++i)
+	{
+		let F = SContext.Frames[i];
+		if(Time > F.framestart && Time <= F.frameend)
+		{
+			nFrame = i;
+			break;
+		}
+	}
+	CalculateTimers(Result, TimerIndex, nFrame, nFrame+1, SContext);
+	return nFrame;
+}
+
+function CalculateTimers(Result, TimerIndex, nFrameFirst, nFrameLast, SContext)
+{
+	if(!SContext)
+		SContext = S;
+	if(!nFrameFirst || nFrameFirst < 0)
+		nFrameFirst = 0;
+	if(!nFrameLast || nFrameLast > SContext.Frames.length)
+		nFrameLast = SContext.Frames.length;
+	var FrameCount = nFrameLast - nFrameFirst;
+	if(0 == FrameCount)
+		return;
+	var CallCount = 0;
+	var Sum = 0;
+	var Max = 0;
+	var FrameMax = 0;
+
+	var nNumLogs = SContext.Frames[0].ts.length;
+	var StackPosArray = Array(nNumLogs);
+	var StackArray = Array(nNumLogs);
+	let StackIndexArray = Array(nNumLogs);
+	for(var i = 0; i < nNumLogs; ++i)
+	{
+		StackPosArray[i] = 0;
+		StackArray[i] = Array(32);
+		StackIndexArray[i] = Array(32);
+	}
+
+	for(var i = nFrameFirst; i < nFrameLast; i++)
+	{
+		let FrameSum = 0;
+		let fr = SContext.Frames[i];
+		for(nLog = 0; nLog < nNumLogs; nLog++)
+		{
+			let StackPos = StackPosArray[nLog];
+			let Stack = StackArray[nLog];
+			let StackIndex = StackIndexArray[nLog];
+			var ts = fr.ts[nLog];
+			var ti = fr.ti[nLog];
+			var tt = fr.tt[nLog];
+			var count = ts.length;
+			for(var j = 0; j < count; j++)
+			{
+				var type = tt[j];
+				var index = ti[j];
+				var time = ts[j];
+				if(index < ETOKEN_MAX)
+				{
+					if(type == 1) //enter
+					{
+						//push
+						Stack[StackPos] = time;
+						StackIndex[StackPos] = index;
+						if(StackArray[nLog][StackPos] != time)
+						{
+							console.log('fail fail fail');
+						}
+						StackPos++;
+					}
+					else if(type == 0) // leave
+					{
+						var timestart;
+						var timeend = time;
+						if(StackPos>0)
+						{
+							StackPos--;
+							timestart = Stack[StackPos];
+						}
+						else
+						{
+							timestart = SContext.Frames[nFrameFirst].framestart;
+						}
+						if(index == TimerIndex)
+						{
+							let TimeDelta = timeend - timestart;
+							CallCount++;
+							FrameSum += TimeDelta;
+							Sum += TimeDelta;
+							if(TimeDelta > Max)
+								Max = TimeDelta;
+						}
+					}
+					else
+					{
+						//meta
+					}
+				}
+			}
+			if(i == nFrameLast - 1)
+			{
+				for(var j = 0; j < StackPos; ++j)
+				{
+					if(StackIndex[j] == TimerIndex)
+					{
+						let LastFrameEnd = SContext.Frames[nFrameLast-1].frameend;
+						let TimeDelta = LastFrameEnd - Stack[j];
+						CallCount++;
+						FrameSum += TimeDelta;
+						Sum += TimeDelta;
+						if(TimeDelta > Max)
+							Max = TimeDelta;
+						break;
+					}
+				}
+
+			}
+			if(FrameSum > FrameMax)
+			{
+				FrameMax = FrameSum;
+			}
+			StackPosArray[nLog] = StackPos;
+		}
+	}
+
+	Result.CallCount = CallCount;
+	Result.Sum = Sum.toFixed(3);
+	Result.Max = Max.toFixed(3);
+	Result.Average = (Sum / CallCount).toFixed(3);
+	Result.FrameAverage = (Sum / FrameCount).toFixed(3);
+	Result.FrameCallAverage = (CallCount / FrameCount).toFixed(3);
+	Result.FrameMax = FrameMax.toFixed(3);
+	return Result;
+}
+
+function PreprocessCalculateAllTimers()
+{
+	ProfileEnter("CalculateAllTimers");
+	var nFrameFirst = 0;
+	var nFrameLast = S.Frames.length;
+	var FrameCount = nFrameLast - nFrameFirst;
+	if(0 == FrameCount)
+		return;
+	for(var j = 0; j < S.TimerInfo.length; j++)
+	{
+		S.TimerInfo[j].CallCount = 0;
+		S.TimerInfo[j].Sum = 0;
+		S.TimerInfo[j].Max = 0;
+		S.TimerInfo[j].FrameMax = 0;
+	}
+
+
+	var nNumLogs = S.Frames[0].ts.length;
+	var StackPosArray = Array(nNumLogs);
+	var StackArray = Array(nNumLogs);
+	for(var i = 0; i < nNumLogs; ++i)
+	{
+		StackPosArray[i] = 0;
+		StackArray[i] = Array(20);
+	}
+
+	for(var i = nFrameFirst; i < nFrameLast; i++)
+	{
+		for(var j = 0; j < S.TimerInfo.length; j++)
+		{
+			S.TimerInfo[j].FrameSum = 0;
+		}
+
+		var fr = S.Frames[i];
+		for(nLog = 0; nLog < nNumLogs; nLog++)
+		{
+			var StackPos = StackPosArray[nLog];
+			var Stack = StackArray[nLog];
+			var ts = fr.ts[nLog];
+			var ti = fr.ti[nLog];
+			var tt = fr.tt[nLog];
+			var count = ts.length;
+			for(j = 0; j < count; j++)
+			{
+				var type = tt[j];
+				var index = ti[j];
+				var time = ts[j];
+				if(index < ETOKEN_MAX && index >= 0)
+				{
+					if(type == 1) //enter
+					{
+						//push
+						Stack[StackPos] = time;
+						if(StackArray[nLog][StackPos] != time)
+						{
+							console.log('fail fail fail');
+						}
+						StackPos++;
+					}
+					else if(type == 0) // leave
+					{
+						var timestart;
+						var timeend = time;
+						if(StackPos>0)
+						{
+							StackPos--;
+							timestart = Stack[StackPos];
+						}
+						else
+						{
+							timestart = S.Frames[nFrameFirst].framestart;
+						}
+						// if(index == TimerIndex)
+						{
+							var TimeDelta = timeend - timestart;
+							S.TimerInfo[index].CallCount++;
+							S.TimerInfo[index].FrameSum += TimeDelta;
+							S.TimerInfo[index].Sum += TimeDelta;
+							if(TimeDelta > S.TimerInfo[index].Max)
+							{
+								S.TimerInfo[index].Max = TimeDelta;
+								S.TimerInfo[index].worst = TimeDelta;
+								S.TimerInfo[index].worststart = timestart;
+								S.TimerInfo[index].worstend = timeend;
+								S.TimerInfo[index].worstthread = nLog;
+							}
+						}
+					}
+				}
+				else
+				{
+					//meta
+				}
+			}
+			for(var j = 0; j < S.TimerInfo.length; j++)
+			{
+				if(S.TimerInfo[j].FrameSum > S.TimerInfo[j].FrameMax)
+				{
+					S.TimerInfo[j].FrameMax = S.TimerInfo[j].FrameSum;
+				}
+			}
+			StackPosArray[nLog] = StackPos;
+		}
+
+
+	}
+
+	for(var j = 0; j < S.TimerInfo.length; j++)
+	{
+		var CallCount = S.TimerInfo[j].CallCount;
+		var Sum = S.TimerInfo[j].Sum.toFixed(3);
+		var Max = S.TimerInfo[j].Max.toFixed(3);
+		var Average = (S.TimerInfo[j].Sum / S.TimerInfo[j].CallCount).toFixed(3);
+		var FrameAverage = (S.TimerInfo[j].Sum / FrameCount).toFixed(3);
+		var FrameCallAverage = (S.TimerInfo[j].CallCount / FrameCount).toFixed(3);
+		var FrameMax = S.TimerInfo[j].FrameMax.toFixed(3);
+		S.TimerInfo[j].CallCount = CallCount;
+		S.TimerInfo[j].Sum = Sum;
+		S.TimerInfo[j].Max  = Max ;
+		S.TimerInfo[j].Average = Average;
+		S.TimerInfo[j].FrameAverage = FrameAverage;
+		S.TimerInfo[j].FrameCallAverage = FrameCallAverage;
+		S.TimerInfo[j].FrameMax = FrameMax;
+	}
+	ProfileLeave();
+}
+
+var FlashFrames = 10;
+var FlashFrameCounter = 0;
+var FlashMessage = '';
+function TimeString(Diff)
+{
+	var DiffString = "0 sec";
+	var DiffTable = [1,60,60*60,60*60*24];
+	var DiffNameTable = ["sec", "min", "hr", "day"];
+	for(var i = 0; i < DiffTable.length; ++i)
+	{
+		if(Diff >= DiffTable[i])
+		{
+			DiffString = Math.floor(Diff / DiffTable[i]) + " " + DiffNameTable[i];
+		}
+	}
+	return DiffString;
+
+}
+function ShowFlashMessage(Message, FrameCount)
+{
+	FlashMessage = Message;
+	FlashFrameCounter = FrameCount;
+}
+function OnPageReady()
+{
+	var DumpDate = S.DumpUtcCaptureTime;
+	var CurrentDate = Date.now() / 1000;
+	var Diff = CurrentDate - DumpDate;
+	var Limit = 10*60;//flash old message when loading captures older than 10 minutes
+	if(Diff > Limit)
+	{
+		ShowFlashMessage("Captured " + TimeString(Diff) + " ago", 100);
+	}
+}
+
+function DrawFlashMessage(context)
+{
+	if(FlashFrameCounter > 0)
+	{
+		if(FlashFrameCounter>1)
+		{
+			var FlashPrc = Math.sin(FlashFrameCounter / FlashFrames);
+			context.font = FontFlash;
+			context.globalAlpha = FlashPrc * 0.35 + 0.5;
+			context.textAlign = 'center';
+			context.fillStyle = 'red';
+			context.fillText(FlashMessage, nWidth * 0.5, 50);
+			context.globalAlpha = 1;
+			context.textAlign = 'left';
+			context.font = Font;
+		}
+		FlashFrameCounter -= 1;
+
+	}
+}
+
+function DrawCaptureInfo(context)
+{
+	context.fillStyle = 'white';
+	context.textAlign = 'right';
+	context.font = Font;
+	var DumpDate = S.DumpUtcCaptureTime;
+	var CurrentDate = Date.now() / 1000;
+	var Diff = CurrentDate - DumpDate;
+	var DiffString = TimeString(Diff) + " ago";
+	context.fillText(new Date(DumpDate*1000).toLocaleString(), nWidth, FontHeight);
+	if(Mode == ModeTimers || Mode == ModeTimers_Threads || Mode == ModeTimers_Groups)
+	{
+		context.fillText("Timer Frames: " + S.AggregateInfo.Frames, nWidth, FontHeight*2);
+	}
+	else
+	{
+		context.fillText("Detailed Frames "+ S.Frames.length, nWidth, FontHeight*2);
+	}
+	context.fillText(S.DumpHost, nWidth, FontHeight*3);
+	context.fillText(DiffString, nWidth, FontHeight*4);
+	context.textAlign = 'left';
+	DrawFlashMessage(context);
+}
+
+function DrawDetailedFrameHistory()
+{
+	ProfileEnter("DrawDetailedFrameHistory");
+	var x = HistoryViewMouseX;
+
+	var context = CanvasHistory.getContext('2d');
+	context.clearRect(0, 0, CanvasHistory.width, CanvasHistory.height);
+
+	let HistoryHeight = CanvasHistory.height;
+
+	var GreenTime = (TargetTime * 0.9);
+	var RedBegin = (TargetTime * 1.1);
+	var LerpDist = 1.0 / (RedBegin - GreenTime);
+
+
+	var fHeight = nHistoryHeight;
+	var fWidth = nWidth / S.Frames.length;
+	var fHeightScale = fHeight / ReferenceTime;
+	var fX = 0;
+	var FrameIndex = -1;
+	var MouseDragging = MouseDragState != MouseDragOff;
+	RangeCpuHistory = RangeInit();
+	RangeGpuHistory = RangeInit()
+
+	var FrameFirst = -1;
+	var FrameLast = nWidth;
+	var fDetailedOffsetEnd = fDetailedOffset + fDetailedRange;
+	for(i = 0; i < S.Frames.length; i++)
+	{
+		var fMs = S.Frames[i].frameend - S.Frames[i].framestart;
+
+		var fPrc = (fMs - GreenTime) * LerpDist;
+		fPrc = Clamp(fPrc, 0, 1);
+		var color = LerpColor(fPrc);
+
+
+
+		if(fDetailedOffset <= S.Frames[i].frameend && fDetailedOffset >= S.Frames[i].framestart)
+		{
+			var lerp = (fDetailedOffset - S.Frames[i].framestart) / (S.Frames[i].frameend - S.Frames[i].framestart);
+			FrameFirst = fX + fWidth * lerp;
+		}
+		if(fDetailedOffsetEnd <= S.Frames[i].frameend && fDetailedOffsetEnd >= S.Frames[i].framestart)
+		{
+			var lerp = (fDetailedOffsetEnd - S.Frames[i].framestart) / (S.Frames[i].frameend - S.Frames[i].framestart);
+			FrameLast = fX + fWidth * lerp;
+		}
+		var fH = fHeightScale * fMs;
+		var bMouse = x > fX && x < fX + fWidth;
+		if(bMouse && !MouseDragging)
+		{
+			context.fillStyle = FRAME_HISTORY_COLOR_GPU;
+			RangeCpuHistory.Begin = S.Frames[i].framestart;
+			RangeCpuHistory.End = S.Frames[i].frameend;
+			if(S.Frames[i].framestartgpu)
+			{
+				RangeGpuHistory.Begin = S.Frames[i].framestartgpu;
+				RangeGpuHistory.End = S.Frames[i].frameendgpu;
+			}
+			FrameIndex = i;
+		}
+		else
+		{
+			context.fillStyle = color;
+		}
+		context.fillRect(fX, fHeight - fH, fWidth-1, fH);
+		fX += fWidth;
+	}
+
+	var fRangeHistoryBegin = FrameFirst;
+	var fRangeHistoryEnd = FrameLast;
+	var X = fRangeHistoryBegin;
+	var Y = 0;
+	var W = fRangeHistoryEnd - fRangeHistoryBegin;
+	context.globalAlpha = 0.35;
+	context.fillStyle = '#009900';
+	context.fillRect(X, Y, W, fHeight);
+	context.globalAlpha = 1;
+	context.strokeStyle = '#00ff00';
+	context.beginPath();
+	context.moveTo(X, Y);
+	context.lineTo(X, Y+fHeight);
+	context.moveTo(X+W, Y);
+	context.lineTo(X+W, Y+fHeight);
+	context.stroke();
+
+	{
+		var fH = fHeight - fHeightScale * TargetTime;
+		context.fillStyle = 'wheat';
+		context.strokeStyle = 'wheat';
+		context.beginPath();
+		context.moveTo(0, fH);
+		context.lineTo(nWidth, fH);
+		// context.closePath();
+		context.stroke();
+		var YText;
+		if(fH > HistoryHeight * 0.25)
+		{
+			YText = fH - FontAscent;
+		}
+		else
+		{
+			YText = fH + FontHeight;
+		}
+		context.fillText(TargetTime + 'ms', 3, YText);
+		context.textAlign='right';
+		context.fillText(FormatTime(ReferenceTime) + 'ms', nWidth, FontHeight);
+		context.textAlign='left';
+	}
+
+
+	DrawCaptureInfo(context);
+
+	if(FrameIndex>=0 && !MouseDragging)
+	{
+		var StringArray = [];
+		StringArray.push("Frame");
+		StringArray.push("" + FrameIndex);
+		StringArray.push("Time");
+		StringArray.push("" + (S.Frames[FrameIndex].frameend - S.Frames[FrameIndex].framestart).toFixed(3));
+
+		DrawToolTip(StringArray, CanvasHistory, HistoryViewMouseX, HistoryViewMouseY+20);
+
+	}
+	ProfileLeave();
+}
+function TimeToMsString(Time)
+{
+	return Time.toFixed(3) + "ms";
+}
+function TimeToString(Time)
+{
+	if(Time > 1000)
+	{
+		return (Time/1000.0).toFixed(0) +"s";
+	}
+	else if(Time > 0.9)
+	{
+		return Time.toFixed(0) + "ms";
+	}
+	else if(Time > 0.0009)
+	{
+		return (Time*1000).toFixed(0) + "us";
+	}
+	else
+	{
+		return (Time*1000000).toFixed(0) + "ns";
+	}
+}
+
+function DrawDetailedBackground(context)
+{
+	var fMs = fDetailedRange;
+	var fMsEnd = fMs + fDetailedOffset;
+	var fMsToScreen = nWidth / fMs;
+	var fRate = Math.floor(2*((Math.log(fMs)/Math.log(10))-1))/2;
+	var fStep = Math.pow(10, fRate);
+	var fRcpStep = 1.0 / fStep;
+	var nColorIndex = Math.floor(fDetailedOffset * fRcpStep) % 2;
+	if(nColorIndex < 0)
+		nColorIndex = -nColorIndex;
+	var fStart = Math.floor(fDetailedOffset * fRcpStep) * fStep;
+	var fHeight = CanvasDetailedView.height;
+	var fScaleX = nWidth / fDetailedRange;
+	var HeaderString = TimeToString(fStep);
+	context.textAlign = 'center';
+	for(f = fStart; f < fMsEnd; )
+	{
+		var fNext = f + fStep;
+		var X = (f - fDetailedOffset) * fScaleX;
+		var W = (fNext-f)*fScaleX;
+		context.fillStyle = nBackColors[nColorIndex];
+		context.fillRect(X, 0, W+2, fHeight);
+		nColorIndex = 1 - nColorIndex;
+		context.fillStyle = '#777777'
+		context.fillText(HeaderString, X + W * 0.5, 10);
+		context.fillText(HeaderString, X + W * 0.5, nHeight - 10);
+		f = fNext;
+	}
+	context.textAlign = 'left';
+	var fScaleX = nWidth / fDetailedRange;
+	context.globalAlpha = 0.5;
+	context.strokeStyle = '#bbbbbb';
+	context.beginPath();
+	for(var i = 0; i < S.Frames.length; i++)
+	{
+		var frfr = S.Frames[i];
+		if(frfr.frameend < fDetailedOffset || frfr.framestart > fDetailedOffset + fDetailedRange)
+		{
+			continue;
+		}
+		var X = (frfr.framestart - fDetailedOffset) * fScaleX;
+		if(X >= 0 && X < nWidth)
+		{
+			context.moveTo(X, 0);
+			context.lineTo(X, nHeight);
+		}
+	}
+	context.stroke();
+	context.globalAlpha = 1;
+
+}
+
+function DrawToolTip(StringArray, Canvas, x, y, bSecondary)
+{
+	var context = Canvas.getContext('2d');
+	context.font = Font;
+	var WidthArray = Array(StringArray.length);
+	var nMaxWidth = 0;
+	var nHeight = 0;
+	for(i = 0; i < StringArray.length; i += 2)
+	{
+		var nWidth0 = context.measureText(StringArray[i]).width;
+		var nWidth1 = context.measureText(StringArray[i+1]).width;
+		var nSum = nWidth0 + nWidth1;
+		WidthArray[i] = nWidth0;
+		WidthArray[i+1] = nWidth1;
+		if(nSum > nMaxWidth)
+		{
+			nMaxWidth = nSum;
+		}
+		nHeight += BoxHeight;
+	}
+	nMaxWidth += 15;
+	//bounds check.
+	if(!bSecondary)
+	{
+		var CanvasRect = Canvas.getBoundingClientRect();
+		if(y + nHeight > CanvasRect.height)
+		{
+			y = CanvasRect.height - nHeight;
+			x += 20;
+		}
+		if(x + nMaxWidth > CanvasRect.width)
+		{
+			x = CanvasRect.width - nMaxWidth;
+		}
+	}
+	else
+	{
+		x -= nMaxWidth;
+	}
+	context.fillStyle = 'black';
+	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
+	context.fillStyle = 'white';
+
+	var XPos = x;
+	var XPosRight = x + nMaxWidth;
+	var YPos = y + BoxHeight-2;
+	for(i = 0; i < StringArray.length; i += 2)
+	{
+		context.fillText(StringArray[i], XPos, YPos);
+		context.fillText(StringArray[i+1], XPosRight - WidthArray[i+1], YPos);
+		YPos += BoxHeight;
+	}
+	return {"x":x, "y":y};
+}
+
+function BuildToolTipDetailed(S, nHoverToken, HoverTokenOwner, bSecond)
+{
+	var StringArray = [];
+	var groupid = S.TimerInfo[nHoverToken].group;
+	if(nHoverToken > -1)
+	{
+		StringArray.push("Timer");
+		StringArray.push(S.TimerInfo[nHoverToken].name);
+		StringArray.push("Group");
+		StringArray.push(S.GroupInfo[groupid].name);
+	}
+	else
+	{
+		StringArray.push("");
+		StringArray.push("");
+		StringArray.push("");
+		StringArray.push("");
+	}
+	StringArray.push("");
+	StringArray.push("");
+
+	if(S == HoverTokenOwner)
+	{
+		StringArray.push("Time");
+		StringArray.push((RangeCpu.End-RangeCpu.Begin).toFixed(3));
+	}
+	else
+	{
+		StringArray.push("");
+		StringArray.push("");
+	}
+
+	StringArray.push("");
+	StringArray.push("");
+	StringArray.push("Total");
+	StringArray.push("" + S.TimerInfo[nHoverToken].Sum);
+	StringArray.push("Max");
+	StringArray.push("" + S.TimerInfo[nHoverToken].Max);
+	StringArray.push("Average");
+	StringArray.push("" + S.TimerInfo[nHoverToken].Average);
+	StringArray.push("Count");
+	StringArray.push("" + S.TimerInfo[nHoverToken].CallCount);
+
+	StringArray.push("");
+	StringArray.push("");
+
+	StringArray.push("Max/Frame");
+	StringArray.push("" + S.TimerInfo[nHoverToken].FrameMax);
+
+	StringArray.push("Average Time/Frame");
+	StringArray.push("" + S.TimerInfo[nHoverToken].FrameAverage);
+
+	StringArray.push("Average Count/Frame");
+	StringArray.push("" + S.TimerInfo[nHoverToken].FrameCallAverage);
+
+
+	let Time = fDetailedOffset + fDetailedRange * (DetailedViewMouseX / nWidth);
+	if(bSecond)
+		Time += fDetailedOffsetSecond;
+	let FrameTime = new Object();
+	let Frame = CalculateTimers2(FrameTime, nHoverToken, Time, S);
+	StringArray.push("");
+	StringArray.push("");
+	if(Frame>-1)
+	{
+		StringArray.push("Frame " + Frame);
+		StringArray.push("");
+		StringArray.push("Total");
+		StringArray.push("" + FrameTime.Sum);
+		StringArray.push("Count");
+		StringArray.push("" + FrameTime.CallCount);
+		StringArray.push("Average");
+		StringArray.push("" + FrameTime.Average);
+		StringArray.push("Max");
+		StringArray.push("" + FrameTime.Max);
+	}
+	else
+	{
+		for(var i = 0; i < 10; ++i)
+			StringArray.push("");
+	}
+
+	StringArray.push("");
+	StringArray.push("");
+
+	StringArray.push("Detailed Capture");
+	StringArray.push("");
+	StringArray.push("Frames");
+	StringArray.push(S.Frames.length);
+	StringArray.push("Time");
+	StringArray.push(DetailedTotal(S).toFixed(2) + "ms");
+	return StringArray;
+
+
+
+}
+
+
+function DrawHoverToolTip()
+{
+	ProfileEnter("DrawHoverToolTip");
+	let StringArray = [];
+	let StringArray2;
+	if(ToolTipImmediate != null)
+	{
+		DrawToolTip(ToolTipImmediate, CanvasDetailedView, DetailedViewMouseX, DetailedViewMouseY+20);
+		ToolTipImmediate = null;
+
+	}
+	else if(nHoverToken != -1)
+	{
+
+		let bShowTimers = Mode == ModeTimers || Mode == ModeTimers_Threads || Mode == ModeTimers_Groups;
+		// this confused alot of people.
+		// if(ToolTipFlip == 1)
+		// {
+		// 	bShowTimers = !bShowTimers;
+		// }
+		if(bShowTimers)
+		{
+			// var StringArray = [];
+			let groupid = S.TimerInfo[nHoverToken].group;
+			StringArray.push("Timer");
+			StringArray.push(S.TimerInfo[nHoverToken].name);
+			StringArray.push("Group");
+			StringArray.push(S.GroupInfo[groupid].name);
+
+			StringArray.push("");
+			StringArray.push("");
+			let Timer = S.TimerInfo[nHoverToken];
+			StringArray.push("Average");
+			StringArray.push(Timer.average);
+			StringArray.push("Max");
+			StringArray.push(Timer.max);
+			StringArray.push("Excl Max");
+			StringArray.push(Timer.exclmax);
+			StringArray.push("Excl Average");
+			StringArray.push(Timer.exclaverage);
+			StringArray.push("Call Average");
+			StringArray.push(Timer.callaverage);
+			StringArray.push("Call Count");
+			StringArray.push(Timer.callcount);
+
+			StringArray.push("");
+			StringArray.push("");
+
+
+			StringArray.push("Group");
+			StringArray.push(S.GroupInfo[groupid].name);
+			StringArray.push("Average");
+			StringArray.push(S.GroupInfo[groupid].average);
+			StringArray.push("Max");
+			StringArray.push(S.GroupInfo[groupid].max);
+
+			StringArray.push("");
+			StringArray.push("");
+
+			StringArray.push("Timer Capture");
+			StringArray.push("");
+			StringArray.push("Frames");
+			StringArray.push(S.AggregateInfo.Frames);
+			StringArray.push("Time");
+			StringArray.push(S.AggregateInfo.Time.toFixed(2) + "ms");
+
+
+		}
+		else
+		{
+			StringArray = BuildToolTipDetailed(S, nHoverToken, HoverTokenOwner, 0);
+			let nCompareHoverToken = TimerRemapReverse[nHoverToken];
+			if(nCompareHoverToken > -1)
+			{
+				StringArray2 = BuildToolTipDetailed(S2, nCompareHoverToken, HoverTokenOwner, 1);
+			}
+		}
+		if(ToolTipCorner)
+		{
+			let R = DrawToolTip(StringArray, CanvasDetailedView, nWidth, nHeight);
+			if(StringArray2)
+				DrawToolTip(StringArray2, CanvasDetailedView, R.x-15, R.y, 1);
+		}
+		else
+		{
+			let R = DrawToolTip(StringArray, CanvasDetailedView, DetailedViewMouseX, DetailedViewMouseY+20);
+			if(StringArray2)
+				DrawToolTip(StringArray2, CanvasDetailedView, R.x-15, R.y, 1);
+		}
+	}
+	else if(nHoverCSCpu >= 0)
+	{
+		StringArray = [];
+		StringArray.push("Context Switch");
+		StringArray.push("");
+		StringArray.push("");
+		StringArray.push("");
+		StringArray.push("Cpu");
+		StringArray.push("" + nHoverCSCpu);
+		StringArray.push("Begin");
+		StringArray.push("" + RangeCpu.Begin);
+		StringArray.push("End");
+		StringArray.push("" + RangeCpu.End);
+		if(ToolTipCorner)
+		{
+			DrawToolTip(StringArray, CanvasDetailedView, nWidth, nHeight);
+		}
+		else
+			DrawToolTip(StringArray, CanvasDetailedView, DetailedViewMouseX, DetailedViewMouseY+20);
+	}
+	ProfileLeave();
+}
+
+function FormatMeta(Value, Dec)
+{
+	if(!Value)
+	{
+		Value = "0";
+	}
+	else
+	{
+		Value = '' + Value.toFixed(Dec);
+	}
+	return Value;
+}
+
+function FilterMatch(FilterArray, value)
+{
+	if(!FilterArray)
+		return true;
+	for(var i = 0; i < FilterArray.length; ++i)
+	{
+		var res = value.search(FilterArray[i]);
+		if(res<0)
+			return false;
+	}
+	return true;
+}
+
+
+function DrawBarView()
+{
+	ProfileEnter("DrawBarView");
+	Invalidate++;
+	nHoverToken = -1;
+	var context = CanvasDetailedView.getContext('2d');
+	context.clearRect(0, 0, nWidth, nHeight);
+
+	var Height = BoxHeight;
+	var Width = nWidth;
+	var NameWidth = Math.max(S.TimerNameWidth, S.GroupNameWidth) + 20;
+
+	//clamp offset to prevent scrolling into the void
+	var nTotalRows = 0;
+	for(var groupid in S.GroupInfo)
+	{
+		if(!GroupsDisabled[S.GroupInfo[groupid].name])
+		{
+			nTotalRows += S.GroupInfo[groupid].TimerArray.length + 1;
+		}
+	}
+	var nTotalRowPixels = nTotalRows * Height;
+	var nFrameRows = nHeight - BoxHeight;
+
+	if(nOffsetBarsY + nFrameRows > nTotalRowPixels && nTotalRowPixels > nFrameRows)
+	{
+		nOffsetBarsY = nTotalRowPixels - nFrameRows;
+	}
+	var ColumnsWidthBefore = new Array(ColumnsWidth.length);
+	for(var i = 0; i < ColumnsWidth.length; ++i)
+	{
+		ColumnsWidthBefore[i] = ColumnsWidth[i];
+	}
+
+	var Y = -nOffsetBarsY + BoxHeight;
+	let TimersGroups = Mode == ModeTimers_Threads || Mode == ModeTimers_Groups;
+	if(TimersGroups)
+	{
+		nOffsetBarsX = 0;
+	}
+	var XBase = -nOffsetBarsX;
+	var nColorIndex = 0;
+
+	context.fillStyle = 'white';
+	context.font = Font;
+	var bMouseIn = 0;
+	var RcpReferenceTime = 1.0 / ReferenceTime;
+	var CountWidth = 12 * FontWidth;
+	var nMetaLen = S.TimerInfo[0].meta.length;
+	var nMetaCharacters = 10;
+	var InnerBoxHeight = BoxHeight-2;
+	var TimerLen = 8; //todo: fix max digits.
+	var TimerWidth = TimerLen * FontWidth;
+	var nWidthBars = nBarsWidth+2;
+	var nWidthMs = TimerWidth+2+10;
+	var R = 0;
+	var AllColumns = TimersGroups != 0;
+
+
+
+	for(var i = 0; i < nMetaLen; ++i)
+	{
+		if(nMetaCharacters < MetaNames[i].length)
+			nMetaCharacters = MetaNames[i].length;
+	}
+	var nWidthMeta = nMetaCharacters * FontWidth + 6;
+	function HeaderMouseHandle(XBegin, X, Header)
+	{
+		var bMouseIn = DetailedViewMouseY >= 0 && DetailedViewMouseY < BoxHeight && DetailedViewMouseX < X && DetailedViewMouseX > XBegin;
+		if(bMouseIn)
+		{
+			SortColumnMouseOverNext = Header;
+		}
+	}
+	function HeaderString(Header)
+	{
+		if(Header == SortColumnMouseOver)
+		{
+			return Header + (SortColumnOrderFlip ? '<' : '>');
+		}
+		else
+		{
+			return Header;
+		}
+
+	}
+	function DrawHeaderSplit(Header)
+	{
+		if(ColumnsEnabled[R]||AllColumns)
+		{
+			context.fillStyle = 'white';
+			context.fillText(HeaderString(Header), X, Height-FontAscent);
+			var XBegin = X;
+			X += nWidthBars;
+			context.fillStyle = nBackColorOffset;
+			X += ColumnsWidth[R];
+			if(X >= NameWidth)
+			{
+				context.fillRect(X-3, 0, 1, nHeight);
+			}
+			HeaderMouseHandle(XBegin, X, Header);
+		}
+		R++;
+	}
+	function DrawHeaderSplitSingle(Header, Col)
+	{
+		if(ColumnsEnabled[Col]||AllColumns)
+		{
+			context.fillStyle = 'white';
+			context.fillText(HeaderString(Header), X, Height-FontAscent);
+			var XBegin = X;
+			X += ColumnsWidth[R];
+			context.fillStyle = nBackColorOffset;
+			if(X >= NameWidth)
+			{
+				context.fillRect(X-3, 0, 1, nHeight);
+			}
+			HeaderMouseHandle(XBegin, X, Header);
+		}
+		R++;
+	}
+	function DrawHeaderSplitLeftRight(HeaderLeft, HeaderRight, Width)
+	{
+		context.textAlign = 'left';
+		context.fillStyle = 'white';
+		context.fillText(HeaderLeft, X, Height-FontAscent);
+		var XBegin = X;
+		X += Width;
+		context.textAlign = 'right';
+		context.fillText(HeaderRight, X-5, Height-FontAscent);
+		context.textAlign = 'left';
+		context.fillStyle = nBackColorOffset;
+		if(X >= NameWidth)
+		{
+			context.fillRect(X-3, 0, 1, nHeight);
+		}
+		HeaderMouseHandle(XBegin, X, HeaderLeft);
+	}
+	function DrawTimer(Value, Color)
+	{
+		if(ColumnsEnabled[R]||AllColumns)
+		{
+			var Prc = Value * RcpReferenceTime;
+			var YText = Y+Height-FontAscent;
+			if(Prc > 1)
+			{
+				Prc = 1;
+			}
+			context.textAlign = 'left';
+			context.fillStyle = Color;
+			context.fillRect(X+1, Y+1, Prc * nBarsWidth, InnerBoxHeight);
+			var TimerText = Value.toFixed(2);
+			var W = context.measureText(TimerText).width + FontWidth;
+			ColumnsWidth[R] = Math.max(W, ColumnsWidth[R]);
+			X += nWidthBars;
+			X += ColumnsWidth[R];
+			context.fillStyle = 'white';
+			context.textAlign = 'right';
+			context.fillText(TimerText, X - FontWidth, YText);
+			context.textAlign = 'left';
+		}
+		R++;
+	}
+	function DrawCount(Str)
+	{
+		if(ColumnsEnabled[R]||AllColumns)
+		{
+			X += ColumnsWidth[R];
+			context.fillStyle = 'white';
+			context.textAlign = 'right';
+			var YText = Y+Height-FontAscent;
+			context.fillText(Str, X-6, YText);
+			var W = Math.max(80, context.measureText(Str).width + FontWidth * 2);
+			ColumnsWidth[R] = Math.max(W, ColumnsWidth[R]);
+		}
+		R++;
+
+	}
+
+
+	function DrawMeta(Value, Width, Dec, YText, Col)
+	{
+		if(ColumnsEnabled[Col]||AllColumns)
+		{
+			Value = FormatMeta(Value, Dec);
+			X += (FontWidth*Width);
+			ColumnsWidth[R] = FontWidth*Width;
+			context.textAlign = 'right';
+			context.fillText(Value, X-FontWidth, YText);
+			context.textAlign = 'left';
+		}
+		R++;
+	}
+
+
+
+	function DrawTimerRow(timerid, showgroup)
+	{
+		R = 0;
+		var Timer = S.TimerInfo[timerid];
+		var Average = Timer.average;
+		var Max = Timer.max;
+		var Min = Timer.min;
+		var Spike = Timer.spike;
+		var ExclusiveMax = Timer.exclmax;
+		var ExclusiveAverage = Timer.exclaverage;
+		var CallAverage = Timer.callaverage;
+		var CallCount = Timer.callcount;
+		var YText = Y+Height-FontAscent;
+		var Color = g_Colors[Timer.cid];
+		X = NameWidth + XBase;
+
+		nColorIndex = 1-nColorIndex;
+		bMouseIn = DetailedViewMouseY >= Y && DetailedViewMouseY < Y + BoxHeight;
+		if(bMouseIn)
+		{
+			nHoverToken = timerid;
+		}
+		context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+		context.fillRect(0, Y, Width, FontHeight+2);
+
+		DrawTimer(Average,  Color);
+		DrawTimer(Max, Color);
+		DrawTimer(Timer.total, Color);
+		DrawTimer(Min, Color);
+		DrawCount(Spike.toFixed(2) + '%');
+		DrawTimer(CallAverage, Color);
+		DrawCount(CallCount);
+		DrawTimer(ExclusiveAverage, Color);
+		DrawTimer(ExclusiveMax, Color);
+
+		context.fillStyle = 'white';
+		var Col = R;
+		for(var j = 0; j < nMetaLen; ++j)
+		{
+		    DrawMeta(Timer.meta[j], MetaLengths[j], 0, YText, Col + j);
+		    DrawMeta(Timer.metaavg[j], MetaLengthsAvg[j], 2, YText, Col + j);
+		    DrawMeta(Timer.metamax[j], MetaLengthsMax[j], 0, YText, Col + j);
+		}
+		context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+		context.fillRect(0, Y, NameWidth, Height);
+		context.textAlign = 'right';
+		context.fillStyle = Color;
+		context.fillText(Timer.name, NameWidth - 5, YText);
+		context.textAlign = 'left';
+		if(showgroup)
+		{
+			context.fillStyle = 'white';
+			context.fillText(S.GroupInfo[Timer.group].name, 1, YText);
+		}
+	}
+	if(SortColumn && Mode == ModeTimers)
+	{
+		var OrderArray = new Array(S.TimerInfo.length);
+		var KeyArray = new Array(S.TimerInfo.length);
+		for(var idx in GroupOrder)
+		{
+			var Group = S.GroupInfo[idx];
+			if((!GroupsDisabled[Group.name]) && FilterMatch(FilterGroup, Group.name))
+			{
+				var TimerArray = Group.TimerArray;
+				for(var timerindex in TimerArray)
+				{
+					var timerid = TimerArray[timerindex];
+					if(FilterMatch(FilterTimer, S.TimerInfo[timerid].name))
+					{
+						OrderArray.push(timerid);
+						NameWidth = Math.max(S.TimerInfo[timerid].wtotal, NameWidth);
+					}
+				}
+			}
+		}
+		var KeyFunc = null;
+		switch(SortColumn)
+		{
+			case 1: KeyFunc = function (a) { return S.TimerInfo[a].average; }; break;
+			case 2: KeyFunc = function (a) { return S.TimerInfo[a].max; }; break;
+			case 3: KeyFunc = function (a) { return S.TimerInfo[a].total; }; break;
+			case 4: KeyFunc = function (a) { return S.TimerInfo[a].min; }; break;
+			case 5: KeyFunc = function (a) { return S.TimerInfo[a].spike; }; break;
+			case 6: KeyFunc = function (a) { return S.TimerInfo[a].callaverage; }; break;
+			case 7: KeyFunc = function (a) { return S.TimerInfo[a].callcount; }; break;
+			case 8: KeyFunc = function (a) { return S.TimerInfo[a].exclaverage; }; break;
+			case 9: KeyFunc = function (a) { return S.TimerInfo[a].exclmax; }; break;
+		}
+
+		var Flip = SortColumnOrderFlip == 1 ? -1 : 1;
+		OrderArray.sort(function(a,b) { return Flip * (KeyFunc(b) - KeyFunc(a)); } );
+
+		for(var i in OrderArray)
+		{
+			DrawTimerRow(OrderArray[i], 1);
+			Y += Height;
+		}
+
+	}
+	else if(Mode == ModeTimers_Threads)
+	{
+		for(var i = 0; i < S.ThreadNames.length; ++i)
+		{
+			if((IsThreadActive(S.ThreadNames[i])) && FilterMatch(FilterTimer, S.ThreadNames[i]))
+			{
+				var X = 0;
+				var YText = Y+Height-FontAscent;
+				bMouseIn = DetailedViewMouseY >= Y && DetailedViewMouseY < Y + BoxHeight;
+				nColorIndex = 1-nColorIndex;
+				context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+				context.fillRect(0, Y, Width, FontHeight+2);
+				var ThreadColor = CSwitchColors[i % CSwitchColors.length];
+				context.fillStyle = ThreadColor;
+				context.fillText(S.ThreadNames[i], 1, YText);
+				context.textAlign = 'left';
+				Y += Height;
+				for(var idx in GroupOrder)
+				{
+					R = 0;
+					var groupid = GroupOrder[idx];
+					var Group = S.GroupInfo[groupid];
+					var PerThreadTimer = S.ThreadGroupTimeArray[i][groupid];
+					var PerThreadTimerTotal = S.ThreadGroupTimeTotalArray[i][groupid];
+					if((PerThreadTimer > 0.0001|| PerThreadTimerTotal>0.1) && (!GroupsDisabled[Group.name]) && FilterMatch(FilterGroup, Group.name))
+					{
+						var GColor = GroupColors ? g_Colors[S.GroupInfo[groupid].cid] : 'white';
+						var X = 0;
+						nColorIndex = 1-nColorIndex;
+						bMouseIn = DetailedViewMouseY >= Y && DetailedViewMouseY < Y + BoxHeight;
+						context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+						context.fillRect(0, Y, Width, nHeight);
+						context.fillStyle = GColor;
+						context.textAlign = 'right';
+						context.fillText(Group.name, NameWidth - 5, Y+Height-FontAscent);
+						context.textAlign = 'left';
+						X += NameWidth;
+						DrawTimer(PerThreadTimer, GColor);
+						DrawTimer(PerThreadTimerTotal, GColor);
+						Y += Height;
+					}
+				}
+			}
+		}
+	}
+	else
+	{
+		for(var idx in GroupOrder)
+		{
+			var groupid = GroupOrder[idx];
+			var Group = S.GroupInfo[groupid];
+			var GColor = GroupColors ? g_Colors[S.GroupInfo[groupid].cid] : 'white';
+			if((!GroupsDisabled[Group.name]) && FilterMatch(FilterGroup, Group.name))
+			{
+				R = 0;
+				var TimerArray = Group.TimerArray;
+				var X = XBase;
+				nColorIndex = 1-nColorIndex;
+				bMouseIn = DetailedViewMouseY >= Y && DetailedViewMouseY < Y + BoxHeight;
+				context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+				context.fillRect(0, Y, Width, FontHeight+2);
+				context.fillStyle = GColor;
+				context.fillText(Group.name, 1, Y+Height-FontAscent);
+				X += NameWidth;
+				DrawTimer(Group.average, GColor);
+				DrawTimer(Group.max, GColor);
+				DrawTimer(Group.total, GColor);
+
+				context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+				context.fillRect(0, Y, NameWidth, FontHeight+2);
+				context.fillStyle = GColor;
+				context.fillText(Group.name, 1, Y+Height-FontAscent);
+
+				Y += Height;
+				let TimersGroups = Mode == ModeTimers_Threads || Mode == ModeTimers_Groups;
+				if(TimersGroups)
+				{
+					for(var i = 0; i < S.ThreadNames.length; ++i)
+					{
+						R = 0;
+						var PerThreadTimer = S.ThreadGroupTimeArray[i][groupid];
+						var PerThreadTimerTotal = S.ThreadGroupTimeTotalArray[i][groupid];
+						if((PerThreadTimer > 0.0001|| PerThreadTimerTotal>0.1) && (IsThreadActive(S.ThreadNames[i])) && FilterMatch(FilterTimer, S.ThreadNames[i]))
+						{
+							var YText = Y+Height-FontAscent;
+							bMouseIn = DetailedViewMouseY >= Y && DetailedViewMouseY < Y + BoxHeight;
+							nColorIndex = 1-nColorIndex;
+							context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+							context.fillRect(0, Y, Width, FontHeight+2);
+							var ThreadColor = CSwitchColors[i % CSwitchColors.length];
+							context.fillStyle = ThreadColor;
+							context.textAlign = 'right';
+							context.fillText(S.ThreadNames[i], NameWidth - 5, YText);
+							context.textAlign = 'left';
+							X = NameWidth;
+							DrawTimer(PerThreadTimer, ThreadColor);
+							X += nWidthBars + ColumnsWidth[R++];
+							DrawTimer(PerThreadTimerTotal, ThreadColor);
+							Y += Height;
+						}
+					}
+				}
+				else
+				{
+					for(var timerindex in TimerArray)
+					{
+						var timerid = TimerArray[timerindex];
+						if(FilterMatch(FilterTimer, S.TimerInfo[timerid].name))
+						{
+							DrawTimerRow(timerid, 0);
+							Y += Height;
+						}
+					}
+				}
+			}
+		}
+	}
+	X = 0;
+	R = 0;
+	context.fillStyle = nBackColorOffset;
+	context.fillRect(0, 0, Width, Height);
+	context.fillStyle = 'white';
+	SortColumnMouseOverNext = null;
+
+	if(Mode == ModeTimers_Threads || Mode == ModeTimers_Groups)
+	{
+		if(Mode == ModeTimers_Threads)
+		{
+			DrawHeaderSplitLeftRight(StrThread, StrGroup, NameWidth);
+			DrawHeaderSplit(StrAverage);
+			DrawHeaderSplit(StrTotal);
+		}
+		else
+		{
+			DrawHeaderSplitLeftRight(StrGroup, StrThread, NameWidth);
+			DrawHeaderSplit(StrAverage);
+			DrawHeaderSplit(StrMax);
+			DrawHeaderSplit(StrTotal);
+		}
+	}
+	else
+	{
+		X = NameWidth + XBase;
+		DrawHeaderSplit(StrAverage);
+		DrawHeaderSplit(StrMax);
+		DrawHeaderSplit(StrTotal);
+		DrawHeaderSplit(StrMin);
+		DrawHeaderSplitSingle(StrSpike, R);
+		DrawHeaderSplit(StrCallAverage);
+		DrawHeaderSplitSingle(StrCount, R);
+		DrawHeaderSplit(StrExclAverage);
+		DrawHeaderSplit(StrExclMax);
+		var Col = R;
+		for(var i = 0; i < nMetaLen; ++i)
+		{
+			DrawHeaderSplitSingle(MetaNames[i], Col + i);
+			DrawHeaderSplitSingle(MetaNames[i] + " Avg", Col + i);
+			DrawHeaderSplitSingle(MetaNames[i] + " Max", Col + i);
+		}
+		X = 0;
+		context.fillStyle = nBackColorOffset;
+		context.fillRect(0, 0, NameWidth, Height);
+		context.fillStyle = 'white';
+
+		DrawHeaderSplitLeftRight(StrGroup, StrTimer, NameWidth);
+
+	}
+
+	var ColumnsChanged = false;
+	for(var i = 0; i < ColumnsWidth.length; ++i)
+	{
+		if(ColumnsWidthBefore[i] != ColumnsWidth[i])
+		{
+			ColumnsChanged = true;
+		}
+	}
+	if(ColumnsChanged)
+	{
+		Invalidate = 0;
+	}
+
+
+
+
+	ProfileLeave();
+}
+
+var CounterNameWidth = 100;
+var CounterValueWidth = 100;
+var CounterLimitWidth = 100;
+
+var FormatCounterDefault = 0;
+var FormatCounterBytes = 1;
+var FormatCounterBytesExt = [ "b","kb","mb","gb","tb","pb", "eb","zb", "yb" ];
+
+function ShiftRight10(v)
+{
+	if(v > 1024)
+	{
+		return v / 1024.0;
+	}
+	else
+	{
+		return v >> 10;
+	}
+}
+
+
+function FormatCounter(Format, Counter)
+{
+	if(!Counter)
+	{
+		return '0';
+	}
+	var Negative = 0;
+	if(Counter < 0)
+	{
+		Counter = -Counter;
+		Negative = 1;
+		if(Counter < 0) // handle INT_MIN
+		{
+			Counter = -(Counter+1);
+			if(Counter < 0)
+			{
+				return '?';
+			}
+		}
+	}
+	var str = Negative ? '-' :'' ;
+	if(Format == FormatCounterDefault)
+	{
+		var Seperate = 0;
+		var result = '';
+		while (Counter)
+		{
+			if (Seperate)
+			{
+				result += '.';
+			}
+			Seperate = 1;
+			for (var i = 0; Counter && i < 3; ++i)
+			{
+				var Digit = Math.floor(Counter % 10);
+				Counter = Math.floor(Counter / 10);
+				result += '' + Digit;
+			}
+		}
+
+		for(var i = 0; i < result.length; ++i)
+		{
+			str += result[result.length-1-i];
+		}
+		return str;
+	}
+	else if(Format == FormatCounterBytes)
+	{
+		var Shift = 0;
+		var Divisor = 1;
+		var CountShifted = ShiftRight10(Counter);
+		while(CountShifted)
+		{
+			Divisor <<= 10;
+			CountShifted = ShiftRight10(CountShifted);
+			Shift++;
+		}
+		if(Shift)
+		{
+			return str + (Counter / Divisor).toFixed(2) + '' + FormatCounterBytesExt[Shift];
+		}
+		else
+		{
+			return str + Counter.toFixed(2) + '' + FormatCounterBytesExt[0];
+		}
+	}
+	return '?'
+}
+function DrawCounterView()
+{
+	ProfileEnter("DrawCounterView");
+	Invalidate++;
+	nHoverToken = -1;
+	var context = CanvasDetailedView.getContext('2d');
+	context.clearRect(0, 0, nWidth, nHeight);
+
+	var Height = BoxHeight;
+	var Width = nWidth;
+	//clamp offset to prevent scrolling into the void
+	var nTotalRows = S.CounterInfo.length;
+	var nTotalRowPixels = nTotalRows * Height;
+	var nFrameRows = nHeight - BoxHeight;
+	if(nOffsetCountersY + nFrameRows > nTotalRowPixels && nTotalRowPixels > nFrameRows)
+	{
+		nOffsetCountersY = nTotalRowPixels - nFrameRows;
+	}
+
+	var CounterNameWidthTemp = 10;
+	var CounterValueWidthTemp = 10;
+	var CounterLimitWidthTemp = 10;
+
+	var CounterWidth = 150;
+	var Y = -nOffsetCountersY + BoxHeight;
+	var X = 0;
+	var nColorIndex = 0;
+	context.fillStyle = 'white';
+	context.font = Font;
+	var bMouseIn = 0;
+	function DrawHeaderSplitSingle(Header, Width)
+	{
+		context.fillStyle = 'white';
+		context.fillText(Header, X, Height-FontAscent);
+		X += Width;
+		context.fillStyle = nBackColorOffset;
+		context.fillRect(X-3, 0, 1, nHeight);
+	}
+	function DrawHeaderSplitSingleRight(Header, Width)
+	{
+		X += Width;
+		context.fillStyle = 'white';
+		context.textAlign  = 'right';
+		context.fillText(Header, X - FontWidth, Height-FontAscent);
+		context.fillStyle = nBackColorOffset;
+		context.fillRect(X, 0, 1, nHeight);
+		context.textAlign  = 'left';
+	}
+	var TimerLen = 6;
+	var TimerWidth = TimerLen * FontWidth;
+	nHoverCounter = -1;
+	function CounterIndent(Level)
+	{
+		return Level * 4 * FontWidth;
+	}
+	function Max(a, b)
+	{
+		return a > b ? a : b;
+	}
+
+	function DrawCounterRecursive(Index)
+	{
+		var Counter = S.CounterInfo[Index];
+		var Indent = CounterIndent(Counter.level);
+		CounterNameWidthTemp = Max(CounterNameWidthTemp, Counter.name.length+1 + Indent / (FontWidth+1));
+		CounterValueWidthTemp = Max(CounterValueWidthTemp, Counter.formatted.length);
+		CounterLimitWidthTemp = Max(CounterLimitWidthTemp, Counter.formattedlimit.length);
+
+		var X = 0;
+		nColorIndex = 1-nColorIndex;
+		var HeightExpanded = Counter.Expanded ? Height * 5 : Height
+
+		bMouseIn = DetailedViewMouseY >= Y && DetailedViewMouseY < Y + HeightExpanded;
+		if(bMouseIn)
+		{
+			nHoverCounter = Index;
+		}
+		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+		context.fillStyle = bgcolor;
+		context.fillRect(0, Y, Width, HeightExpanded);
+		context.fillStyle = 'white';
+		var c = Counter.closed ? '*' : ' ';
+		context.fillText(c + Counter.name, Indent, Y+Height-FontAscent);
+		X += CounterNameWidth;
+		X += CounterValueWidth - FontWidth;
+		context.textAlign = 'right';
+		context.fillText(Counter.formatted, X, Y+Height-FontAscent);
+		context.textAlign = 'left';
+		X += FontWidth * 4;
+		var Y0 = Y + 1;
+		if(Counter.limit != 0)
+		{
+			context.fillText(Counter.formattedlimit, X, Y+Height-FontAscent);
+			X += CounterLimitWidth;
+			var X0 = X + 1;
+			context.fillStyle = 'white';
+			context.fillRect(X0, Y0, Counter.boxprc * (CounterWidth-2), Height-2);
+			context.fillStyle = bgcolor;
+			context.fillRect(X0+1, Y0+1, Counter.boxprc * (CounterWidth-4), Height-4);
+			context.fillStyle = 'cyan';
+			context.fillRect(X0+1, Y0+1, Counter.counterprc * (CounterWidth-4), Height-4);
+			X += CounterWidth + 10;
+		}
+		else
+		{
+			X += CounterLimitWidth;
+			X += CounterWidth + 10;
+		}
+		var CounterHistory = Counter.counterhistory;
+		if(CounterHistory)
+		{
+			var Prc = CounterHistory.prc;
+
+			context.fillStyle = 'cyan';
+			context.strokeStyle = 'cyan';
+			context.globalAlpha = 0.5;
+			context.beginPath();
+			var x = X;
+			var YBase = Y0 + HeightExpanded-1;
+			var YOffset = -(HeightExpanded-2);
+
+			context.moveTo(X, Y0);
+			for(var i = 0; i < Prc.length; ++i)
+			{
+				context.moveTo(x, YBase);
+				context.lineTo(x, YBase + Prc[i] * YOffset);
+
+				x += 1;
+			}
+			context.stroke();
+
+			x = X;
+			context.globalAlpha = 1.0;
+			context.beginPath();
+			context.moveTo(X, YBase);
+
+			for(var i = 0; i < Prc.length; ++i)
+			{
+				context.lineTo(x, YBase + Prc[i] * YOffset);
+				x += 1;
+			}
+			context.stroke();
+			if(bMouseIn)
+			{
+				var MouseGraphX = Math.floor(DetailedViewMouseX - X);
+				if(MouseGraphX >= 0 && MouseGraphX < CounterHistory.history.length)
+				{
+					context.fillStyle = 'white';
+					var Formatted = FormatCounter(Counter.format, CounterHistory.history[MouseGraphX]);
+					context.fillText(Formatted, X, Y+Height-FontAscent);
+				}
+				context.strokeStyle = 'orange';
+				context.beginPath();
+				var CrossX = X + MouseGraphX;
+				var CrossY = YBase + Prc[MouseGraphX] * YOffset;
+				context.moveTo(CrossX-2, CrossY-2);
+				context.lineTo(CrossX+2, CrossY+2);
+				context.moveTo(CrossX+2, CrossY-2);
+				context.lineTo(CrossX-2, CrossY+2);
+				context.stroke();
+
+			}
+			X += Prc.length + 5;
+			context.fillStyle = 'white';
+			context.fillText( FormatCounter(Counter.format, Counter.minvalue), X, Y + Height - FontAscent);
+			X += CounterWidth + 5;
+			context.fillText( FormatCounter(Counter.format, Counter.maxvalue), X, Y + Height - FontAscent);
+			X += CounterWidth + 5;
+		}
+
+		Y += HeightExpanded;
+
+		if(!Counter.closed)
+		{
+			var ChildIndex = Counter.firstchild;
+			while(ChildIndex != -1)
+			{
+				DrawCounterRecursive(ChildIndex);
+				ChildIndex = S.CounterInfo[ChildIndex].sibling;
+			}
+		}
+	}
+
+	for(var i = 0; i < S.CounterInfo.length; ++i)
+	{
+		if(S.CounterInfo[i].parent == -1)
+		{
+			DrawCounterRecursive(i);
+		}
+	}
+
+	X = 0;
+	context.fillStyle = nBackColorOffset;
+	context.fillRect(0, 0, Width, Height);
+	context.fillStyle = 'white';
+	DrawHeaderSplitSingle('Name', CounterNameWidth);
+	DrawHeaderSplitSingleRight('Value', CounterValueWidth + (FontWidth+1));
+	DrawHeaderSplitSingle('Limit', CounterLimitWidth + CounterWidth + 3 * (FontWidth+1));
+
+
+
+
+
+	var CounterNameWidthNew = CounterNameWidthTemp * (FontWidth+1);
+	var CounterValueWidthNew = CounterValueWidthTemp * (FontWidth+1);
+	var CounterLimitWidthNew = CounterLimitWidthTemp * (FontWidth+1);
+	if(CounterNameWidthNew != CounterNameWidth || CounterValueWidthNew != CounterValueWidth || CounterLimitWidthNew != CounterLimitWidth)
+	{
+		// console.log('requesting redraw 0' + CounterNameWidthNew + '= ' + CounterNameWidth );
+		// console.log('requesting redraw 1' + CounterValueWidthNew + '= ' + CounterValueWidth );
+		// console.log('requesting redraw 2' + CounterLimitWidthNew + '= ' + CounterLimitWidth );
+		CounterNameWidth = CounterNameWidthNew;
+		CounterValueWidth = CounterValueWidthNew;
+		CounterLimitWidth = CounterLimitWidthNew;
+		Invalidate = 0;
+	}
+
+	ProfileLeave();
+}
+
+
+//preprocess context switch data to contain array per thread
+function PreprocessContextSwitchCacheItem(ThreadId)
+{
+	var CSObject = S.CSwitchCache[ThreadId];
+	if(ThreadId > 0 && !CSObject)
+	{
+		CSArrayIn = new Array();
+		CSArrayOut = new Array();
+		CSArrayCpu = new Array();
+		var nCount = S.CSwitchTime.length;
+		var j = 0;
+		var TimeIn = -1.0;
+		for(var i = 0; i < nCount; ++i)
+		{
+			var ThreadIn = S.CSwitchThreadInOutCpu[j];
+			var ThreadOut = S.CSwitchThreadInOutCpu[j+1];
+			var Cpu = S.CSwitchThreadInOutCpu[j+2];
+			if(TimeIn < 0)
+			{
+				if(ThreadIn == ThreadId)
+				{
+					TimeIn = S.CSwitchTime[i];
+				}
+			}
+			else
+			{
+				if(ThreadOut == ThreadId)
+				{
+					var TimeOut = S.CSwitchTime[i];
+					CSArrayIn.push(TimeIn);
+					CSArrayOut.push(TimeOut);
+					CSArrayCpu.push(Cpu);
+					TimeIn = -1;
+				}
+			}
+			j += 3;
+		}
+		CSObject = new Object();
+		CSObject.Size = CSArrayIn.length;
+		CSObject.In = CSArrayIn;
+		CSObject.Out = CSArrayOut;
+		CSObject.Cpu = CSArrayCpu;
+		S.CSwitchCache[ThreadId] = CSObject;
+	}
+
+}
+function PreprocessContextSwitchCache()
+{
+	ProfileEnter("PreprocessContextSwitchCache");
+	var AllThreads = {};
+	var nCount = S.CSwitchTime.length;
+	for(var i = 0; i < nCount; ++i)
+	{
+		var nThreadIn = S.CSwitchThreadInOutCpu[i];
+		if(!AllThreads[nThreadIn])
+		{
+		    AllThreads[nThreadIn] = '' + nThreadIn;
+		    var FoundThread = false;
+		    for(var i = 0; i < S.ThreadIds.length; ++i)
+		    {
+		        if(S.ThreadIds[i] == nThreadIn)
+		        {
+		            FoundThread = true;
+		        }
+		    }
+		    if(!FoundThread)
+		    {
+		        S.CSwitchOnlyThreads.push(nThreadIn);
+		    }
+		}
+	}
+	for(var i = 0; i < S.CSwitchOnlyThreads.length; ++i)
+	{
+		PreprocessContextSwitchCacheItem(S.CSwitchOnlyThreads[i]);
+	}
+	for(var i = 0; i < S.ThreadIds.length; ++i)
+	{
+		PreprocessContextSwitchCacheItem(S.ThreadIds[i]);
+	}
+	function HandleMissingThread(a)
+	{
+		if(!S.CSwitchThreads[a])
+		{
+			S.CSwitchThreads[a] = {'tid':a, 'pid':-1, 't':'?', 'p':'?'}
+		}
+	}
+	function CompareThreadInfo(a, b)
+	{
+		if(a.pid != b.pid)
+			return a.pid - b.pid;
+		else
+			return a.tid - b.tid;
+	}
+	S.CSwitchOnlyThreads.sort( function(a, b){
+		HandleMissingThread(a);
+		HandleMissingThread(b);
+		return CompareThreadInfo(S.CSwitchThreads[a], S.CSwitchThreads[b]);
+	} );
+
+	ProfileLeave();
+}
+
+function DrawContextSwitchBars(context, ThreadId, fScaleX, fOffsetY, fDetailedOffset, nHoverColor, MinWidth, bDrawEnabled, bSecond)
+{
+	ProfileEnter("DrawContextSwitchBars");
+	var CSObject = S.CSwitchCache[ThreadId];
+	if(CSObject && CSObject.Size > 0)
+	{
+		var Size = CSObject.Size;
+		var In = CSObject.In;
+		var Out = CSObject.Out;
+		var Cpu = CSObject.Cpu;
+		var nNumColors = CSwitchColors.length;
+		for(var i = 0; i < Size; ++i)
+		{
+			var TimeIn = In[i];
+			var TimeOut = Out[i];
+			var ActiveCpu = Cpu[i];
+
+			var X = (TimeIn - fDetailedOffset) * fScaleX;
+			if(X > nWidth)
+			{
+				break;
+			}
+			var W = (TimeOut - TimeIn) * fScaleX;
+			if(W > MinWidth && X+W > 0)
+			{
+				if(nHoverCSCpu == ActiveCpu || bDrawEnabled)
+				{
+					if(nHoverCSCpu == ActiveCpu)
+					{
+						context.fillStyle = nHoverColor;
+					}
+					else
+					{
+						context.fillStyle = CSwitchColors[ActiveCpu % nNumColors];
+					}
+					context.fillRect(X, fOffsetY, W, CSwitchHeight);
+				}
+				if(DetailedViewMouseX >= X && DetailedViewMouseX <= X+W && DetailedViewMouseY < fOffsetY+CSwitchHeight && DetailedViewMouseY >= fOffsetY)
+				{
+					nHoverCSCpuNext = ActiveCpu;
+					RangeCpuNext.Off = bSecond ? fDetailedOffsetSecond : 0;
+					RangeCpuNext.Begin = TimeIn;
+					RangeCpuNext.End = TimeOut;
+					RangeCpuNext.Thread = ThreadId;
+					RangeGpuNext.Begin = RangeGpuNext.End = -1;
+				}
+			}
+		}
+	}
+	else
+	{
+		//debug: draw context switch without cswitch
+		// for(var i = 0; i < 8; ++i)
+		// {
+		// 	context.fillStyle = CSwitchColors[i];
+		// 	context.fillRect((nWidth * i / 8) + 10, fOffsetY, nWidth / 8 - 20, CSwitchHeight);
+		// }
+	}
+	ProfileLeave();
+}
+
+function DrawDetailedButtons(context, X, Y, Names, Callbacks, Align)
+{
+	if(!Align)
+	{
+		Align = "left";
+	}
+	var Dir = 1;
+	var Offset = 0;
+	var OffsetText = 0;
+	if(Align == "right")
+	{
+		Dir = -1;
+	}
+	else if(Align == "center")
+	{
+		Offset = -0.5;
+		Align = "left";
+	}
+	let W = Array(Names.length);
+	var w = 0;
+	for(let i = 0; i < Names.length; ++i)
+	{
+		W[i] = context.measureText(Names[i]).width;
+		w += W[i];
+	}
+	X += w * Offset;
+
+	// context.textBaseline = 'top';
+	context.textAlign = Align;
+	context.fillStyle = 'white';
+	var mx = DetailedViewMouseX;
+	var my = DetailedViewMouseY;
+	for(let i = 0; i < Names.length; ++i)
+	{
+		let w = W[i];
+		let x0_ = X + w * Dir;
+		let x0 = Math.min(X, x0_);
+		let x1 = Math.max(X, x0_);
+		let y0 = Y;
+		let y1 = Y + FontHeight;
+		context.fillStyle = nBackColors[0];
+		context.fillRect(x0, y0, x1 - x0, y1 - y0);
+
+		if(mx >= x0 && mx <= x1 && my >= y0 && my <= y1)
+		{
+			DetailedMouseOverButton = 1;
+			context.fillStyle = 'cyan';
+			DetailedAddMouseEvent(99, function(){ Callbacks[i](); } );
+		}
+		else
+		{
+			context.fillStyle = 'white';
+		}
+
+		context.fillText(Names[i], X, Y + FontHeight - 2);
+		X += Dir * (w+FontWidth);
+	}
+
+	context.fillStyle = 'white';
+	context.textAlign = 'left';
+}
+
+function DrawDetailedViewLargeHeader(context, Text, Y)
+{
+	context.textAlign = "left";
+	context.fillStyle = "grey";
+	context.strokeStyle = "grey";
+	context.textBaseline = "top";
+	context.font = FontLarge;
+	context.beginPath();
+	context.moveTo(0, Y);
+	context.lineTo(nWidth, Y);
+	context.stroke();
+	context.fillText(Text, 0, Y + 2);
+	context.font = Font;
+	context.textBaseline = "alphabetic";
+	return Y + 2 + FontHeightLarge;
+}
+
+function DrawDetailedView(S, S0, context, MinWidth, bDrawEnabled)
+{
+	if(!S || !S.Frames)
+	{
+		return;
+	}
+	let bSecond = S != S0;
+	if(bDrawEnabled && !bSecond)
+	{
+		DrawDetailedBackground(context);
+	}
+
+	let colors = [ '#ff0000', '#ff00ff', '#ffff00'];
+	let fScaleX = nWidth / fDetailedRange;
+	let fOffsetY = -nOffsetY + BoxHeight;
+
+
+	let nHoverTokenStack = -1;
+	if(S == S0)
+	{
+		nHoverCounter += nHoverCounterDelta;
+		if(nHoverCounter >= 255)
+		{
+			nHoverCounter = 255;
+			nHoverCounterDelta = -nHoverCounterDelta;
+		}
+		if(nHoverCounter < 128)
+		{
+			nHoverCounter = 128;
+			nHoverCounterDelta = -nHoverCounterDelta;
+		}
+	}
+	let nHoverHigh = nHoverCounter.toString(16);
+	let nHoverLow = (127+255-nHoverCounter).toString(16);
+	let nHoverColor = '#' + nHoverHigh + nHoverHigh + nHoverHigh;
+	let nHoverColorIndex;
+
+	context.fillStyle = 'black';
+	context.font = Font;
+	// context.textBaseline = 'alphabetic';
+
+	let nNumLogs = S.Frames[0].ts.length;
+	if(S0)
+	{
+		let l0 = S0.Frames[0].ts.length;
+		let l1 = S.Frames[0].ts.length
+		if(l1 != l0)
+			debugger;
+	}
+	let Off = fDetailedOffset;
+	let XOffset = 0;
+	if(bSecond)
+	{
+		XOffset = fDetailedOffsetSecond;
+		Off += XOffset;
+	}
+	let fTimeEnd = Off + fDetailedRange;
+
+	let FirstFrame = 0;
+	for(let i = 0; i < S.Frames.length ; i++)
+	{
+		if(S.Frames[i].frameend < Off)
+		{
+			FirstFrame = i;
+		}
+	}
+
+	let BoxHeightScaled = BoxHeight;
+	let Scale = 1;
+	let fExtra = 0;
+	let Padding = 15;
+	let SecondReverseOffset = 0;
+	if(DrawDetailedFlameMode == 1)
+	{
+		BoxHeightScaled = Math.ceil(BoxHeight*0.5);
+		fExtra = 0.5;
+	}
+	else if(DrawDetailedFlameMode == 2)
+	{
+		BoxHeightScaled = 0;
+		fExtra = 1;
+	}
+	if(DrawDetailedCompareReverse && bSecond)
+	{
+		Scale = -1;
+		BoxHeightScaled = -BoxHeightScaled;
+		SecondReverseOffset = 5-BoxHeight;
+	}
+	let BoxHeightScaledPos = Math.abs(BoxHeightScaled);
+	let BatchesTxtColor = ['#ffffff', '#333333'];
+	let TotalBatches = 0;
+	let BatchData = {};
+	{
+		let L = BatchData;
+		L.Batches = new Array(g_Colors.length+1);
+		L.BatchesTxt = new Array();
+		L.BatchesTxtPos = new Array();
+		for(let i = 0; i < 2; ++i)
+		{
+			L.BatchesTxt[i] = Array();
+			L.BatchesTxtPos[i] = Array();
+		}
+		for(let i = 0; i < L.Batches.length; ++i)
+		{
+			L.Batches[i] = Array();
+		}
+	}
+	let AddBatch = function(StackPos, index, X, Y, W, Name, NameLen, Duration, Opacity)
+	{
+		TotalBatches++;
+		let L = BatchData;
+		let O = Opacity ? Opacity : 1.0;
+		O = 1-((1-O)*(1-O));
+		let B = L.Batches[index];
+		let txtidx = g_ColorsTextIndex[index];
+		if(txtidx < 0 || txtidx > 1)
+			debugger;
+		let BTxt = L.BatchesTxt[txtidx];
+		let BTxtPos = L.BatchesTxtPos[txtidx];
+		B.push(X);
+		B.push(Y);
+		B.push(W);
+		B.push(O);
+		DebugDrawQuadCount++;
+
+		let XText = X < 0 ? 0 : X;
+		let WText = W - (XText-X);
+		if(XText + WText > nWidth)
+		{
+			WText = nWidth - XText;
+		}
+		let BarTextLen = Math.floor((WText-2)/FontWidth);
+
+		if(BarTextLen >= 2)
+		{
+			let TimeText = TimeToMsString(Duration);
+			let TimeTextLen = TimeText.length;
+			if(BarTextLen < NameLen)
+				Name = Name.substr(0, BarTextLen);
+			let YPos = Y+BoxHeight-FontAscent;
+			BTxt.push(Name);
+			BTxtPos.push(XText+2);
+
+			BTxtPos.push(YPos);
+			DebugDrawTextCount++;
+			if(BarTextLen - NameLen > TimeTextLen)
+			{
+				BTxt.push(TimeText);
+				BTxtPos.push(XText+WText-2 - TimeTextLen * FontWidth);
+				BTxtPos.push(YPos);
+				DebugDrawTextCount++;
+			}
+		}
+	};
+	{
+		let Times = Timeline.Times;
+		let Colors = Timeline.Colors;
+		let Ends = Timeline.Ends;
+		let Positions = Timeline.Positions;
+		let Names = Timeline.Names;
+		let SearchMatch = Timeline.SearchMatch;
+		let off = 0.7;
+		let off2 = 2*off;
+		let MaxPosition = 1;
+		if(Timeline.Positions.length)
+		{
+			fOffsetY = DrawDetailedViewLargeHeader(context, "Timeline", fOffsetY);
+		}
+
+		for(let i = 0; i < Timeline.Positions.length; ++i)
+		{
+			let TimeStart = Times[i];
+			let TimeEnd = Ends[i];
+			let Position = Positions[i];
+			if(Position >= 0)
+			{
+				MaxPosition = Math.max(Position, MaxPosition);
+				let Color = Colors[i];
+				let Name = Names[i];
+				let P = Positions[i];
+				let X = (TimeStart - Off) * fScaleX;
+				let Y = fOffsetY + P * (BoxHeight+2);
+				let W = (TimeEnd-TimeStart)*fScaleX;
+				if(FilterInputSearchActive2)
+				{
+					Color = SearchMatch[i] ? CIDMatch : CIDFail;
+				}
+				if(!bSecond)
+				{
+					if(DetailedViewMouseX >= X && DetailedViewMouseX <= X+W && DetailedViewMouseY < Y+BoxHeight && DetailedViewMouseY >= Y)
+					{
+						RangeCpuNext.Off = 0;
+						RangeCpuNext.Begin = TimeStart;
+						RangeCpuNext.End = TimeEnd;
+						RangeCpuNext.Thread = -1;
+						nHoverColorIndex = Color;
+						Color = cidhovercolor;
+					}
+					AddBatch(0, Color, X, Y, W, Name, Name.length, TimeEnd-TimeStart);
+				}
+			}
+		}
+		fOffsetY += (1+MaxPosition) * (BoxHeight+3);
+	}
+	let nMinTimeMs = MinWidth / fScaleX;
+	let AutoHideCount = 0;
+	let VisibleThreadCount = 0;
+	let DrawGuides = 1;
+	let CurrentHeading;
+	{
+		if(!ThreadYBegin)
+		{
+			ThreadYBegin = Array(S0.ThreadNames.length);
+			ThreadYEnd = Array(S0.ThreadNames.length);
+		}
+
+		for(let i = 0; i < nNumLogs; i++)
+		{
+			let nLog = ThreadOrderT[i];
+			let ThreadName = S0.ThreadNames[nLog];
+			let LogIsGPU = S0.ISGPU[nLog];
+			let HeadingString = LogIsGPU ? "GPU" : "CPU";
+			let Active = IsThreadActive(ThreadName) && 0 == S.ThreadLogAutoHidden[nLog];
+			let ThreadColors = S0.ThreadColors[nLog];
+			if(HeadingString != CurrentHeading)
+			{
+				fOffsetY = DrawDetailedViewLargeHeader(context, HeadingString, fOffsetY);
+				CurrentHeading = HeadingString;
+			}
+
+
+			if(0 != S.ThreadLogAutoHidden[nLog] && HideMode == HideModeFullyHidden)
+			{
+				AutoHideCount++;
+				continue;
+			}
+			if(HideMode == HideModeFullyHidden && !Active)
+			{
+				AutoHideCount++;
+				continue;
+			}
+			VisibleThreadCount++;
+			let SMul = 2;
+			let LogHeight = (S0.MaxStack[nLog]) * BoxHeightScaledPos + BoxHeight;
+			let LogHeight2 = (S0.MaxStack2[nLog]) * BoxHeightScaledPos + BoxHeight;
+			if(nContextSwitchEnabled)
+			{
+				LogHeight += (CSwitchHeight+4);
+				LogHeight2 += (CSwitchHeight+4);
+			}
+			if(!S0.SecondActive)
+			{
+				LogHeight2 = 0;
+			}
+			let OY = fOffsetY;
+			if(!bSecond)
+			{
+				OY += LogHeight2+1;
+			}
+			else
+			{
+				if(DrawDetailedCompareReverse)
+				{
+					OY += LogHeight2 - 5;
+				}
+			}
+
+			let fOffsetYDelta = Active ? (LogHeight + LogHeight2 + Padding) : BoxHeight;
+
+			ThreadYBegin[nLog] = fOffsetY;
+			ThreadYEnd[nLog] = fOffsetY + fOffsetYDelta;
+
+			let ThreadHover = false;
+			if(bDrawEnabled)
+			{
+				if(Active || !bSecond)
+				{
+					let Color = bSecond ? ThreadColors.coloroff : ThreadColors.color;
+					let ColorLine = !bSecond ? ThreadColors.colordark : ThreadColors.color;
+					let BaseY = (bSecond||!Active) ? (fOffsetY+1) : (fOffsetY+1+LogHeight2);
+					let HeightY = !Active ? BoxHeight : (bSecond ? LogHeight2 : (LogHeight + Padding));
+					let TransparentLine = S2.Frames != null && !bSecond;
+					if(TransparentLine)
+					{
+						context.globalAlpha = 0.4;
+					}
+					context.strokeStyle = ColorLine;
+					context.beginPath();
+					context.moveTo(0, BaseY+HeightY-1);
+					context.lineTo(nWidth, BaseY+HeightY-1);
+					context.stroke();
+					if(TransparentLine)
+					{
+						context.globalAlpha = 1.0;
+					}
+					let Gradient = context.createLinearGradient(0,BaseY,0,40 + BaseY);
+					Gradient.addColorStop(0, ThreadColors.colortrans);
+					Gradient.addColorStop(1,'transparent');
+					if(bSecond)
+						ThreadColors.gradientoff = Gradient;
+					else
+						ThreadColors.gradient = Gradient;
+					context.fillStyle = Gradient;
+					context.fillRect(0,BaseY,nWidth,HeightY);
+				}
+			}
+			let D = fOffsetY + BoxHeight - DetailedViewMouseY;
+
+			if(bDrawEnabled && G_DEBUG && 0)
+			{
+				debugger;
+			}
+			if(!bSecond)
+			{
+				if(D > 0 && D < BoxHeight)
+				{
+					if(!bDrawEnabled)
+					{
+						context.globalAlpha = 0.3;
+						context.fillStyle = 'grey';
+						context.fillRect(0, fOffsetY+2, nWidth, Active ? LogHeight2 + LogHeight + Padding : BoxHeight);
+						context.globalAlpha = 1.0;
+					}
+					ThreadHover = 1;
+				}
+			}
+			let HasSetHover = 0;
+
+
+			if(Active)
+			{
+				if(DrawDetailedNewDraw)
+				{
+					OY += 4;
+
+					if(nContextSwitchEnabled)
+					{
+						DrawContextSwitchBars(context, S.ThreadIds[nLog], fScaleX, OY, Off, nHoverColor, MinWidth, bDrawEnabled, bSecond);
+						OY += Scale * (CSwitchHeight+2);
+					}
+					OY += SecondReverseOffset;
+					// Duration of 1 pixel
+					let ThresholdPixelDuration =  fDetailedRange / nWidth;
+					let ThresholdLimit = ThresholdPixelDuration * 1.0; // if below this we dont go further down
+					let Rows = S.LogRows[nLog];
+					for(let r in Rows)
+					{
+						{
+							let Row = Rows[r];
+							let Size = Row.Tree.length;
+							let Tree = Row.Tree;
+							const Y = OY + r * BoxHeightScaled;
+							const MY = DetailedViewMouseY < Y+BoxHeight && DetailedViewMouseY >= Y;
+
+
+							let DrawRange = function(Depth, Begin, End)
+							{
+								let TreeLevel = Tree[Depth];
+								for(let j = Begin; j < End; ++j)
+								{
+									let TimeBegin = TreeLevel.Begin[j];
+									let Duration = TreeLevel.Duration[j];
+									let TimeEnd = TimeBegin + Duration;
+									if(TimeBegin < fTimeEnd && TimeEnd > Off)
+									{
+
+										if(Depth > 0 && TreeLevel.Duration[j] > ThresholdLimit)
+										{
+											DrawRange(Depth-1, j*2, j*2 + 2);
+										}
+										else
+										{
+											let Index = TreeLevel.Index[j];
+											let cid = TreeLevel.ColorIds[j];
+											let Opacity = Depth == 0 ? 1.0 : TreeLevel.SumDuration[j] / TreeLevel.Duration[j];
+
+											if(FilterInputSearchActive2)
+											{
+												if(Depth == 0)
+													cid = S0.TimerInfo[Index].search;
+												else
+													cid = CIDFail;
+											}
+											else
+											{
+												if(GroupColors == 1 && Depth == 0)
+													cid = S0.TimerInfo[Index].cid;
+												if(GroupColors == 2)
+													cid = ThreadColors.colordark_cid;
+												if(GroupColors == 3)
+													cid = TreeLevel.SectionColor[j];
+											}
+											if(Index == nHoverToken)
+											{
+												nHoverColorIndex = cid;
+												cid = cidhovercolor;
+											}
+
+
+											let Name = Depth == 0 ? S0.TimerInfo[Index].name : "";
+											let NameLen = Depth == 0 ? S0.TimerInfo[Index].len : 0;
+											let X = (TimeBegin - Off) * fScaleX;
+											let W = (TimeEnd-TimeBegin)*fScaleX;
+											if(W > 1 || Opacity > 0.1)
+											{
+												AddBatch(Depth, cid, X, Y, W, Name, NameLen, TimeEnd-TimeBegin, Opacity);
+											}
+
+											const M = MY && DetailedViewMouseX >= X && DetailedViewMouseX <= X+W;
+											if(Depth == 0 && M)
+											{
+												RangeCpuNext.Off = bSecond ? fDetailedOffsetSecond : 0;
+												RangeCpuNext.Begin = TimeBegin;
+												RangeCpuNext.End = TimeEnd;
+												RangeCpuNext.Thread = nLog;
+												RangeCpuNext.Off = XOffset;
+												if(TreeLevel.CpuDuration && TreeLevel.CpuDuration[j]) // detect if its a gpu marker, with embedded cpu ticks.
+												{
+													RangeGpuNext.Begin = RangeCpuNext.Begin;
+													RangeGpuNext.End = RangeCpuNext.End;
+													RangeGpuNext.Thread = nLog;
+													RangeGpuNext.Off = XOffset;
+
+													RangeCpuNext.Begin = TreeLevel.CpuBegin[j];
+													RangeCpuNext.End = TreeLevel.CpuBegin[j] + TreeLevel.CpuDuration[j];
+													RangeCpuNext.Thread = TreeLevel.CpuThread[j];
+													RangeCpuNext.Off = XOffset;
+												}
+												else
+												{
+													RangeGpuNext.Begin = -1;
+													RangeGpuNext.End = -1
+												}
+												nHoverTokenNext = Index;
+												nHoverTokenStack = r;
+												nHoverTokenIndexNext = TreeLevel.Source[j];
+												nHoverTokenLogIndexNext = nLog;
+												HoverTokenNextOwner = S;
+												HasSetHover = 1;
+
+
+												if(Index == FilterSearchPassIndex)
+												{
+													console.log("kill this");
+													let Range = RangeInit();
+													Range.Begin = TimeBegin;
+													Range.End = TimeEnd;
+													Range.Thread = nLog;
+													Range.YBegin = Y - ThreadYBegin[nLog];
+													Range.Second = bSecond;
+
+													if(FilterSearchArray.length < 500)
+													{
+														FilterSearchArray.push(Range);
+														if(FilterSearchArray.length == 500)
+														{
+															ShowFlashMessage('Capping Search Result to 500', 30);
+														}
+													}
+												}
+
+
+
+											}
+										}
+									}
+								}
+							}
+							DrawRange(Size-1, 0, Tree[Size-1].Length);
+							// if tree is uneven, the tails won't have parents.
+							for(let i = Size-2; i >= 0; --i)
+							{
+								let TreeLen = Tree[i].Length;
+								if((TreeLen % 2) == 1)
+									DrawRange(i, TreeLen-1, TreeLen);
+							}
+
+						}
+					}
+				}
+				else
+				{
+
+					let LodIndex = 0;
+					let MinDelta = 0;
+					let NextLod = 1;
+					while(NextLod < S.LodData.length && S.LodData[NextLod].MinDelta[nLog] < nMinTimeMs)
+					{
+						LodIndex = NextLod;
+						NextLod = NextLod + 1;
+						MinDelta = S.LodData[LodIndex].MinDelta[nLog];
+					}
+					if(LodIndex == S.LodData.length)
+					{
+						LodIndex = S.LodData.length-1;
+					}
+					if(DisableLod || FilterSearchPassIndex != -1)
+					{
+						LodIndex = 0;
+					}
+
+					OY += 4;
+
+					if(nContextSwitchEnabled)
+					{
+						DrawContextSwitchBars(context, S.ThreadIds[nLog], fScaleX, OY, Off, nHoverColor, MinWidth, bDrawEnabled, bSecond);
+						OY += Scale * (CSwitchHeight+2);
+					}
+					OY += SecondReverseOffset;
+					let MaxDepth = 1;
+					let StackPos = 0;
+					let Stack = Array(20);
+					let Lod = S.LodData[LodIndex];
+
+					let TypeArray = Lod.TypeArray[nLog];
+					let IndexArray = Lod.IndexArray[nLog];
+					let TimeArray = Lod.TimeArray[nLog];
+
+					let LocalFirstFrame = S.Frames[FirstFrame].FirstFrameIndex[nLog];
+					let IndexStart = S.ISGPU[nLog] ? 0 : Lod.LogStart[LocalFirstFrame][nLog];
+					let IndexEnd = TimeArray.length;
+					IndexEnd = TimeArray.length;
+
+
+
+					for(let j = IndexStart; j < IndexEnd; ++j)
+					{
+						let type = TypeArray[j];
+						let index = IndexArray[j];
+						let time = TimeArray[j];
+						if(type == 1)
+						{
+							//push
+							Stack[StackPos] = j;
+							StackPos++;
+							if(StackPos > MaxDepth)
+							{
+								MaxDepth = StackPos;
+							}
+						}
+						else if(type == 0)
+						{
+							if(StackPos>0)
+							{
+								StackPos--;
+
+								let StartIndex = Stack[StackPos];
+								let timestart = TimeArray[StartIndex];
+								let timeend = time;
+								let X = (timestart - Off) * fScaleX;
+								let Y = OY + StackPos * BoxHeightScaled;
+
+								let W = (timeend-timestart)*fScaleX;
+
+								if(X < nWidth && X+W > 0)
+								{
+									if(index == FilterSearchPassIndex)
+									{
+										let Range = RangeInit();
+										Range.Begin = timestart;
+										Range.End = timeend;
+										Range.Thread = nLog;
+										Range.YBegin = Y - ThreadYBegin[nLog];
+										Range.Second = bSecond;
+
+										if(FilterSearchArray.length < 500)
+										{
+											FilterSearchArray.push(Range);
+											if(FilterSearchArray.length == 500)
+											{
+												ShowFlashMessage('Capping Search Result to 500', 30);
+											}
+										}
+									}
+									if(W > MinWidth)
+									{
+										if(bDrawEnabled || index == nHoverToken)
+										{
+											let cid = GroupColors == 2 ? ThreadColors.colordark_cid : S0.TimerInfo[index].cid;
+											if(index == nHoverToken)
+											{
+												nHoverColorIndex = cid;
+												cid = cidhovercolor;
+											}
+											AddBatch(StackPos, cid, X, Y, W, S0.TimerInfo[index].name, S0.TimerInfo[index].len, timeend-timestart);
+										}
+
+
+										if(DetailedViewMouseX >= X && DetailedViewMouseX <= X+W && DetailedViewMouseY < Y+BoxHeight && DetailedViewMouseY >= Y && StackPos > nHoverTokenStack)
+										{
+											RangeCpuNext.Off = bSecond ? fDetailedOffsetSecond : 0;
+											RangeCpuNext.Begin = timestart;
+											RangeCpuNext.End = timeend;
+											RangeCpuNext.Thread = nLog;
+											RangeCpuNext.Off = XOffset;
+											if((TypeArray[StartIndex+1]&3) == 3 && (TypeArray[j+1]&3) == 3)
+											{
+												RangeGpuNext.Begin = RangeCpuNext.Begin;
+												RangeGpuNext.End = RangeCpuNext.End;
+												RangeGpuNext.Thread = nLog;
+												RangeGpuNext.Off = XOffset;
+												//cpu tick is stored following
+												RangeCpuNext.Begin = TimeArray[StartIndex+1];
+												RangeCpuNext.End = TimeArray[j+1];
+												RangeCpuNext.Thread = IndexArray[StartIndex+1];
+												RangeCpuNext.Off = XOffset;
+											}
+											else
+											{
+												RangeGpuNext.Begin = -1;
+												RangeGpuNext.End = -1
+											}
+
+											nHoverTokenNext = index;
+											nHoverTokenStack = StackPos;
+											nHoverTokenIndexNext = j;
+											nHoverTokenLogIndexNext = nLog;
+											HoverTokenNextOwner = S;
+											HasSetHover = 1;
+										}
+									}
+								}
+								if(StackPos == 0 && time > fTimeEnd)
+									break;
+							}
+						}
+					}
+					// if(HasSetHover)
+					// {
+					// 	for(let i = 0; i < S.Frames.length-1; ++i)
+					// 	{
+					// 		let IndexStart = Lod.LogStart[i][nLog];
+					// 		if(nHoverTokenIndexNext >= IndexStart)
+					// 		{
+					// 			nHoverFrame = i;
+					// 		}
+					// 	}
+					// }
+				}
+			}
+			let w = context.measureText(ThreadName).width;
+			context.fillStyle = nBackColors[0];
+			context.fillStyle = 'white';
+			context.fillText(ThreadName, 0, fOffsetY+FontHeight-1);
+			if(ThreadHover)
+			{
+				DrawDetailedButtons(context, nWidth, fOffsetY+1, ["\u2191\u2191\u2191", "\u2193\u2193\u2193", "\u2191", "\u2193"],
+					[function(){ThreadOrderMoveUp(ThreadName,1);}, function(){ThreadOrderMoveDown(ThreadName,1);},
+					function(){ThreadOrderMoveUp(ThreadName);}, function(){ThreadOrderMoveDown(ThreadName);}],
+					 "right");
+							// DetailedAddMouseEvent(1, function(){ Callbacks[i](); } );
+				DetailedAddMouseEvent(1, function()
+				{
+					ToggleThread(ThreadName);
+				});
+			}
+			// context.textBaseline = 'alphabetic';
+			fOffsetY += fOffsetYDelta;
+			// ThreadY[nLog+1] = fOffsetY;
+		}
+		if(AutoHideCount)
+		{
+			fOffsetY += FontHeight;
+			let Text = AutoHideCount + " Threads Auto Hidden. Toggle in Thread Menu to show";
+			let w = context.measureText(Text).width;
+			context.fillStyle = "orange";
+			context.fillText(Text, 0, fOffsetY+FontHeight-1);
+		}
+		if(VisibleThreadCount == 0 && HideMode == HideModeFullyHidden)
+		{
+			fOffsetY += FontHeight;
+			let Text = "All Threads Hidden. Toggle in Thread Menu to show";
+			let w = context.measureText(Text).width;
+			context.fillStyle = "red";
+			context.fillText(Text, 0, fOffsetY+FontHeight-1);
+		}
+
+		if(nContextSwitchEnabled && !bSecond) //non instrumented threads.
+		{
+			let CurrentPid = -112;
+			let ContextSwitchThreads = S.CSwitchOnlyThreads;
+			function DrawHeader(str, X, Y)
+			{
+				let width = str.length * FontWidth;
+				context.globalAlpha = 0.5;
+				context.fillStyle = 'grey';
+				context.fillRect(X, Y-FontHeight + 2, width, FontHeight);
+				context.globalAlpha = 1.0;
+				context.fillStyle = 'white';
+				context.fillText(str, X, Y);
+
+
+			}
+			for(let i = 0; i < ContextSwitchThreads.length; ++i)
+			{
+				let ThreadId = ContextSwitchThreads[i];
+				let ThreadName = '' + ThreadId;
+				let TI = S.CSwitchThreads[ThreadId];
+
+				if(TI)
+				{
+					if(CurrentPid != TI.pid)
+					{
+						fOffsetY += BoxHeight + 1;
+						CurrentPid = TI.pid;
+						let str = TI.pid.toString(16) +':' +TI.p;
+						DrawHeader(str, 0, fOffsetY+5);
+						fOffsetY += BoxHeight + 1;
+					}
+				}
+
+				DrawContextSwitchBars(context, ThreadId, fScaleX, fOffsetY, Off, nHoverColor, MinWidth, bDrawEnabled);
+
+				if(TI)
+				{
+					DrawHeader(TI.tid.toString(16) +':' +TI.t, 10, fOffsetY+5);
+ 				}
+				fOffsetY += BoxHeight + 1;
+			}
+		}
+		{
+			let h = nHeight;
+
+		}
+		let TOP_LIMIT = 100;
+		if(fOffsetY < TOP_LIMIT)
+		{
+			let Diff = fOffsetY - TOP_LIMIT;
+			nOffsetY += Math.floor(Diff);
+			nOffsetY = Math.max(0, nOffsetY);
+		}
+		let FillRects = function(a, color, colordark)
+		{
+			context.fillStyle = color;
+			let opac = -1;
+			for(let j = 0; j < a.length; j += 4)
+			{
+				let X = a[j];
+				let Y = a[j+1];
+				let W = a[j+2];
+				let O = a[j+3];
+				if(O != opac)
+				{
+					opac = O;
+					context.globalAlpha = opac;
+				}
+				context.fillRect(X, Y, W, BoxHeight-1);
+			}
+		};
+		let rect_calls = 0;
+		let text_calls = 0;
+
+		{
+			let Batches = BatchData.Batches;
+			for(let i = 0; i < Batches.length; ++i)
+			{
+				let a = Batches[i];
+				if(a.length)
+				{
+					let Color = i == 0 ? nHoverColor : g_Colors[i];
+					let ColorDark = i == 0 ? nHoverColor : g_ColorsDark[i];
+					if(i == 0)
+					{
+						if(nHoverColorIndex)
+						{
+							let mult = nHoverCounter / 255.0;
+							let m2 =mult -0.5;
+							let m4 = m2 * 0.5;
+							let f = function()
+							{
+								let H = g_ColorH[nHoverColorIndex];
+								let S = g_ColorS[nHoverColorIndex];
+								let L = g_ColorL[nHoverColorIndex];
+								let offset = 0;
+								if(S> 0.5)
+									offset = 0.5 - S;
+								let offsetL = 0;
+								if(L > 0.75)
+									offsetL = 0.75 - L;
+								L = L + m4 + offsetL;
+								L = L > 1 ? 1 : (L < 0 ? 0 : L);
+								S = S + m2 + offset;
+								S = S > 1 ? 1 : (S < 0 ? 0 : S);
+								return ConvertHslToColor(H, S, L);
+							};
+							let ColorCV = f();
+							ColorDark = Color = ColorCV; ;
+						}
+					}
+					FillRects(a, Color, ColorDark);
+					rect_calls += a.length;
+
+				}
+			}
+			context.globalAlpha = 1.0;
+			let BatchesTxt = BatchData.BatchesTxt;
+			let BatchesTxtPos = BatchData.BatchesTxtPos;
+			for(let i = 0; i < BatchesTxt.length; ++i)
+			{
+				context.fillStyle = BatchesTxtColor[i];
+				let TxtArray = BatchesTxt[i];
+				let PosArray = BatchesTxtPos[i];
+				for(let j = 0; j < TxtArray.length; ++j)
+				{
+					let k = j * 2;
+					context.fillText(TxtArray[j], PosArray[k],PosArray[k+1]);
+
+				}
+				text_calls += TxtArray.length;
+			}
+
+		}
+		// console.log("rect_calls ", rect_calls, " text_calls ", text_calls);
+
+	}
+//	console.log("Total Batches ", TotalBatches);
+
+}
+
+
+function DrawTextBox(context, text, x, y, align)
+{
+	let textsize = context.measureText(text).width;
+	let offsetx = 0;
+	let offsety = -FontHeight;
+	if(align == 'center')
+	{
+		offsetx = -textsize / 2.0;
+	}
+	else if(align == 'right')
+	{
+		offsetx = -textsize;
+	}
+	context.fillStyle = nBackColors[0];
+	context.fillRect(x + offsetx, y + offsety, textsize+2, FontHeight + 2);
+	context.fillStyle = 'white';
+	context.fillText(text, x, y);
+
+}
+
+function DrawFilterSearchRanges(context, Ranges, ColorBack, ColorFront, ThreadY)
+{
+	if(0 == Ranges.length)
+		return;
+	//todo: arrow key support
+	var MarginTop = 1.0 * FontHeight;
+	var MarginBottom = nHeight - 1.0 * FontHeight;
+
+
+	var Time = new Date();
+	var Delta = Time - FilterSearchStartTime;
+	var BlinkTime = 2.5 * 1000;
+	var Blinks = 5;
+	var HoverFloat = 0.2;
+	var Blinking = 0;
+	if(Delta < BlinkTime)
+	{
+		Blinking = 1;
+		var b0 = Blinks* Math.PI * Delta;
+		var b1 = b0 / BlinkTime;
+		var Mag = Math.abs(Math.sin(b1));
+		HoverFloat = Mag * 0.5 + 0.2;
+	}
+	var Lines = new Array();
+	var Rects = new Array();
+
+
+	for(var i = 0; i < Ranges.length; ++i)
+	{
+		var Range = Ranges[i];
+		let Off = Range.Second ? fDetailedOffsetSecond : 0
+		var fBegin = Range.Begin - Off;
+		var fEnd = Range.End - Off;
+		var OffsetTop = Range.YBegin + ThreadY[Range.Thread];
+		var OffsetBottom = OffsetTop + BoxHeight;
+
+		if(fBegin < fEnd)
+		{
+			{
+				OffsetTop = Math.max(OffsetTop, 0);
+				OffsetBottom = Math.max(OffsetBottom, MarginTop);
+				OffsetTop = Math.min(OffsetTop, MarginBottom);
+				OffsetBottom = Math.min(OffsetBottom, nHeight);
+				var fScaleX = nWidth / fDetailedRange;
+				var X = (fBegin - fDetailedOffset) * fScaleX;
+				var Y = OffsetTop;
+				var W = (fEnd - fBegin) * fScaleX;
+				if(W > 1)
+				{
+					Rects.push(X-3);
+					Rects.push(OffsetTop-3);
+					Rects.push(W+5);
+					Rects.push(5 + OffsetBottom - OffsetTop);
+				}
+				else
+				{
+					X += W * 0.5;
+					Lines.push(X);
+					context.beginPath();
+					context.moveTo(X, 0);
+					context.lineTo(X, nHeight);
+					context.stroke();
+				}
+			}
+		}
+	}
+
+	context.fillStyle = ColorBack;
+	context.strokeStyle = ColorBack;
+
+	context.globalAlpha = HoverFloat;
+
+	for(var i = 0; i < Rects.length;)
+	{
+		var X = Rects[i++];
+		var Y = Rects[i++];
+		var W = Rects[i++];
+		var H = Rects[i++];
+		context.fillRect(X, Y, W, H);
+	}
+	context.globalAlpha = 1;
+	for(var i = 0; i < Rects.length;)
+	{
+		var X = Rects[i++];
+		var Y = Rects[i++];
+		var W = Rects[i++];
+		var H = Rects[i++];
+		context.strokeRect(X, Y, W, H);
+	}
+
+	for(var i = 0; i < Lines.length; ++i)
+	{
+		context.beginPath();
+		context.moveTo(Lines[i], 0);
+		context.lineTo(Lines[i], nHeight);
+		context.stroke();
+	}
+	if(Blinking>0)
+	{
+		Invalidate = 1;
+	}
+
+}
+
+
+function DrawRange(context, Range, ColorBack, ColorFront, Name, Offset)
+{
+	if(!Offset)
+		Offset = 0;
+	var fBegin = Range.Begin;
+	var fEnd = Range.End;
+	var OffsetTop = Range.YBegin;
+	var OffsetBottom = Range.YEnd;
+	var Off = Range.Off + fDetailedOffset;
+	if(fBegin < fEnd)
+	{
+		var MarginTop = (1.0+Offset) * (FontHeight+1);
+		var MarginBottom = nHeight - (Offset+1.5) * (FontHeight+1);
+		if(OffsetTop < MarginTop)
+		{
+			Offset += 1;
+			OffsetTop = MarginTop;
+		}
+		if(OffsetBottom > MarginBottom)
+		{
+			OffsetBottom = MarginBottom;
+		}
+		var fRulerOffset = FontHeight * 0.5;
+		var fScaleX = nWidth / fDetailedRange;
+		var X = (fBegin - Off) * fScaleX;
+		var YSpace = (FontHeight+2);
+		var Y = OffsetTop;
+		var YBottom = OffsetBottom;
+		var W = (fEnd - fBegin) * fScaleX;
+		context.globalAlpha = 0.1;
+		context.fillStyle = ColorBack;
+		context.fillRect(X, OffsetTop + fRulerOffset, W, OffsetBottom - OffsetTop);
+		context.globalAlpha = 1;
+		context.strokeStyle = ColorFront;
+		context.beginPath();
+		context.moveTo(X, 0);
+		context.lineTo(X, nHeight);
+		context.moveTo(X+W, 0);
+		context.lineTo(X+W, nHeight);
+		context.stroke();
+		var Duration = (fEnd - fBegin).toFixed(2) + "ms";
+		var Center = ((fBegin + fEnd) / 2.0) - Off;
+		var DurationWidth = context.measureText(Duration+ "   ").width;
+
+		context.fillStyle = 'white';
+		context.textAlign = 'right';
+		var TextPosY = Y + YSpace;
+		DrawTextBox(context, (fBegin-Range.Off).toFixed(2), X-3, TextPosY, 'right');
+		var YS = [Y, YBottom];
+		for(var i = 0; i < YS.length; ++i)
+		{
+			var Y = YS[i];
+			var Y0 = Y + fRulerOffset;
+			var W0 = W - DurationWidth + FontWidth*1.5;
+			if(W0 > 6)
+			{
+				context.textAlign = 'center';
+				DrawTextBox(context, Duration,Center * fScaleX, Y + YSpace, 'center');
+				W0 = W0 / 2.0;
+				var X0 = X + W0;
+				var X1 = X + W - W0;
+				context.strokeStyle = ColorFront;
+				context.beginPath();
+				context.moveTo(X, Y0);
+				context.lineTo(X0, Y0);
+				context.moveTo(X0, Y0-2);
+				context.lineTo(X0, Y0+2);
+				context.moveTo(X1, Y0-2);
+				context.lineTo(X1, Y0+2);
+				context.moveTo(X1, Y0);
+				context.lineTo(X + W, Y0);
+				context.stroke();
+			}
+			else
+			{
+				if(i == 1)
+				{
+					context.textAlign = 'right';
+					DrawTextBox(context, Duration, X - 3, Y0, 'right');
+					context.textAlign = 'left';
+					DrawTextBox(context, Duration, X + W + 2, Y0, 'left');
+				}
+				context.strokeStyle = ColorFront;
+				context.beginPath();
+				context.moveTo(X, Y0);
+				context.lineTo(X+W, Y0);
+				context.stroke();
+			}
+		}
+		context.textAlign = 'left';
+		DrawTextBox(context, (fEnd-Range.Off).toFixed(2), X + W + 2, TextPosY, 'left');
+		DrawTextBox(context, Name, X + W + 2, OffsetTop + YSpace + FontHeight, 'left');
+	}
+	return Offset;
+}
+function DetailedAddMouseEvent(P, E)
+{
+	if(!DetailedMouseEvent)
+	{
+		DetailedMouseEvent = {"P":P, "E":E};
+	}
+	else if(DetailedMouseEvent.P < P)
+	{
+		DetailedMouseEvent.P = P;
+		DetailedMouseEvent.E = E;
+	}
+
+}
+
+function CreateGraphData(Samples, Name, Color)
+{
+	let gd = {};
+	gd.Samples = Samples;
+	gd.Name = Name;
+	gd.Color = Color;
+	return gd;
+}
+
+function CreateDrawGraphParameters()
+{
+	let P = {};
+	P.Rect = WindowRect(0, 0, 1, 1);
+	P.RangeMin = 0.0;
+	P.RangeMax = 0.0;
+	P.Mark = [16.66, 33.33];
+	P.Ext = "ms";
+	P.Border = 2;
+	P.Frame = 1;
+	return P;
+}
+
+
+
+function DrawGraph(context, Parameters, data, Mouse)
+{
+
+	ProfileEnter("DrawGraph");
+	let Rect = Parameters.Rect;
+	let RangeMin = Parameters.RangeMin;
+	let RangeMax = Parameters.RangeMax;
+	let MaxLen = 0;
+	let MaxSample = 0;
+	let MinSample = 1e25;
+	for(let i in data)
+	{
+		let d = data[i];
+		MaxLen = Math.max(MaxLen, d.Samples.length);
+		for(let j in d.Samples)
+		{
+			MaxSample = Math.max(MaxSample, d.Samples[j]);
+			MinSample = Math.max(MinSample, d.Samples[j]);
+		}
+	}
+	if(0 == MaxLen)
+		return;
+
+	if(RangeMax <= RangeMin)
+	{
+		RangeMin = MinSample;
+		RangeMax = MaxSample;
+	}
+
+
+	let Ext = Parameters.Ext;
+	let Border = Parameters.Border;
+	let Frame = Parameters.Frame;
+	if(Frame)
+		Border += 10;
+
+	let wx = Rect.x;
+	let wy = Rect.y;
+	let wh = Rect.h;
+	let ww = Rect.w;
+
+	let x = Rect.x + Border;
+	let y = Rect.y + Border;
+	let h = Rect.h - 2*Border;
+	let w = Rect.w - 2*Border;
+
+	let MouseX = Mouse.X-x;
+	let MouseY = Mouse.Y-y;
+	let MouseInside = Mouse.X >= x && Mouse.Y >= y && Mouse.X < x + w && Mouse.Y < y + h;
+	let MouseXPrc = (Mouse.X - x) / (w-1);
+
+	context.clearRect(wx, wy, ww, wh);
+
+
+	let SampleWidth = w / (MaxLen-1);
+	let MouseIndex = Math.max(0, Math.min(MaxLen-1, Math.floor(MouseXPrc * MaxLen)));
+
+	let HeightScale = h / (RangeMax-RangeMin);
+	let Y = y + h;
+	let YStart = Y;
+
+	for(let dataindex in data)
+	{
+		let LocalElement = data[dataindex];
+		let Samples = LocalElement.Samples;
+		let X = x + w - (Samples.length-1)*SampleWidth;
+		Y = y + h;
+
+		context.globalAlpha = 1;
+		context.strokeStyle = LocalElement.Color;
+		context.fillStyle = LocalElement.Color;
+		context.beginPath();
+		for(let i = 0; i < Samples.length; ++i)
+		{
+			Y = Math.max(YStart - Samples[i] * HeightScale, y);
+			if(i == 0)
+				context.moveTo(X, Y);
+			else
+				context.lineTo(X, Y);
+			X += SampleWidth;
+
+		}
+		let GRAPH_ALPHA = 0.2;
+		context.stroke();
+		context.lineTo(X-SampleWidth, YStart);
+		context.lineTo(x, YStart);
+		context.globalAlpha = GRAPH_ALPHA;
+		context.fill();
+
+		if(MouseInside)
+		{
+			let MouseSample = Samples[MouseIndex];
+			let Y = Math.max(YStart - MouseSample * HeightScale, y);
+			let X = x + w + (MouseIndex - (Samples.length-1))*SampleWidth;
+
+			context.globalAlpha = 0.8;
+			context.beginPath();
+			context.arc(X, Y, 2, 0, 2 * Math.PI);
+			context.fill();
+
+			context.globalAlpha = 1;
+
+			context.beginPath();
+			context.arc(X, Y, 3, 0, 2 * Math.PI);
+			context.stroke();
+		}
+
+
+	}
+	context.globalAlpha = 1;
+	context.fillStyle = 'wheat';
+	context.strokeStyle = 'wheat';
+	context.textAlign='right';
+	context.fillText(RangeMax + Ext, x+w, y + FontHeight);
+	for(let m in Parameters.Mark)
+	{
+		let Sample = Parameters.Mark[m];
+		let Y = YStart - Sample * HeightScale;
+		context.fillText(Sample + Ext, x+w, Y + FontHeight);
+	}
+
+
+	context.globalAlpha = 0.4;
+	for(let m in Parameters.Mark)
+	{
+		let Sample = Parameters.Mark[m];
+		let Y = YStart - Sample * HeightScale;
+		{
+			context.beginPath();
+			context.moveTo(x-(Frame?5:0), Y);
+			context.lineTo(x+w, Y);
+			context.stroke();
+		}
+	}
+	context.globalAlpha = 1;
+	if(Frame)
+	{
+		context.beginPath();
+		context.moveTo(x-5, YStart);
+		context.lineTo(x+w+5, YStart);
+		context.stroke();
+
+		context.beginPath();
+		context.moveTo(x, YStart+5);
+		context.lineTo(x, YStart-h-5);
+		context.stroke();
+
+		context.beginPath();
+		context.moveTo(x, YStart-h);
+		context.lineTo(x-5, YStart-h);
+		context.stroke();
+	}
+
+	for(let dataindex = 0; dataindex < data.length; ++dataindex)
+	{
+		let LocalElement = data[dataindex];
+		context.textAlign='left';
+		context.strokeStyle = LocalElement.Color;
+		context.fillStyle = LocalElement.Color;
+		context.fillText(LocalElement.Name, x+2, y + FontHeight * (dataindex+1));
+	}
+
+	if(MouseInside)
+	{
+		ToolTipImmediate = new Array();
+		for(let dataindex in data)
+		{
+			let LocalElement = data[dataindex];
+			let Samples = LocalElement.Samples;
+			ToolTipImmediate.push(LocalElement.Name);
+			ToolTipImmediate.push(FormatTime(Samples[MouseIndex])+ Parameters.Ext);
+		}
+	}
+
+	ProfileLeave();
+}
+
+function DrawDetailed(Animation)
+{
+	DetailedMouseEvent = null;
+
+	if(!Initialized)
+	{
+		return;
+	}
+	ProfileEnter("DrawDetailed");
+	DetailedMouseOverButton = false;
+
+	DebugDrawQuadCount = 0;
+	DebugDrawTextCount = 0;
+	nHoverCSCpuNext = -1;
+
+	RangeCpuNext = RangeInit();
+	RangeGpuNext = RangeInit();
+
+	var start = new Date();
+	nDrawCount++;
+
+	var context = CanvasDetailedView.getContext('2d');
+	var offscreen = CanvasDetailedOffscreen.getContext('2d');
+	var fScaleX = nWidth / fDetailedRange;
+	var fOffsetY = -nOffsetY + BoxHeight;
+	if(DetailedRedrawState.fOffsetY == fOffsetY && DetailedRedrawState.fDetailedOffset == fDetailedOffset && DetailedRedrawState.fDetailedRange == fDetailedRange && !KeyCtrlDown && !KeyShiftDown && !KeyAltDown && !MouseDragButton && !RedrawRequested)
+	{
+		Invalidate++;
+	}
+	else
+	{
+		Invalidate = 0;
+		DetailedRedrawState.fOffsetY = fOffsetY;
+		DetailedRedrawState.fDetailedOffset = fDetailedOffset;
+		DetailedRedrawState.fDetailedRange = fDetailedRange;
+	}
+	if(nHoverTokenDrawn != nHoverToken)
+	{
+		Invalidate = 1;
+	}
+	nHoverTokenDrawn = nHoverToken;
+	nHoverTokenNext = -1;
+	HoverTokenNextOwner = null;
+	nHoverTokenLogIndexNext = -1;
+	nHoverTokenIndexNext = -1;
+
+
+
+	if(DrawDetailedNewDraw || Invalidate == 0) //when panning, only draw bars that are a certain width to keep decent framerate
+	{
+		context.clearRect(0, 0, CanvasDetailedView.width, CanvasDetailedView.height);
+		DrawDetailedView(S, S, context, nMinWidthPan, true);
+		DrawDetailedView(S2, S, context, nMinWidthPan, true, 1);
+		ProfileRedraw0++;
+	}
+	else if(Invalidate == 1) //draw full and store
+	{
+		offscreen.clearRect(0, 0, CanvasDetailedView.width, CanvasDetailedView.height);
+		DrawDetailedView(S, S, offscreen, nMinWidth, true);
+		DrawDetailedView(S2, S, offscreen, nMinWidth, true, 1);
+		OffscreenData = offscreen.getImageData(0, 0, CanvasDetailedOffscreen.width, CanvasDetailedOffscreen.height);
+		ProfileRedraw1++;
+	}
+	else//reuse stored result untill next time viewport is changed.
+	{
+		context.clearRect(0, 0, CanvasDetailedView.width, CanvasDetailedView.height);
+		context.putImageData(OffscreenData, 0, 0);
+		DrawDetailedView(S, S, context, nMinWidth, false);
+		DrawDetailedView(S2, S, context, nMinWidth, false, 1);
+		ProfileRedraw2++;
+	}
+
+	if(KeyShiftDown || KeyCtrlDown || MouseDragSelectRange() || ZoomActive || FilterSearchActive)
+	{
+		nHoverToken = -1;
+		nHoverTokenIndex = -1;
+		nHoverTokenLogIndex = -1;
+		HoverTokenOwner = null;
+		RangeCpu = RangeInit();
+		RangeGpu = RangeInit();
+	}
+	else
+	{
+		nHoverToken = nHoverTokenNext;
+		HoverTokenOwner = HoverTokenNextOwner;
+		nHoverTokenIndex = nHoverTokenIndexNext;
+		nHoverTokenLogIndex = nHoverTokenLogIndexNext;
+		if(RangeValid(RangeCpuHistory))
+		{
+			RangeCopy(RangeCpu, RangeCpuHistory);
+			RangeCopy(RangeGpu, RangeGpuHistory);
+		}
+		else
+		{
+			RangeCopy(RangeCpu, RangeCpuNext);
+			RangeCopy(RangeGpu, RangeGpuNext);
+		}
+	}
+
+	DrawTextBox(context, TimeToMsString(fDetailedOffset), 0, FontHeight, 'left');
+	context.textAlign = 'right';
+	DrawTextBox(context, TimeToMsString(fDetailedOffset + fDetailedRange), nWidth, FontHeight, 'right');
+	context.textAlign = 'left';
+
+	if(!FilterSearchActive && !IgnoreInput && SubMenuActive == -1)
+	{
+		let Colors = GroupColors == 3 ? "Color[Section]" : (GroupColors == 2 ? "Color[thread]" : (GroupColors ? "Color[group]" : "Color[timer]"));
+		DrawDetailedButtons(context, nWidth * 0.5, 0, [Colors],[function(){ToggleGroupColors(1);}], "center");
+	}
+
+
+	var YBegin = ThreadYBegin[fRangeThreadIdNext];
+	var YEnd = ThreadYEnd[fRangeThreadIdNext];
+	var YBeginGpu = YBegin;
+	var YEndGpu = YEnd;
+	function RangeSet(R)
+	{
+		if(R.Thread >= 0)
+		{
+			R.YBegin = ThreadYBegin[R.Thread];
+			R.YEnd = ThreadYEnd[R.Thread];
+		}
+		else
+		{
+			R.YBegin = 0;
+			R.YEnd = nHeight;
+		}
+	}
+	RangeSet(RangeSelect);
+	RangeSet(RangeCpu);
+	RangeSet(RangeGpu);
+	var Offset = 0;
+	Offset = DrawRange(context, RangeSelect, '#59d0ff', '#00ddff', "Selection", Offset);
+	Offset = DrawRange(context, RangeCpu, '#009900', '#00ff00', "Cpu", Offset);
+	Offset = DrawRange(context, RangeGpu, '#996600', '#775500', "Gpu", Offset);
+
+	DrawFilterSearchRanges(context, FilterSearchArray, '#ff9900', '#ff9900', ThreadYBegin);
+
+	nHoverCSCpu = nHoverCSCpuNext;
+
+	DrawFilterSearch();
+
+	ProfileDrawFrameTimeGraph(context);
+
+	ProfileLeave();
+}
+function ZoomToHighlight(NoGpu)
+{
+	if(RangeValid(RangeGpu) && !NoGpu)
+	{
+		ZoomToRange(RangeGpu);
+	}
+	else if(RangeValid(RangeCpu))
+	{
+		ZoomToRange(RangeCpu);
+	}
+	RangeCpu = RangeInit();
+	RangeGpu = RangeInit();
+}
+
+function MoveToNext(Direction) //1 forward, -1 backwards
+{
+	var fTimeBegin, fTimeEnd, nLog;
+	var Index = nHoverToken;
+
+	if(nHoverToken != -1 && nHoverTokenLogIndex != -1)
+	{
+		fTimeBegin = RangeCpu.Begin;
+		fTimeEnd = RangeCpu.End;
+		nLog = nHoverTokenLogIndex;
+	}
+	else if(RangeValid(RangeSelect))
+	{
+		fTimeBegin = RangeSelect.Begin;
+		fTimeEnd = RangeSelect.End;
+		nLog = RangeSelect.Thread;
+		Index = RangeSelect.Index;
+	}
+	else
+	{
+		return;
+	}
+	if(nLog<0)
+	{
+		return;
+	}
+	var Forward = Direction && Direction < 0 ? 0 : 1;
+	var bFound = false;
+	var nStackPos = 0;
+	var fResultTimeBegin, fResultTimeEnd;
+	var TypeBegin = Forward ? 1 : 0;
+	var TypeEnd = Forward ? 0 : 1;
+	var SearchTimeBegin = Forward ? fTimeBegin : fTimeEnd;
+
+	var istart = Forward ? 0 : S.Frames.length-1;
+	var iend = Forward ? S.Frames.length : -1;
+	var idelta = Forward ? 1 : -1;
+	for(var i = istart; i != iend; i += idelta)
+	{
+		var fr = S.Frames[i];
+		var ts = fr.ts[nLog];
+		var ti = fr.ti[nLog];
+		var tt = fr.tt[nLog];
+		var jstart = Forward ? 0 : ts.length-1;
+		var jend = Forward ? ts.length : -1;
+		var jdelta = Forward ? 1 : -1;
+		for(var j = jstart; j != jend; j += jdelta)
+		{
+			if(!bFound)
+			{
+				if(tt[j] == TypeBegin && Index == ti[j])
+				{
+					if(SearchTimeBegin == ts[j])
+					{
+						bFound = true;
+					}
+				}
+			}
+			else
+			{
+				if(Index == ti[j])
+				{
+					var type = tt[j];
+					if(type == TypeBegin)
+					{
+						if(0 == nStackPos)
+						{
+							fResultTimeBegin = ts[j];
+						}
+						nStackPos++;
+					}
+					else if(type == TypeEnd && nStackPos)
+					{
+						nStackPos--;
+						if(0 == nStackPos)
+						{
+							fResultTimeEnd = ts[j];
+							if(0 == Forward)
+							{
+								var Tmp = fResultTimeBegin;
+								fResultTimeBegin = fResultTimeEnd;
+								fResultTimeEnd = Tmp;
+							}
+							RangeSelect.Begin = fResultTimeBegin;
+							RangeSelect.End = fResultTimeEnd;
+							RangeSelect.Thread = nLog;
+							RangeSelect.Index = Index;
+							MoveTo(fResultTimeBegin,fResultTimeEnd);
+							return;
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+function MoveTo(fMoveBegin, fMoveEnd, YTop, YBottom)
+{
+	var nOffsetYBottom = YBottom - nHeight;
+	var nOffsetYDest = nOffsetY;
+	if(nOffsetYDest < nOffsetYBottom)
+	{
+		nOffsetYDest = nOffsetYBottom;
+	}
+	if(nOffsetYDest > YTop)
+	{
+		nOffsetYDest = YTop;
+	}
+	var fRange = fDetailedRange;
+	var fMinRange = (fMoveEnd-fMoveBegin) * 2.0;
+	if(fRange < fMinRange)
+	{
+		fRange = fMinRange;
+	}
+	var fMoveCenter = (fMoveBegin + fMoveEnd) * 0.5;
+	fMoveBegin = fMoveCenter - 0.5 * fRange;
+	fMoveEnd = fMoveCenter + 0.5 * fRange;
+	var nOffset;
+	if(nOffsetYDest != nOffsetY)
+		nOffset = nOffsetYDest;
+	ZoomTo(fMoveBegin, fMoveEnd, nOffsetYDest, -1);
+}
+
+function ZoomToRange(R)
+{
+	ZoomTo(R.Begin, R.End, 0, 0, R.Off);
+}
+
+let ZoomCallback = null;
+
+function ZoomTo(fZoomBegin, fZoomEnd, OffsetYDest, ZoomTime, fOffset)
+{
+	if(fZoomBegin < fZoomEnd)
+	{
+		if(fOffset)
+		{
+			fZoomBegin -= fOffset;
+			fZoomEnd -= fOffset;
+		}
+		AnimationActive = true;
+		var fDetailedOffsetOriginal = fDetailedOffset;
+		var fDetailedRangeOriginal = fDetailedRange;
+		var fDetailedOffsetTarget = fZoomBegin;
+		var fDetailedRangeTarget = fZoomEnd - fZoomBegin;
+		var OffsetYOriginal = nOffsetY;
+		var OffsetYTarget = OffsetYDest;
+		var TimestampStart = new Date();
+		var count = 0;
+		if(!ZoomTime)
+		{
+			ZoomTime = ZOOM_TIME;
+		}
+
+		function ZoomFunc()
+		{
+			ZoomActive = 1;
+			var fPrc = (new Date() - TimestampStart) / (ZoomTime * 1000.0);
+			if(fPrc > 1.0 || ZoomTime < 0.01)
+			{
+				fPrc = 1.0;
+			}
+			fPrc = Math.pow(fPrc, 0.3);
+			fDetailedOffset = fDetailedOffsetOriginal + (fDetailedOffsetTarget - fDetailedOffsetOriginal) * fPrc;
+			fDetailedRange = fDetailedRangeOriginal + (fDetailedRangeTarget - fDetailedRangeOriginal) * fPrc;
+			if(OffsetYDest)
+			{
+				nOffsetY = OffsetYOriginal + (OffsetYTarget - OffsetYOriginal) * fPrc;
+			}
+			if(fPrc >= 1.0)
+			{
+				AnimationActive = false;
+				fDetailedOffset = fDetailedOffsetTarget;
+				fDetailedRange = fDetailedRangeTarget;
+				if(OffsetYDest)
+				{
+					nOffsetY = OffsetYTarget;
+				}
+				ZoomCallback = null;
+			}
+			else
+			{
+				RequestRedraw();
+			}
+			return 1;
+		}
+		ZoomCallback = ZoomFunc;
+		RequestRedraw();
+	}
+}
+
+function RequestAnimationFrame(cb)
+{
+	if(!RedrawRequested)
+	{
+		let RedrawCallback = function(foo)
+		{
+			RedrawRequested = 0;
+			cb(foo);
+		};
+		RedrawRequested = 1;
+		requestAnimationFrame(RedrawCallback);
+	}
+}
+
+function RequestRedraw(FullRedraw)
+{
+	if(!RedrawRequested)
+	{
+		RequestAnimationFrame(Draw);
+	}
+}
+
+function UpdateFilterSearch()
+{
+	let Value = FilterInputSearch2.value;
+	if(Value != FilterInputSearchValue)
+	{
+		FilterInputSearchValue = Value;
+		let FilterSearch = CreateFilter(FilterInputSearchValue);
+		if(!FilterSearch)
+		{
+			FilterInputSearchActive2 = false;
+		}
+		else
+		{
+			FilterInputSearchActive2 = true;
+			let States = new Array();
+			States.push(S);
+			if(S2 && S2.TimerInfo)
+				States.push(S2);
+			for(let i in States)
+			{
+				let State = States[i];
+				for(let j in State.TimerInfo)
+				{
+					let TI = State.TimerInfo[j];
+					let Name = TI.name;
+					if(FilterMatch(FilterSearch, Name))
+					{
+						TI.search = CIDMatch;
+					}
+					else
+					{
+						TI.search = CIDFail;
+					}
+				}
+			}
+			for(let i = 0; i < Timeline.Names.length; ++i)
+			{
+				Timeline.SearchMatch[i] = FilterMatch(FilterSearch, Timeline.Names[i]);
+			}
+		}
+	}
+}
+
+
+function Draw()
+{
+	let ProfileDrawStart = new Date();
+
+	UpdateFilterSearch();
+	let RedrawMode = 1;
+	let RedrawAgain = 0;
+	RedrawMode = 1;
+	if(Mode == ModeDetailed)
+	{
+		if(ProfileMode == 2 || ((nHoverCSCpu >= 0 || nHoverToken != -1) && !KeyCtrlDown && !KeyShiftDown && !MouseDragButton)||(Invalidate<2 && !KeyCtrlDown && !KeyShiftDown && !MouseDragButton))
+		{
+			RedrawMode = 1;
+			RedrawAgain = 1;
+		}
+	}
+	else
+	{
+		if(Invalidate < 1)
+		{
+			RedrawMode = 1;
+		}
+	}
+
+	if(!Initialized)
+	{
+		return;
+	}
+	if(InsideDraw)
+	{
+		debugger;
+		return;
+	}
+	let ZoomActive = 0;
+	if(ZoomCallback)
+	{
+		ZoomActive = ZoomCallback();
+	}
+	InsideDraw = 1;
+	if(ProfileMode)
+	{
+		ProfileModeClear();
+		ProfileEnter("Total");
+	}
+
+	if(ZoomActive)
+	{
+		DrawDetailed(true);
+	}
+	else if(RedrawMode == 1)
+	{
+		if(Mode == ModeTimers || Mode == ModeTimers_Threads || Mode == ModeTimers_Groups)
+		{
+			DrawBarView();
+			DrawHoverToolTip();
+		}
+		else if(Mode == ModeDetailed)
+		{
+			DrawDetailed(false);
+			DrawHoverToolTip();
+		}
+		else if(Mode == ModeCounters)
+		{
+			DrawCounterView();
+			DrawHoverToolTip();
+		}
+	}
+	DrawDetailedFrameHistory();
+	DrawMenu();
+
+
+	if(ProfileMode)
+	{
+		ProfileLeave();
+		ProfileModeDraw(CanvasDetailedView);
+	}
+
+	InsideDraw = 0;
+	{
+		let ProfileDrawEnd = new Date();
+		let DrawTime = ProfileDrawEnd - ProfileDrawStart;
+		let Delta = ProfileDrawStart - ProfileDrawStartLast;
+		let Draw2Draw = ProfileDrawStart - ProfileDrawEndLast;
+
+		if(ProfileMode != 3)
+		{
+			PushIntoArray(ProfileDrawTime, DrawTime);
+			PushIntoArray(ProfileDeltaTime, Delta);
+			PushIntoArray(ProfileDraw2Draw, Draw2Draw);
+		}
+		ProfileDrawStartLast = ProfileDrawStart;
+		ProfileDrawEndLast = ProfileDrawEnd;
+	}
+
+	if(RedrawAgain)
+	{
+		RequestRedraw();
+	}
+	MouseReleased = false;
+}
+
+function MoveFilterInputMenuDiv(x, y, w)
+{
+	if(FilterInputMenuDivPos.x != x || FilterInputMenuDivPos.y != y || FilterInputMenuDivPos.w != w)
+	{
+		FilterInputMenuDivPos.x = x;
+		FilterInputMenuDivPos.y = y;
+		FilterInputMenuDivPos.w = w;
+		FilterInputMenuDiv.style['left'] = x + 'px';
+		FilterInputMenuDiv.style['top'] = y + 'px';
+		FilterInputMenu.style['width'] = w + 'px';
+	}
+}
+function MoveFilterInputDiv(x, y, w)
+{
+	if(FilterInputDivPos.x != x || FilterInputDivPos.y != y || FilterInputDivPos.w != w)
+	{
+		FilterInputDivPos.x = x;
+		FilterInputDivPos.y = y;
+		FilterInputDivPos.w = w;
+		FilterInputDiv.style['left'] = x + 'px';
+		FilterInputDiv.style['top'] = (y + (CanvasHistory.height / DPR)) + 'px';
+		FilterInput.style['width'] = w + 'px';
+	}
+}
+
+
+function MakeMenuItem(name, f, visible)
+{
+	var Item = {};
+	Item.name = name;
+	Item.f = f;
+	Item.w = name.length;
+	Item.x = 0;
+	Item.y = 0;
+	Item.visible = visible;
+	return Item;
+}
+function EnableMenu(m)
+{
+	if(m != SubMenuActive)
+	{
+		if(SubMenuActive == SubMenuThreads)
+		{
+			FilterInputMenuThreadsValue = FilterInputMenu.value;
+		}
+		else if(SubMenuActive == SubMenuGroups)
+		{
+			FilterInputMenuGroupsValue = FilterInputMenu.value;
+		}
+
+		SubMenuActive = m;
+		SubMenuTimeout = new Date();
+
+		if(SubMenuActive == SubMenuThreads)
+		{
+			FilterInputMenu.value = FilterInputMenuThreadsValue;
+			FilterInputMenu.focus();
+		}
+		else if(SubMenuActive == SubMenuGroups)
+		{
+			FilterInputMenu.value = FilterInputMenuGroupsValue;
+			FilterInputMenu.focus();
+		}
+		FilterInputMenuValueLast = FilterInput.value;
+		// if(m == SubMenuHelp)
+		{
+			let info = document.getElementById("divFrameInfo");
+			info.display = 'inline';
+		}
+	}
+	if(m == -1)
+	{
+		SubMenuTimeout = 0;
+	}
+	if(SubMenuActive == SubMenuGroups || SubMenuActive == SubMenuThreads)
+	{
+		FilterInputMenuDiv.style['display'] = 'inline';
+		FilterInputMenu.focus();
+	}
+	else
+	{
+		FilterInputMenuDiv.style['display'] = 'none';
+	}
+}
+function InitMenu()
+{
+	MenuItems = [];
+	MenuItems.push(MakeMenuItem("?", function(){EnableMenu(SubMenuHelp); } ));
+	MenuItems.push(MakeMenuItem("Mode", function(){EnableMenu(SubMenuMode); } ));
+	MenuItems.push(MakeMenuItem("Reference", function(){EnableMenu(SubMenuReference); } ));
+	MenuItems.push(MakeMenuItem("Target", function(){EnableMenu(SubMenuTarget); } ));
+	MenuItems.push(MakeMenuItem("Threads", function(){ EnableMenu(SubMenuThreads); }, function(){ return Mode != ModeCounters && Mode != ModeTimers_Groups; }));
+	MenuItems.push(MakeMenuItem("Groups", function(){ EnableMenu(SubMenuGroups); }, function() { return Mode != ModeDetailed && Mode != ModeCounters && Mode != ModeTimers_Threads; } ));
+	MenuItems.push(MakeMenuItem("Columns", function(){ EnableMenu(SubMenuColumns); }, function(){return Mode == ModeTimers; }  ));
+	MenuItems.push(MakeMenuItem("Options", function(){ EnableMenu(SubMenuOptions); } ));
+	MenuItems.push(MakeMenuItem("Compare", function(){ EnableMenu(SubMenuCompare); } ));
+}
+function DrawTopMenu(context)
+{
+	MenuItems[SubMenuMode].name = "Mode[" + ModeItems[Mode] + "]";
+	let X = 2;
+	let Y = 0;
+	let MouseInY = GlobalMouseY < BoxHeight;
+	for(let i = 0; i < MenuItems.length; ++i)
+	{
+		let Item = MenuItems[i];
+		if(Item.visible == null || Item.visible())
+		{
+			let w = context.measureText(Item.name).width + 4;
+			let MouseIn = MouseInY && GlobalMouseX >= X && GlobalMouseX < X + w;
+			let color = MouseIn ? nBackColors[1] : "black";
+			Item.x = X;
+			Item.y = Y + BoxHeight;
+			if(MouseIn)
+			{
+				context.fillStyle = 'white';
+				context.fillRect(X-2, Y, w+4, BoxHeight);
+				// Enable
+				EnableMenu(i);
+			}
+			context.fillStyle = color;
+			context.fillRect(X, Y, w, BoxHeight);
+			context.fillStyle = "white";
+			context.fillText(Item.name, X+2, Y+BoxHeight-FontAscent);
+			if(MouseIn && MouseReleased)
+			{
+				Item.f();
+			}
+			X += w + 6;
+		}
+	}
+
+	return WindowRect(0, 0, X, BoxHeight);
+}
+function MenuSize(w)
+{
+	return WindowRect(nWidth / 2 - w / 2, HistoryHeight + 50,w, nHeight);
+}
+function MouseInRect(Rect)
+{
+	return MouseInside(Rect.x, Rect.y, Rect.w, Rect.h);
+}
+function MouseInside(X, Y, W, H)
+{
+	return GlobalMouseX >= X && GlobalMouseX <= X + W && GlobalMouseY >= Y && GlobalMouseY <= Y + H;
+}
+
+function DrawMenuGeneric(Elements, Active, OnClick, x, y, Elements2)
+{
+	let context = CanvasMenu.getContext('2d');
+	let nColorIndex = 0;
+	if(Elements2 && Elements2.length != Elements.length)
+	{
+		Elements2 = null;
+	}
+	let h = FontHeight * Elements.length;
+	let w = 20;
+	let w2 = 0;
+	for(let i = 0; i < Elements.length; ++i)
+	{
+		let m = context.measureText(Elements[i]).width;
+		w = w > m ? w : m;
+		if(Elements2)
+		{
+			m = context.measureText(Elements2[i]).width;
+			w2 = w2 > m ? w2 : m;
+		}
+	}
+	w += 10 + w2;
+	let SizeInfo = MenuSize(w);
+	SizeInfo.x = x;
+	SizeInfo.y = y;
+	let X = x;
+	let Y = y;
+
+
+	for(let i = 0; i < Elements.length; ++i)
+	{
+		let Selected = Active(i);
+		let Name = Elements[i];
+		let bMouseIn = GlobalMouseY >= Y && GlobalMouseY < Y + BoxHeight;
+		let bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+		let TextY = Y+BoxHeight-FontAscent;
+		context.fillStyle = Selected?'white':bgcolor;
+		context.fillRect(X-2, Y, w+4, BoxHeight);
+		context.fillStyle = bgcolor;
+		context.fillRect(X, Y, w, BoxHeight);
+		context.fillStyle = 'white';
+		context.fillText(Name, X + 2, TextY);
+		if(Elements2)
+		{
+			context.textAlign = "right";
+			context.fillText(Elements2[i], X + w , TextY);
+			context.textAlign = "left";
+		}
+		context.fillText(Name, X + 2, TextY);
+		if(bMouseIn && MouseReleased)
+		{
+			OnClick(i, Name);
+		}
+		Y += BoxHeight;
+		nColorIndex = 1-nColorIndex;
+	}
+	SizeInfo.h = Y - SizeInfo.y;
+	return SizeInfo;
+}
+
+function DrawMenuReference()
+{
+	let Names = [];
+	let ActiveIdx = 0;
+	for(let i in ReferenceTimes)
+	{
+		let v = ReferenceTimes[i];
+		if(v < 0)
+		{
+			Names.push(ReferenceTimeAutoString);
+		}
+		else
+		{
+			if(ReferenceTime == ReferenceTimes[i])
+			{
+				ActiveIdx = i;
+			}
+			Names.push(v + "ms");
+		}
+	}
+	let Click = function(idx, name)
+	{
+		SetReferenceTime(Names[idx]);
+		RequestRedraw();
+		Invalidate = 0;
+
+	};
+	let x = MenuItems[SubMenuReference].x;
+	let y = MenuItems[SubMenuReference].y;
+	let Active = function(Idx) { return ActiveIdx == Idx; };
+	return DrawMenuGeneric(Names, Active, Click, x, y, null);
+}
+function DrawMenuTarget()
+{
+	let Names = [];
+	for(let i in TargetTimes)
+	{
+		Names.push(TargetTimes[i] + "ms");
+	}
+	let Click = function(idx, name)
+	{
+		SetTargetTime(Names[idx]);
+		RequestRedraw();
+		Invalidate = 0;
+
+	};
+	let x = MenuItems[SubMenuTarget].x;
+	let y = MenuItems[SubMenuTarget].y;
+	let Active = function(Idx) { return TargetTimes[Idx] == TargetTime; };
+	return DrawMenuGeneric(Names, Active, Click, x, y, null);
+}
+
+function DrawMenuMode()
+{
+	let Click = function(idx, name)
+	{
+		SetMode(idx,false);
+		MenuItems[SubMenuMode].name = "Mode[" + ModeItems[idx] + "]";
+		RequestRedraw();
+		Invalidate = 0;
+
+	};
+	let x = MenuItems[SubMenuMode].x;
+	let y = MenuItems[SubMenuMode].y;
+	let Active = function(Idx) { return Idx == Mode; };
+	return DrawMenuGeneric(ModeItems, Active, Click, x, y, null);
+}
+function DrawMenuOptions()
+{
+	let DrawMode = DrawDetailedNewDraw ? "DrawMode[New]":"DrawMode[Old]";
+	let OptionNames =["Context Switch", "MergeDisable", "LodDisable", "Flame Mode", "Compare Reverse", "Help",DrawMode];
+	let Click = function(idx, name)
+	{
+		switch(idx)
+		{
+			case 0: ToggleContextSwitch(); break;
+			case 1: ToggleDisableMerge(); break;
+			case 2: ToggleDisableLod(); break;
+			case 3: ToggleDetailedFlameMode(); break;
+			case 4: ToggleDetailedSecondReverse(); break;
+			case 5: ShowHelp(1,1); break;
+			case 6: ToggleDetailedNewDraw(); break;
+		}
+		RequestRedraw();
+		Invalidate = 0;
+
+	};
+	let x = MenuItems[SubMenuOptions].x;
+	let y = MenuItems[SubMenuOptions].y;
+	let Active = function(Idx) { return false; };
+	return DrawMenuGeneric(OptionNames, Active, Click, x, y, null);
+}
+
+function DrawMenuColumns()
+{
+	let Click = function(idx, name)
+	{
+		ToggleColumn(idx);
+
+	};
+	let x = MenuItems[SubMenuColumns].x;
+	let y = MenuItems[SubMenuColumns].y;
+	let Active = function(Idx) { return ColumnsEnabled[Idx]; };
+	return DrawMenuGeneric(ColumnNames, Active, Click, x, y, null);
+
+}
+
+function GroupMenuSize()
+{
+	return MenuSize(300);
+}
+
+function ThreadMenuSize()
+{
+	return MenuSize(S.ThreadNameWidth + S.ThreadCategoryWidth + 10);
+}
+
+function DrawMenuSeparator(context, X, Y, W, Height)
+{
+	context.fillStyle = 'grey';
+	context.fillRect(X-2, Y, W+2, Height);
+}
+
+function DrawMultiMenu(context, X, Y, W, Elements, Callbacks)
+{
+	let A = Array();
+	let wtemp = W;
+	let bMouseIn = GlobalMouseY >= Y && GlobalMouseY < Y + BoxHeight;
+
+	for(let i = 0; i < Elements.length; ++i)
+	{
+		let wElement = context.measureText(Elements[i]).width;
+		if(i > 0)
+		{
+			wElement += 15;
+			wtemp -= wElement;
+		}
+		A.push(wElement);
+	}
+	A[0] = Math.max(wtemp, 0);
+
+	context.fillStyle = nBackColors[0];
+	context.fillRect(X-2, Y, W, BoxHeight);
+	let XOff = 0;
+	let TextY = Y+BoxHeight-FontAscent;
+	for(let i = 0; i < Elements.length; ++i)
+	{
+		let width = A[i];
+		let Inside = i != 0 && bMouseIn && GlobalMouseX > XOff + X && GlobalMouseX <= XOff + X + width;
+		context.fillStyle = Inside ? nBackColorOffset : nBackColors[0];
+		context.fillRect(X+XOff, Y, width, BoxHeight);
+		context.fillStyle = 'white';
+		context.textAlign = 'center';
+		context.fillText(Elements[i], X+XOff + width * 0.5, TextY);
+		XOff += width;
+		if(Inside && MouseReleased && Callbacks[i])
+		{
+			Callbacks[i]();
+		}
+	}
+	context.textAlign = 'left';
+}
+
+function DrawMenuThreads()
+{
+	if(FilterInputMenuValueLast != FilterInputMenu.value)
+	{
+		nOffsetMenuThreads = 0;
+	}
+	FilterInputMenuValueLast = FilterInputMenu.value;
+	let FilterArray = CreateFilter(FilterInputMenu.value);
+	let context = CanvasMenu.getContext('2d');
+	let nColorIndex = 0;
+	let SizeInfo = ThreadMenuSize();
+	SizeInfo.x = MenuItems[SubMenuThreads].x;
+	SizeInfo.y = MenuItems[SubMenuThreads].y;
+	let Y = SizeInfo.y;
+	let Width = SizeInfo.w;
+	let Selection = null;
+	let X = SizeInfo.x;
+	MoveFilterInputMenuDiv(SizeInfo.x, SizeInfo.y, SizeInfo.w);
+	Y += 35;
+
+	let bMouseIn = GlobalMouseY >= Y && GlobalMouseY < Y + BoxHeight;
+	let bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+	let TextY = Y+BoxHeight-FontAscent;
+	let YClear = Y;
+	let TextYClear = TextY;
+	let YStart = Y;
+	let MatchCount = 0;
+	let MouseTaken = bMouseIn;
+
+	Y += (BoxHeight) * 5 + 3 * 2;
+	nColorIndex = 1-nColorIndex;
+
+	Y -= nOffsetMenuThreads;
+	let CPULogs = [];
+	let GPULogs = [];
+	for(let i = 0; i < S.ThreadNames.length; ++i)
+	{
+		let Name = S.ThreadNames[i];
+		if(S.ISGPU[i])
+			GPULogs.push(Name);
+		else
+			CPULogs.push(Name);
+		let ParentName = "ThreadCategory";
+		if(FilterMatch(FilterArray, ParentName + " " + Name))
+		{
+			if(Y > YStart)
+			{
+				let ParentColor = 'white';
+				let E =	IsThreadActive(Name);
+				let AutoHidden = S.ThreadLogAutoHidden[i];
+				bMouseIn = GlobalMouseY >= Y && GlobalMouseY < Y + BoxHeight && !MouseTaken;
+				bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+				TextY = Y+BoxHeight-FontAscent;
+				context.fillStyle = E ? (AutoHidden?'orange':'white') :bgcolor;
+				context.fillRect(X-2, Y, Width+4, BoxHeight);
+				context.fillStyle = bgcolor;
+				context.fillRect(X, Y, Width, BoxHeight);
+				context.fillStyle = ParentColor;
+				context.fillText(ParentName, X + 2, TextY);
+				context.fillStyle = S.ThreadColors[i].color;
+				context.textAlign = 'right';
+				context.fillText(Name, X + Width - 2, TextY);
+				context.textAlign = 'left';
+				if(bMouseIn && MouseReleased)
+				{
+					ToggleThread(Name);
+					RequestRedraw();
+				}
+			}
+			Y += BoxHeight;
+			nColorIndex = 1-nColorIndex;
+			MatchCount++;
+		}
+	}
+	let TextAll = "All [" + S.ThreadNames.length + "]";
+	let TextFiltered = "Filtered [" + MatchCount +"]";
+	let TextCPU = "CPU [" + CPULogs.length + "]";
+	let TextGPU = "GPU [" + GPULogs.length + "]";
+
+	let ElementsAll = [TextAll, "Off", "Flip", "On"];
+	let ElementsFiltered = [TextFiltered, "Off", "Flip", "On"];
+	let ElementsCPU = [TextCPU, "Off", "Flip", "On"];
+	let ElementsGPU = [TextGPU, "Off", "Flip", "On"];
+	
+	let CallbacksAll = [null,
+		function(){ ToggleThread(0, 1, 0, 0); },
+		function(){ ToggleThread(0, 1, 0, 1); },
+		function(){ ToggleThread(0, 1, 0, 2); },
+	];
+
+	let CallbacksCPU = [null,
+		function(){ ToggleThread(0, 0, CPULogs, 0); },
+		function(){ ToggleThread(0, 0, CPULogs, 1); },
+		function(){ ToggleThread(0, 0, CPULogs, 2); },
+	];
+	let CallbacksGPU = [null,
+		function(){ ToggleThread(0, 0, GPULogs, 0); },
+		function(){ ToggleThread(0, 0, GPULogs, 1); },
+		function(){ ToggleThread(0, 0, GPULogs, 2); },
+	];
+
+
+	let CreateFilteredArray = function()
+	{
+		if(!FilterArray) return S.ThreadNames;
+		let A = [];
+		for(let i = 0; i < S.ThreadNames.length; ++i)
+		{
+			let Name = S.ThreadNames[i];
+			let ParentName = "ThreadCategory";
+			if(FilterMatch(FilterArray, ParentName + " " + Name))
+			{
+				A.push(Name);
+			}
+		}
+		return A;
+	};
+	let CallbacksFiltered = [null,
+		function(){let F = CreateFilteredArray(); ToggleThread(0, 0, F, 0); },
+		function(){let F = CreateFilteredArray(); ToggleThread(0, 0, F, 1); },
+		function(){let F = CreateFilteredArray(); ToggleThread(0, 0, F, 2); },
+	];
+
+
+	let ElementsOptions = ["Options", "Hide mode:" + (HideMode==HideModeCollapsed ? "Collapsed" : "Invisible"), "AutoHide Empty:" + (ThreadLogAutoHide ? "On": "Off")];
+	let CallbacksOptions = [null,
+	function(){
+		HideMode = HideMode == HideModeCollapsed ? HideModeFullyHidden : HideModeCollapsed;
+		RequestRedraw();
+		Invalidate = 0;
+	},
+	function(){
+		ThreadLogAutoHide = ThreadLogAutoHide ? 0 : 1; UpdateThreadLogAutoHide()
+		RequestRedraw();
+		Invalidate = 0;
+	}
+	];
+
+	DrawMultiMenu(context, X, YClear, Width, ElementsOptions, CallbacksOptions);
+	YClear += BoxHeight;
+	DrawMenuSeparator(context, X, YClear, Width, 2);
+	YClear += 2;
+	DrawMultiMenu(context, X, YClear, Width, ElementsAll, CallbacksAll);
+	YClear += BoxHeight;
+	DrawMultiMenu(context, X, YClear, Width, ElementsFiltered, CallbacksFiltered);
+	YClear += BoxHeight;
+	DrawMenuSeparator(context, X, YClear, Width, 2);
+	YClear += 2;
+	DrawMultiMenu(context, X, YClear, Width, ElementsGPU, CallbacksGPU);
+	YClear += BoxHeight;
+	DrawMultiMenu(context, X, YClear, Width, ElementsCPU, CallbacksCPU);
+	YClear += BoxHeight;
+	DrawMenuSeparator(context, X, YClear, Width, 2);
+	YClear += 2;
+
+	SizeInfo.h = Y-SizeInfo.y;
+	return SizeInfo;
+}
+
+function DrawMenuGroups()
+{
+	if(FilterInputMenuValueLast != FilterInputMenu.value)
+	{
+		nOffsetMenuThreads = 0;
+	}
+	FilterInputMenuValueLast = FilterInputMenu.value;
+	let FilterArray = CreateFilter(FilterInputMenu.value);
+	let context = CanvasMenu.getContext('2d');
+	let nColorIndex = 0;
+	let SizeInfo = ThreadMenuSize();
+	SizeInfo.x = MenuItems[SubMenuGroups].x;
+	SizeInfo.y = MenuItems[SubMenuGroups].y;
+	let Y = SizeInfo.y;
+	let Width = SizeInfo.w;
+	let Selection = null;
+	let X = SizeInfo.x;
+	MoveFilterInputMenuDiv(SizeInfo.x, SizeInfo.y, SizeInfo.w);
+	Y += 35;
+
+	let bMouseIn = GlobalMouseY >= Y && GlobalMouseY < Y + BoxHeight;
+	let bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+	let TextY = Y+BoxHeight-FontAscent;
+	let YClear = Y;
+	let TextYClear = TextY;
+	let YStart = Y;
+	let MatchCount = 0;
+	let MouseTaken = bMouseIn;
+
+	Y += BoxHeight * 2;
+	nColorIndex = 1-nColorIndex;
+
+	Y -= nOffsetMenuThreads;
+
+
+
+	for(var i = 0; i < S.GroupInfo.length; ++i)
+	{
+		let Name = S.GroupInfo[i].name;
+		let ParentName = S.CategoryInfo[S.GroupInfo[i].category];
+		let Color = g_Colors[ S.GroupInfo[i].cid ];
+		if(FilterMatch(FilterArray, ParentName + " " + Name))
+		{
+			if(Y > YStart)
+			{
+				var ParentColor = 'white';
+				let E =	!GroupsDisabled[Name];
+				bMouseIn = GlobalMouseY >= Y && GlobalMouseY < Y + BoxHeight && !MouseTaken;
+				bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+				TextY = Y+BoxHeight-FontAscent;
+				context.fillStyle = E ? 'white' :bgcolor;
+				context.fillRect(X-2, Y, Width+4, BoxHeight);
+				context.fillStyle = bgcolor;
+				context.fillRect(X, Y, Width, BoxHeight);
+				context.fillStyle = ParentColor;
+				context.fillText(ParentName, X + 2, TextY);
+				context.fillStyle = Color;
+				context.textAlign = 'right';
+				context.fillText(Name, X + Width - 2, TextY);
+				context.textAlign = 'left';
+				if(bMouseIn && MouseReleased)
+				{
+					ToggleGroup(Name);
+					RequestRedraw();
+				}
+			}
+			Y += BoxHeight;
+			nColorIndex = 1-nColorIndex;
+			MatchCount++;
+		}
+	}
+	let TextAll = "All [" + S.GroupInfo.length + "]";
+	let TextFiltered = "Filtered [" + MatchCount +"]";
+
+
+
+	let ElementsAll = [TextAll, "Off", "Flip", "On"];
+	let CallbacksAll = [null,
+		function(){ ToggleGroup(0, 1, 0, 0); },
+		function(){ ToggleGroup(0, 1, 0, 1); },
+		function(){ ToggleGroup(0, 1, 0, 2); },
+	];
+	let ElementsFiltered = [TextFiltered, "Off", "Flip", "On"];
+	let CreateFilteredArray = function()
+	{
+		let A = [];
+		for(let i = 0; i < S.GroupInfo.length; ++i)
+		{
+			let Name = S.GroupInfo[i].name;
+			let ParentName = S.CategoryInfo[S.GroupInfo[i].category];
+			if(FilterMatch(FilterArray, ParentName + " " + Name))
+			{
+				A.push(Name);
+			}
+		}
+		return A;
+	};
+	let CallbacksFiltered = [null,
+		function(){let F = CreateFilteredArray(); ToggleGroup(0, 0, F, 0); },
+		function(){let F = CreateFilteredArray(); ToggleGroup(0, 0, F, 1); },
+		function(){let F = CreateFilteredArray(); ToggleGroup(0, 0, F, 2); },
+	];
+
+
+	DrawMultiMenu(context, X, YClear, Width, ElementsAll, CallbacksAll);
+	DrawMultiMenu(context, X, YClear+BoxHeight, Width, ElementsFiltered, CallbacksFiltered);
+
+	SizeInfo.h = Y-SizeInfo.y;
+	return SizeInfo;
+
+
+}
+
+function DrawMenu()
+{
+	MenuRedraw = 0;
+
+	var context = CanvasMenu.getContext('2d');
+	context.clearRect(0, 0, CanvasMenu.width, CanvasMenu.height);
+
+	var nColorIndex = 0;
+	var Y = 50;
+	var Width = 300;
+	var Selection = null;
+
+	ProfileEnter("DrawMenu");
+	let MenuRect = DrawTopMenu(context);
+	if(SubMenuActive != -1)
+	{
+		MouseMoveTime = new Date();
+	}
+	if(SubMenuActive == SubMenuHelp)
+	{
+		if(MouseReleased)
+		{
+			ToggleDebugMode();
+		}
+	}
+	if(SubMenuActive == SubMenuMode)
+	{
+		MenuRect = DrawMenuMode();
+	}
+	else if(SubMenuActive == SubMenuReference)
+	{
+		MenuRect = DrawMenuReference();
+	}
+	else if(SubMenuActive == SubMenuTarget)
+	{
+		MenuRect = DrawMenuTarget();
+	}
+	else if(SubMenuActive == SubMenuThreads)
+	{
+		MenuRect = DrawMenuThreads();
+	}
+	else if(SubMenuActive == SubMenuGroups)
+	{
+		MenuRect = DrawMenuGroups();
+	}
+	else if(SubMenuActive == SubMenuOptions)
+	{
+		MenuRect = DrawMenuOptions();
+	}
+	else if(SubMenuActive == SubMenuCompare)
+	{
+		if(MouseReleased)
+		{
+			ComparePrompt();
+		}
+	}
+	else if(SubMenuActive == SubMenuColumns)
+	{
+		MenuRect = DrawMenuColumns();
+	}
+	var Grow = 10;
+	MenuRect.x -= Grow;
+	MenuRect.y -= Grow;
+	MenuRect.h += 2*Grow;
+	MenuRect.w += 2*Grow;
+	var MouseMoved = GlobalMouseX != SubMenuMouseX || GlobalMouseY != SubMenuMouseY;
+
+	if(MouseInRect(MenuRect) || !MouseMoved)
+	{
+		SubMenuTimeout = new Date();
+		SubMenuMouseX = GlobalMouseX;
+		SubMenuMouseY = GlobalMouseY;
+	}
+	else
+	{
+		var Time = new Date() - SubMenuTimeout;
+		var Dest = SubMenuTimeoutBase * 1000;
+		if(Time > Dest)
+		{
+			EnableMenu(-1);
+		}
+	}
+	if(0)//debugging of menu extents. dont delete
+	{
+		context.strokeStyle = 'red';
+		context.beginPath();
+		context.moveTo(MenuRect.x,MenuRect.y);
+		context.lineTo(MenuRect.x + MenuRect.w,MenuRect.y);
+		context.lineTo(MenuRect.x + MenuRect.w,MenuRect.y+MenuRect.h);
+		context.lineTo(MenuRect.x,MenuRect.y+MenuRect.h);
+		context.lineTo(MenuRect.x,MenuRect.y);
+		context.stroke();
+	}	// SpinnerDraw(SpinnerShow(), context, SpinnerCorner, 0, nHeight-20,  20, 20);
+	ProfileLeave();
+}
+
+
+function ZoomGraph(nZoom)
+{
+	var fOldRange = fDetailedRange;
+	if(nZoom>0)
+	{
+		fDetailedRange *= Math.pow(nModDown ? 1.40 : 1.03, nZoom);
+	}
+	else
+	{
+		var fNewDetailedRange = fDetailedRange / Math.pow((nModDown ? 1.40 : 1.03), -nZoom);
+		if(fNewDetailedRange < 0.0001) //100ns
+			fNewDetailedRange = 0.0001;
+		fDetailedRange = fNewDetailedRange;
+	}
+
+	var fDiff = fOldRange - fDetailedRange;
+	var fMousePrc = DetailedViewMouseX / nWidth;
+	if(fMousePrc < 0)
+	{
+		fMousePrc = 0;
+	}
+	fDetailedOffset += fDiff * fMousePrc;
+
+}
+
+function MeasureFont()
+{
+	var context = CanvasDetailedView.getContext('2d');
+	context.font = Font;
+	FontWidth = context.measureText('W').width;
+
+}
+function ResizeCanvas()
+{
+	nWidth = window.innerWidth;
+	nHeight = window.innerHeight - CanvasHistory.height-2;
+	DPR = window.devicePixelRatio;
+
+	if(DPR)
+	{
+		CanvasDetailedView.style.width = nWidth + 'px';
+		CanvasDetailedView.style.height = nHeight + 'px';
+		CanvasDetailedView.width = nWidth * DPR;
+		CanvasDetailedView.height = nHeight * DPR;
+		CanvasHistory.style.width = window.innerWidth + 'px';
+		CanvasHistory.style.height = 70 + 'px';
+		CanvasHistory.width = window.innerWidth * DPR;
+		CanvasHistory.height = 70 * DPR;
+		CanvasMenu.style.width = window.innerWidth + 'px';
+		CanvasMenu.style.height = window.innerHeight + 'px';
+		CanvasMenu.width = window.innerWidth * DPR;
+		CanvasMenu.height = window.innerHeight * DPR;
+		CanvasHistory.getContext('2d').scale(DPR,DPR);
+		CanvasDetailedView.getContext('2d').scale(DPR,DPR);
+		CanvasMenu.getContext('2d').scale(DPR,DPR);
+
+		CanvasDetailedOffscreen.style.width = nWidth + 'px';
+		CanvasDetailedOffscreen.style.height = nHeight + 'px';
+		CanvasDetailedOffscreen.width = nWidth * DPR;
+		CanvasDetailedOffscreen.height = nHeight * DPR;
+		CanvasDetailedOffscreen.getContext('2d').scale(DPR,DPR);
+
+	}
+	else
+	{
+		DPR = 1;
+		CanvasDetailedView.width = nWidth;
+		CanvasDetailedView.height = nHeight;
+		CanvasDetailedOffscreen.width = nWidth;
+		CanvasDetailedOffscreen.height = nHeight;
+
+		CanvasMenu.width = window.innerWidth;
+		CanvasMenu.height = window.innerHeight;
+		CanvasHistory.width = window.innerWidth;
+	}
+	RequestRedraw();
+}
+
+
+var MouseDragOff = 0;
+var MouseDragDown = 1;
+var MouseDragUp = 2;
+var MouseDragMove = 3;
+var MouseDragState = MouseDragOff;
+var MouseDragTarget = 0;
+var MouseDragButton = 0;
+var MouseDragButtonNext = 0;
+var MouseDragKeyShift = 0;
+var MouseDragKeyCtrl = 0;
+var MouseDragKeyAlt = 0;
+var MouseDragX = 0;
+var MouseDragY = 0;
+var MouseDragXLast = 0;
+var MouseDragYLast = 0;
+var MouseDragXStart = 0;
+var MouseDragYStart = 0;
+
+function clamp(number, min, max)
+{
+  return Math.max(min, Math.min(number, max));
+}
+
+function MouseDragPan()
+{
+	return (MouseDragButton == 1 && !MouseDragKeyCtrl) || MouseDragKeyShift || MouseDragKeyAlt;
+}
+function MouseDragSelectRange()
+{
+	return MouseDragState == MouseDragMove && (MouseDragButton == 3 || (MouseDragKeyShift && MouseDragKeyCtrl));
+}
+function MouseHandleDrag()
+{
+	if(MouseDragTarget == CanvasDetailedView)
+	{
+		if(Mode == ModeDetailed)
+		{
+
+			if(FilterSearchActive)
+			{
+				if(MouseDragKeyShift || MouseDragButton == 1)
+				{
+					var Y = MouseDragY - MouseDragYLast;
+					nOffsetFilterSearch -= Y;
+					if(nOffsetFilterSearch < 0)
+					{
+						nOffsetFilterSearch = 0;
+					}
+				}
+			}
+			else
+			{
+				if(MouseDragSelectRange())
+				{
+					var xStart = MouseDragXStart;
+					var xEnd = MouseDragX;
+					if(xStart > xEnd)
+					{
+						var Temp = xStart;
+						xStart = xEnd;
+						xEnd = Temp;
+					}
+					if(xEnd - xStart > 1)
+					{
+						RangeCpu.Begin = fDetailedOffset + fDetailedRange * (xStart / nWidth);
+						RangeCpu.End = fDetailedOffset + fDetailedRange * (xEnd / nWidth);
+						RangeSelect.Begin = fDetailedOffset + fDetailedRange * (xStart / nWidth);
+						RangeSelect.End = fDetailedOffset + fDetailedRange * (xEnd / nWidth);
+						RangeSelect.Thread = -1;
+						RangeSelect.Index = -1;
+					}
+				}
+				else if(MouseDragPan())
+				{
+					var X = MouseDragX - MouseDragXLast;
+					var Y = MouseDragY - MouseDragYLast;
+					if(X)
+					{
+						if(MouseDragKeyAlt)
+						{
+							fDetailedOffsetSecond += -X * fDetailedRange / nWidth;
+						}
+						else
+						{
+							fDetailedOffset += -X * fDetailedRange / nWidth;
+						}
+					}
+					if(!MouseDragKeyAlt)
+					{
+						nOffsetY -= Y;
+					}
+					if(nOffsetY < 0)
+					{
+						nOffsetY = 0;
+					}
+				}
+				else if(MouseDragKeyCtrl)
+				{
+					if(MouseDragY != MouseDragYLast)
+					{
+						ZoomGraph(MouseDragY - MouseDragYLast);
+					}
+				}
+			}
+		}
+		else if(Mode == ModeTimers || Mode == ModeTimers_Threads || Mode == ModeTimers_Groups)
+		{
+			if(MouseDragKeyShift || MouseDragButton == 1)
+			{
+				var X = MouseDragX - MouseDragXLast;
+				var Y = MouseDragY - MouseDragYLast;
+				nOffsetBarsY -= Y;
+				nOffsetBarsX -= X;
+				if(nOffsetBarsY < 0)
+				{
+					nOffsetBarsY = 0;
+				}
+				if(nOffsetBarsX < 0)
+				{
+					nOffsetBarsX = 0;
+				}
+			}
+		}
+		else if(Mode == ModeCounters)
+		{
+			if(MouseDragKeyShift || MouseDragButton == 1)
+			{
+				var Y = MouseDragY - MouseDragYLast;
+				nOffsetCountersY -= Y;
+				if(nOffsetCountersY < 0)
+				{
+					nOffsetCountersY = 0;
+				}
+			}
+		}
+
+	}
+	else if(MouseDragTarget == CanvasHistory)
+	{
+		function HistoryFrameTime(x)
+		{
+			var NumFrames = S.Frames.length;
+			var fBarWidth = nWidth / NumFrames;
+			var Index = clamp(Math.floor(NumFrames * x / nWidth), 0, NumFrames-1);
+			var Lerp = clamp((x/fBarWidth - Index) , 0, 1);
+			var time = S.Frames[Index].framestart + (S.Frames[Index].frameend - S.Frames[Index].framestart) * Lerp;
+			return time;
+		}
+		if(MouseDragSelectRange())
+		{
+			RangeCpu = RangeInit();
+			RangeGpu = RangeInit();
+
+			var xStart = MouseDragXStart;
+			var xEnd = MouseDragX;
+			if(xStart > xEnd)
+			{
+				var Temp = xStart;
+				xStart = xEnd;
+				xEnd = Temp;
+			}
+			if(xEnd - xStart > 2)
+			{
+				var timestart = HistoryFrameTime(xStart);
+				var timeend = HistoryFrameTime(xEnd);
+				fDetailedOffset = timestart;
+				fDetailedRange = timeend-timestart;
+			}
+		}
+		else if(MouseDragPan())
+		{
+			var Time = HistoryFrameTime(MouseDragX);
+			fDetailedOffset = Time - fDetailedRange / 2.0;
+		}
+	}
+}
+function MouseHandleDragEnd()
+{
+	if(MouseDragTarget == CanvasDetailedView)
+	{
+
+	}
+	else if(MouseDragTarget == CanvasHistory)
+	{
+		if(!MouseDragSelectRange() && !MouseDragPan())
+		{
+			ZoomToHighlight(1);
+		}
+	}
+}
+
+function MouseHandleDragClick()
+{
+	if(MouseDragTarget == CanvasDetailedView)
+	{
+		if(Mode == ModeCounters)
+		{
+			if(nHoverCounter != -1)
+			{
+				if(S.CounterInfo[nHoverCounter].firstchild != -1)
+				{
+					S.CounterInfo[nHoverCounter].closed = !S.CounterInfo[nHoverCounter].closed;
+				}
+				else
+				{
+					S.CounterInfo[nHoverCounter].Expanded = !S.CounterInfo[nHoverCounter].Expanded;
+				}
+				Draw(1);
+			}
+		}
+		else if(Mode == ModeDetailed && FilterSearchSelection >= 0)
+		{
+			FilterInputCommit();
+		}
+		else
+		{
+			if(DetailedMouseEvent)
+			{
+				DetailedMouseEvent.E();
+			}
+			else if(!DetailedMouseOverButton)
+			{
+				ZoomToHighlight();
+			}
+		}
+	}
+	else if(MouseDragTarget == CanvasHistory)
+	{
+		if(Mode == ModeDetailed)
+		{
+			ZoomToHighlight(1);
+		}
+	}
+}
+
+function MapMouseButton(event)
+{
+	if(event.button == 1 || event.which == 1)
+	{
+		return 1;
+	}
+	else if(event.button == 3 || event.which == 3)
+	{
+		return 3;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+function MouseDragIsActive()
+{
+	return MouseDragState != MouseDragOff && MouseDragState != MouseDragDown;
+}
+function MouseDragReset()
+{
+	MouseDragState = MouseDragOff;
+	MouseDragTarget = 0;
+	MouseDragKeyShift = 0;
+	MouseDragKeyCtrl = 0;
+	MouseDragKeyAlt = 0;
+	MouseDragButton = 0;
+}
+function MouseDragKeyUp()
+{
+	if((MouseDragKeyShift && !KeyShiftDown) || (MouseDragKeyCtrl && !KeyCtrlDown) || (MouseDragKeyAlt && !KeyAltDown) || SubMenuActive != -1)
+	{
+		MouseHandleDragEnd();
+		MouseDragReset();
+	}
+}
+function MouseDrag(Source, Event)
+{
+	if(Source == MouseDragOff || (MouseDragTarget && MouseDragTarget != Event.target) || SubMenuActive != -1)
+	{
+		MouseDragReset();
+		return;
+	}
+	if(G_DEBUG)
+	{
+		debugger;
+	}
+	var LocalRect = Event.target.getBoundingClientRect();
+	MouseDragX = Event.clientX - LocalRect.left;
+	MouseDragY = Event.clientY - LocalRect.top;
+	if(MouseDragState == MouseDragMove)
+	{
+		var dx = Math.abs(MouseDragX - MouseDragXStart);
+		var dy = Math.abs(MouseDragY - MouseDragYStart);
+		if((Source == MouseDragUp && MapMouseButton(Event) == MouseDragButton) ||
+			(MouseDragKeyCtrl && !KeyCtrlDown) ||
+			(MouseDragKeyShift && !KeyShiftDown) ||
+			(MouseDragKeyAlt && !KeyAltDown))
+		{
+			MouseHandleDragEnd();
+			MouseDragReset();
+			return;
+		}
+		else
+		{
+			MouseHandleDrag();
+		}
+	}
+	else if(MouseDragState == MouseDragOff)
+	{
+		if(Source == MouseDragDown || KeyShiftDown || KeyCtrlDown|| KeyAltDown)
+		{
+			MouseDragTarget = Event.target;
+			MouseDragButton = MapMouseButton(Event);
+			MouseDragState = MouseDragDown;
+			MouseDragXStart = MouseDragX;
+			MouseDragYStart = MouseDragY;
+			MouseDragKeyCtrl = 0;
+			MouseDragKeyShift = 0;
+			MouseDragKeyAlt = 0;
+
+			if(KeyShiftDown || KeyCtrlDown || KeyAltDown)
+			{
+				MouseDragKeyAlt = KeyAltDown;
+				MouseDragKeyShift = KeyShiftDown;
+				MouseDragKeyCtrl = KeyCtrlDown;
+				MouseDragState = MouseDragMove;
+			}
+		}
+	}
+	else if(MouseDragState == MouseDragDown)
+	{
+		if(Source == MouseDragUp)
+		{
+			MouseHandleDragClick();
+			MouseDragReset();
+		}
+		else if(Source == MouseDragMove)
+		{
+			var dx = Math.abs(MouseDragX - MouseDragXStart);
+			var dy = Math.abs(MouseDragY - MouseDragYStart);
+			if(dx+dy>1)
+			{
+				MouseDragState = MouseDragMove;
+			}
+		}
+	}
+	MouseDragXLast = MouseDragX;
+	MouseDragYLast = MouseDragY;
+}
+
+function MouseMove(evt)
+{
+	evt.preventDefault();
+
+	ZoomActive = 0;
+	MouseDrag(MouseDragMove, evt);
+ 	MouseHistory = 0;
+	MouseDetailed = 0;
+	HistoryViewMouseX = HistoryViewMouseY = -1;
+	var rect = evt.target.getBoundingClientRect();
+	var x = evt.clientX - rect.left;
+	var y = evt.clientY - rect.top;
+	GlobalMouseX = evt.pageX;
+	GlobalMouseY = evt.pageY;
+	if(evt.target == CanvasDetailedView)
+	{
+		if(!MouseDragSelectRange())
+		{
+			RangeCpu = RangeInit();
+		}
+		DetailedViewMouseX = x;
+		DetailedViewMouseY = y;
+	}
+	else if(evt.target = CanvasHistory)
+	{
+		var Rect = CanvasHistory.getBoundingClientRect();
+		HistoryViewMouseX = x;
+		HistoryViewMouseY = y;
+
+		DetailedViewMouseX = -1;
+		DetailedViewMouseY = -1;
+
+	}
+	RequestRedraw();
+}
+
+function MouseSortClick()
+{
+	if(SortColumnMouseOverNext)
+	{
+		if(SortColumnMouseOverNext == SortColumnMouseOver)
+		{
+			SortColumnOrderFlip =  1 - SortColumnOrderFlip;
+		}
+		else
+		{
+			SortColumnOrderFlip = 0;
+		}
+
+		SortColumnMouseOver = SortColumnMouseOverNext;
+		SortColumnMouseOverNext = null;
+		if(SortColumnMouseOver == StrAverage)
+		{
+			SortColumn = 1;
+		}
+		else if(SortColumnMouseOver == StrMax)
+		{
+			SortColumn = 2;
+		}
+		else if(SortColumnMouseOver == StrTotal)
+		{
+			SortColumn = 3;
+		}
+		else if(SortColumnMouseOver == StrMin)
+		{
+			SortColumn = 4;
+		}
+		else if(SortColumnMouseOver == StrSpike)
+		{
+			SortColumn = 5;
+		}
+		else if(SortColumnMouseOver == StrCallAverage)
+		{
+			SortColumn = 6;
+		}
+		else if(SortColumnMouseOver == StrCount)
+		{
+			SortColumn = 7;
+		}
+		else if(SortColumnMouseOver == StrExclAverage)
+		{
+			SortColumn = 8;
+		}
+		else if(SortColumnMouseOver == StrExclMax)
+		{
+			SortColumn = 9;
+		}
+		else if(SortColumnMouseOver == StrGroup)
+		{
+			SortColumn = 0;
+		}
+		RequestRedraw();
+	}
+}
+
+function MouseButton(bPressed, evt)
+{
+	evt.preventDefault();
+	MouseReleased = !bPressed;
+	MouseDrag(bPressed ? MouseDragDown : MouseDragUp, evt);
+	if(!bPressed && SubMenuActive == -1)
+		MouseSortClick();
+	RequestRedraw();
+}
+
+function MouseOut(evt)
+{
+	MouseDrag(MouseDragOff, evt);
+	KeyCtrlDown = 0;
+	KeyShiftDown = 0;
+	KeyAltDown = 0;
+	MouseDragButton = 0;
+	nHoverToken = -1;
+	RangeCpu = RangeInit();
+}
+
+function MouseWheel(e)
+{
+    var e = window.event || e;
+    var delta = (e.wheelDelta || e.detail * (-120));
+    ZoomGraph((-4 * delta / 120.0) | 0);
+    Draw(1);
+}
+
+function ShowDetailedSearch(bShow)
+{
+	if(bShow)
+	{
+		FilterInputSearch2.style['display'] = 'block';
+	}
+	else
+	{
+		FilterInputSearch2.style['display'] = 'none';
+	}
+}
+
+function ShowFilterInput(bShow)
+{
+	if(bShow)
+	{
+		document.getElementById('filterinput').style['display'] = 'block';
+	}
+	else
+	{
+		document.getElementById('filterinput').style['display'] = 'none';
+	}
+}
+
+function SetFilterInput(group, timer)
+{
+	FilterInputGroupString = group;
+	FilterInputTimerString = timer;
+	FilterInputGroup.value = group?group:'';
+	FilterInputTimer.value = timer?timer:'';
+	FilterUpdate();
+	if(group || timer)
+	{
+		ShowFilterInput(1);
+	}
+	else
+	{
+		ShowFilterInput(0);
+	}
+
+}
+
+function ToggleFilterInput(escape)
+{
+	var ActiveElement = -1;
+	for(var i = 0; i < FilterInputArray.length; ++i)
+	{
+		if(FilterInputArray[i] == document.activeElement)
+		{
+			ActiveElement = i;
+		}
+	}
+	var OldActiveElement = ActiveElement;
+	if(ActiveElement >= 0)
+	{
+		FilterInputArray[ActiveElement].blur();
+	}
+	ActiveElement++;
+	if(!escape)
+	{
+		if(ActiveElement < FilterInputArray.length)
+		{
+			ShowFilterInput(1);
+			FilterInputArray[ActiveElement].focus();
+		}
+	}
+	else
+	{
+		if(-1 == OldActiveElement)
+		{
+			SetFilterInput();
+		}
+	}
+}
+
+function KeyUp(evt)
+{
+	//console.log("keyup ", evt.keyCode);
+	if(evt.keyCode== 84)
+	{
+		G_DEBUG = 1;
+	}
+	if(evt.keyCode == 18)
+	{
+		ToolTipFlip = 0;
+	}
+	if(!FilterSearchActive && !IgnoreInput && SubMenuActive == -1)
+	{
+		if(evt.keyCode == 112)
+		{
+			ShowHelp(1, 0);
+		}
+		if(evt.keyCode == 39)
+		{
+			MoveToNext(1);
+		}
+		if(evt.keyCode == 37)
+		{
+			MoveToNext(-1);
+		}
+		if(evt.keyCode == 90)
+		{
+			ToolTipCorner = 1-ToolTipCorner;
+		}
+		if(evt.keyCode == 187)
+		{
+			DrawDetailedFlameMode = (DrawDetailedFlameMode+1) % 3;
+			FilterSearchReset();
+		}
+		if(evt.keyCode == 189)
+		{
+			DrawDetailedCompareReverse = 1-DrawDetailedCompareReverse;
+			FilterSearchReset();
+		}
+		if(evt.keyCode == 32)
+		{
+			if(RangeSelect.Begin < RangeSelect.End)
+			{
+				ZoomToRange(RangeSelect);
+				RangeSelect = RangeInit();
+				MouseHandleDragEnd();
+			}
+		}
+		if(evt.keyCode == 192)
+		{
+			if(Mode == ModeDetailed)
+			{
+				FilterInputSearch2.focus();
+			}
+			else if(Mode == ModeTimers || Mode == ModeTimers_Threads || Mode == ModeTimers_Groups)
+			{
+				ToggleFilterInput(0);
+				evt.preventDefault();
+			}
+		}
+		if(evt.keyCode == 9)
+		{
+			evt.preventDefault();
+			if(Mode == ModeDetailed)
+			{
+				var Token = nHoverToken;
+				if(Token == -1 && RangeValid(RangeSelect) && RangeSelect.Index >= 0)
+				{
+					Token = RangeSelect.Index;
+				}
+				if(Token != -1 && Token < S.TimerInfo.length)
+				{
+					var start = S.TimerInfo[Token].worststart;
+					var end = S.TimerInfo[Token].worstend;
+					RangeSelect.Begin = start;
+					RangeSelect.End = end;
+					RangeSelect.Thread = S.TimerInfo[Token].worstthread;
+					RangeSelect.Index = Token;
+					ShowFlashMessage('Worst: ' + (end-start).toFixed(2) + 'ms', 100);
+					MoveTo(RangeSelect.Begin, RangeSelect.End, ThreadYBegin[RangeSelect.Thread] + nOffsetY, ThreadYEnd[RangeSelect.Thread+1] + nOffsetY);
+					MouseHandleDragEnd();
+				}
+				else
+				{
+					FilterInputSearch2.focus();
+				}
+
+			}
+			else if(Mode == ModeTimers || Mode == ModeTimers_Threads || Mode == ModeTimers_Groups)
+			{
+				ToggleFilterInput(0);
+				evt.preventDefault();
+			}
+
+		}
+		if(evt.keyCode == 88)
+		{
+			ToggleMode();
+		}
+		if(evt.keyCode == 220 && Mode == ModeDetailed)
+		{
+			ToggleGroupColors(true);
+		}
+		if(evt.keyCode == 67 && Mode == ModeDetailed)
+		{
+			HideMode = HideMode == HideModeCollapsed ? HideModeFullyHidden : HideModeCollapsed;
+			RequestRedraw();
+			Invalidate = 0;
+		}
+	}
+	if(evt.keyCode == 18)
+	{
+		KeyAltDown = 0;
+		MouseDragKeyUp();
+	}
+	else if(evt.keyCode == 17)
+	{
+		KeyCtrlDown = 0;
+		MouseDragKeyUp();
+	}
+	else if(evt.keyCode == 16)
+	{
+		KeyShiftDown = 0;
+		MouseDragKeyUp();
+	}
+
+
+	if(evt.keyCode == 27)
+	{
+		if(Mode == ModeDetailed)
+		{
+			let SearchString = FilterInputSearch2.value;
+			if(SearchString.length > 0)
+			{
+				//when search is active, esc clears in the following order:
+				//focus from search
+				//clears active range
+				//clears search
+				if(document.activeElement == FilterInputSearch2)
+				{
+					document.activeElement.blur();
+				}
+				else
+				{
+					if(RangeValid(RangeSelect))
+					{
+						RangeSelect = RangeInit();
+					}
+					else
+					{
+						FilterInputSearch2.value = "";
+					}
+				}
+			}
+			else
+			{
+				RangeSelect = RangeInit();
+			}
+		}
+
+		SortColumn = 0;
+		SortColumnMouseOver = "";
+		if(Mode == ModeTimers || Mode == ModeTimers_Threads || Mode == ModeTimers_Groups)
+		{
+			ToggleFilterInput(1);
+			evt.preventDefault();
+		}
+		if(SubMenuActive != -1)
+		{
+			if(FilterInputMenu.value.trim() != "")
+			{
+				FilterInputMenu.value = "";
+			}
+			else
+			{
+				EnableMenu(-1);
+			}
+		}
+
+		if(FilterSearchActive)
+		{
+			if(FilterInput.value != '')
+			{
+				FilterInput.value = '';
+			}
+			else
+			{
+				FilterInputHide();
+			}
+		}
+		else
+		{
+			FilterSearchReset();
+		}
+	}
+
+
+	if(evt.keyCode == 13 && !IgnoreInput)
+	{
+		if(FilterSearchActive)
+		{
+			FilterInputCommit();
+		}
+		else
+		{
+			FilterInputShow();
+		}
+	}
+	RequestRedraw();
+	Invalidate = 0;
+}
+function FilterInputUpdate()
+{
+	Invalidate = 0;
+	if(FilterSearchActive == 1)
+	{
+		FilterInputDiv.style['display'] = 'inline';
+		FilterInput.focus();
+	}
+	else
+	{
+		FilterSearchSelection = -1;
+		FilterInputDiv.style['display'] = 'none';
+	}
+}
+function FilterInputShow()
+{
+	FilterSearchActive = 1;
+	FilterInputUpdate();
+	RequestRedraw();
+}
+function FilterInputHide()
+{
+	FilterSearchActive = 0;
+	FilterInputUpdate();
+}
+
+function FilterInputCommit()
+{
+	if(FilterSearchSelection >= 0)
+	{
+		FilterSearchReset();
+		FilterSearchPassIndex = FilterSearchSelection;
+		FilterSearchStartTime = new Date();
+	}
+	FilterInputHide();
+}
+function FilterSearchReset()
+{
+	FilterSearchArray = new Array();
+}
+function CreateFilter(Filter)
+{
+	if(!Filter || Filter.length == 0)
+	{
+		return null;
+	}
+	Filter = Filter.split(' ');
+
+	var regexp = "";
+	for(var i = 0; i < Filter.length; ++i)
+	{
+		regexp = regexp + ".*" + Filter[i];
+	}
+	Filter = new Array();
+	regexp = regexp + ".*";
+	Filter.push(new RegExp(regexp, "i"));
+	return Filter;
+}
+function FilterKeyUp()
+{
+	FilterInputTimerString = FilterInputTimer.value;
+	FilterInputGroupString = FilterInputGroup.value;
+	FilterUpdate();
+}
+
+function FilterUpdate()
+{
+	FilterTimer = CreateFilter(FilterInputTimerString);
+	FilterGroup = CreateFilter(FilterInputGroupString);
+}
+
+function KeyDown(evt)
+{
+	//console.log("keydown ", evt.keyCode);
+	if(evt.keyCode == 18)
+	{
+		KeyAltDown = 1;
+	}
+	else if(evt.keyCode == 17)
+	{
+		KeyCtrlDown = 1;
+	}
+	else if(evt.keyCode == 16)
+	{
+		KeyShiftDown = 1;
+	}
+	else if(evt.keyCode == 9)
+	{
+		evt.preventDefault();
+	}
+	else if(evt.keyCode == 13)
+	{
+		evt.preventDefault();
+	}
+	if(evt.keyCode == 91) // z/tab to toggle tooltip
+	{
+		ToolTipFlip = 1;
+	}
+
+
+	Invalidate = 0;
+}
+function ParseCookie(str)
+{
+	if(!str) return null;
+	var result = str.match(/fisk=([^;]+)/);
+	// console.log("cookie is " + str);
+	if(result && result.length > 0)
+	{
+		var Obj = JSON.parse(result[1]);
+		if(!Obj.offline)
+		{
+			var C = {};
+			C.offline = Obj;
+			Obj = C;
+		}
+		return Obj;
+	}
+	return null;
+}
+
+function GetCookie()
+{
+	var Obj = ParseCookie(localStorage.getItem("microprofile_fisk"));
+	if(!Obj)
+	{
+		Obj = ParseCookie(document.cookie);
+	}
+	if(!Obj)
+	{
+		return {offline:{},live:{}};
+	}
+	return Obj;
+}
+
+function ReadCookie()
+{
+	var C = GetCookie();
+	var NewMode = ModeDetailed;
+	if(C.offline)
+	{
+		var Obj = C.offline;
+		if(Obj.Mode)
+		{
+			NewMode = Obj.ModeX;
+		}
+		if(Obj.ReferenceTimeString)
+		{
+			ReferenceTimeString = Obj.ReferenceTimeString;
+		}
+		if(Obj.TargetTimeString)
+		{
+			TargetTimeString = Obj.TargetTimeString;
+		}
+		if(Obj.ThreadsHidden)
+		{
+			ThreadsHidden = Obj.ThreadsHidden;
+		}
+		if(Obj.GroupsAllActive || Obj.GroupsAllActive == 0 || Obj.GroupsAllActive)
+		{
+			GroupsAllActive = Obj.GroupsAllActive;
+		}
+		else
+		{
+			GroupsAllActive = 1;
+		}
+		if(Obj.GroupsDisabled)
+		{
+			GroupsDisabled = Obj.GroupsDisabled;
+		}
+		if(Obj.nContextSwitchEnabled)
+		{
+			nContextSwitchEnabled = Obj.nContextSwitchEnabled;
+		}
+		else
+		{
+			nContextSwitchEnabled = 1;
+		}
+		if(Obj.GroupColors)
+		{
+			GroupColors = Obj.GroupColors;
+		}
+		else
+		{
+			GroupColors = 0;
+		}
+		if(Obj.nHideHelp)
+		{
+			nHideHelp = 1;
+		}
+		if(Obj.ColumnsEnabled)
+		{
+			ColumnsEnabled = Obj.ColumnsEnabled;
+		}
+		if(Obj.ToolTipCorner)
+		{
+			ToolTipCorner = Obj.ToolTipCorner;
+		}
+		if(Obj.DrawDetailedFlameMode)
+		{
+			DrawDetailedFlameMode = Obj.DrawDetailedFlameMode;
+		}
+		if(Obj.DrawDetailedCompareReverse)
+		{
+			DrawDetailedCompareReverse = Obj.DrawDetailedCompareReverse;
+		}
+		if(Obj.ThreadOrderNames)
+		{
+			ThreadOrderNames = Obj.ThreadOrderNames;
+		}
+		if(Obj.ThreadLogAutoHide)
+		{
+			ThreadLogAutoHide = Obj.ThreadLogAutoHide;
+		}
+		if(Obj.DrawDetailedNewDraw)
+		{
+			DrawDetailedNewDraw = Obj.DrawDetailedNewDraw;
+		}
+
+	}
+	SetContextSwitch(nContextSwitchEnabled);
+	SetMode(NewMode);
+	SetReferenceTime(ReferenceTimeString);
+	SetTargetTime(TargetTimeString);
+	UpdateGroupColors();
+	UpdateThreadLogAutoHide();
+}
+function WriteCookie()
+{
+	var C = GetCookie();
+	var Obj = new Object();
+	Obj.ModeX = Mode;
+	Obj.ReferenceTimeString = ReferenceTimeString;
+	Obj.TargetTimeString = TargetTimeString;
+	Obj.ThreadsHidden = ThreadsHidden;
+	Obj.GroupsDisabled = GroupsDisabled;
+	Obj.GroupsAllActive = GroupsAllActive;
+	Obj.nContextSwitchEnabled = nContextSwitchEnabled;
+	Obj.GroupColors = GroupColors;
+	Obj.ColumnsEnabled = ColumnsEnabled;
+	Obj.ToolTipCorner = ToolTipCorner;
+	Obj.DrawDetailedFlameMode = DrawDetailedFlameMode;
+	Obj.DrawDetailedCompareReverse = DrawDetailedCompareReverse;
+	Obj.ThreadOrderNames = ThreadOrderNames;
+	Obj.ThreadLogAutoHide = ThreadLogAutoHide;
+	Obj.DrawDetailedNewDraw = DrawDetailedNewDraw;
+	if(nHideHelp)
+	{
+		Obj.nHideHelp = 1;
+	}
+	C.offline = Obj;
+	var date = new Date();
+	date.setFullYear(2099);
+	var cookie = 'fisk=' + JSON.stringify(C) + ';expires=' + date;
+	document.cookie = cookie;
+	localStorage.setItem("microprofile_fisk", cookie);
+}
+
+function WindowRect(x,y,w,h)
+{
+	var s = {};
+	s.x = x;
+	s.y = y;
+	s.w = w;
+	s.h = h;
+	return s;
+}
+
+function MenuSize(w)
+{
+	return WindowRect(nWidth / 2 - w / 2, 5, w, nHeight);
+}
+
+function TimerMenuSize()
+{
+	return MenuSize(200 + 5 + FontWidth); //fix menu size
+}
+
+function DrawFilterSearch()
+{
+	FilterSearchSelection = -1;
+	FilterSearchPassIndex = -1;
+	FilterSearchSelectionMax = 0;
+	if(!FilterSearchActive)
+		return;
+	nHoverToken = -1;
+
+	if(FilterInputSearchLast != FilterInput.value)
+	{
+		nOffsetFilterSearch = 0;
+	}
+	FilterInputSearchLast = FilterInput.value;
+
+	var FilterArray = CreateFilter(FilterInput.value);
+	var context = CanvasDetailedView.getContext('2d');
+	var nColorIndex = 0;
+	var SizeInfo = TimerMenuSize();
+	var Y = SizeInfo.y;
+	var Width = S.TimerNameWidth + S.GroupNameWidth;
+	SizeInfo.w = Width;
+	var X = SizeInfo.x;
+
+	MoveFilterInputDiv(SizeInfo.x, SizeInfo.y, SizeInfo.w);
+	var YStart = Y;
+	Y += 35; //todo: measure somehow?
+	var MouseX = DetailedViewMouseX;
+	var MouseY = DetailedViewMouseY;
+
+	Y -= nOffsetFilterSearch;
+	var Count = 0;
+	for(var i = 0; i < S.TimerInfo.length; ++i)
+	{
+		var v = S.TimerInfo[i];
+		{
+			var Name = v.name;
+			var ParentName = S.GroupInfo[v.group].name;
+			if(FilterMatch(FilterArray, ParentName + " " + Name))
+			{
+				if(Y >= YStart)
+				{
+					Count++;
+					var ParentName = S.GroupInfo[v.group].name;
+					var ParentColor = 'white';
+					var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
+					var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+					var TextY = Y+BoxHeight-FontAscent;
+					context.fillStyle = bgcolor;
+					context.fillRect(X, Y, Width, BoxHeight);
+					context.fillStyle = ParentColor;
+					context.fillText(ParentName, X + 2, TextY);
+					context.fillStyle = g_Colors[v.cid];
+					context.textAlign = 'right';
+					context.fillText(Name, X + Width - 2, TextY);
+					context.textAlign = 'left';
+					if(bMouseIn)
+					{
+						FilterSearchSelection = i;
+					}
+				}
+				Y += BoxHeight;
+				if(Y > nHeight)
+					break;
+				nColorIndex = 1-nColorIndex;
+			}
+		}
+	}
+	FilterSearchSelectionMax = Count;
+	SizeInfo.h = Y-SizeInfo.y;
+	RequestRedraw();
+	return SizeInfo;
+}
+
+function CalcAverage()
+{
+	var Sum = 0;
+	var Count = 0;
+	for(nLog = 0; nLog < nNumLogs; nLog++)
+	{
+		StackPos = 0;
+		for(var i = 0; i < S.Frames.length; i++)
+		{
+			var Frame_ = S.Frames[i];
+			var tt = Frame_.tt[nLog];
+			var ts = Frame_.ts[nLog];
+
+			var count = tt.length;
+			for(var j = 0; j < count; j++)
+			{
+				var type = tt[j];
+				var time = ts[j];
+				if(type == 1)
+				{
+					Stack[StackPos] = time;//store the frame which it comes from
+					StackPos++;
+				}
+				else if(type == 0)
+				{
+					if(StackPos>0)
+					{
+
+						StackPos--;
+						var localtime = time - Stack[StackPos];
+						Count++;
+						Sum += localtime;
+					}
+				}
+			}
+		}
+	}
+	return Sum / Count;
+
+}
+
+function CheckExtType(value, Checked)
+{
+	if((value&3) != 3)
+		return false;
+	return (value >> 2) == Checked;
+
+}
+
+function MakeLod(index, MinDelta, TimeArray, TypeArray, IndexArray, LogStart)
+{
+	if(S.LodData[index])
+	{
+		console.log("error!!");
+	}
+	var o = new Object();
+	o.MinDelta = MinDelta;
+	o.TimeArray = TimeArray;
+	o.TypeArray = TypeArray;
+	o.IndexArray = IndexArray;
+	o.LogStart = LogStart;
+	S.LodData[index] = o;
+}
+
+function PreprocessBuildSplitArray()
+{
+	var nNumLogs = S.Frames[0].ts.length;
+
+	ProfileEnter("PreprocessBuildSplitArray");
+	var SplitArrays = new Array(nNumLogs);
+
+	for(nLog = 0; nLog < nNumLogs; ++nLog)
+	{
+		console.log("source log " + nLog + " size " + S.LodData[0].TypeArray[nLog].length);
+	}
+
+
+	for(nLog = 0; nLog < nNumLogs; nLog++)
+	{
+		var MaxDepth = 1;
+		var StackPos = 0;
+		var Stack = Array(20);
+		var TypeArray = S.LodData[0].TypeArray[nLog];
+		var TimeArray = S.LodData[0].TimeArray[nLog];
+		var DeltaTimes = new Array(TypeArray.length);
+
+		for(var j = 0; j < TypeArray.length; ++j)
+		{
+			var type = TypeArray[j];
+			var time = TimeArray[j];
+			if(type == 1)
+			{
+				//push
+				Stack[StackPos] = time;
+				StackPos++;
+			}
+			else if(type == 0)
+			{
+				if(StackPos>0)
+				{
+					StackPos--;
+					DeltaTimes[j] = time - Stack[StackPos];
+				}
+				else
+				{
+					DeltaTimes[j] = 0;
+				}
+			}
+		}
+		DeltaTimes.sort(function(a,b){return b-a;});
+		var SplitArray = Array(NumLodSplits);
+		var SplitIndex = DeltaTimes.length;
+
+		var j = 0;
+		for(j = 0; j < NumLodSplits; ++j)
+		{
+			SplitIndex = Math.floor(SplitIndex / 2);
+			while(SplitIndex > 0 && !DeltaTimes[SplitIndex])
+			{
+				SplitIndex--;
+			}
+			if(SplitIndex < SplitMin)
+			{
+				break;
+			}
+			//search.. if 0
+			var SplitTime = DeltaTimes[SplitIndex];
+			if(SplitTime>=0)
+			{
+				SplitArray[j] = SplitTime;
+			}
+			else
+			{
+				SplitArray[j] = SPLIT_LIMIT;
+			}
+			if(j>0)
+			{
+				console.assert(SplitArray[j-1] <= SplitArray[j], "must be less");
+			}
+
+		}
+		for(; j < NumLodSplits; ++j)
+		{
+			SplitArray[j] = SPLIT_LIMIT;
+		}
+
+
+		SplitArrays[nLog] = SplitArray;
+	}
+	ProfileLeave();
+	return SplitArrays;
+}
+
+function PreprocessBuildDurationArray()
+{
+	var nNumLogs = S.Frames[0].ts.length;
+	ProfileEnter("PreprocessBuildDurationArray");
+	var DurationArrays = new Array(nNumLogs);
+	for(nLog = 0; nLog < nNumLogs; ++nLog)
+	{
+		var MaxDepth = 1;
+		var StackPos = 0;
+		var Stack = Array(20);
+		var StackIndex = Array(20);
+		var TypeArray = S.LodData[0].TypeArray[nLog];
+		var TimeArray = S.LodData[0].TimeArray[nLog];
+		var DurationArray = Array(S.LodData[0].TypeArray[nLog].length);
+		for(var j = 0; j < TypeArray.length; ++j)
+		{
+			var type = TypeArray[j];
+			var time = TimeArray[j];
+			if(type == 1)
+			{
+				//push
+				Stack[StackPos] = time;
+				StackIndex[StackPos] = j;
+				StackPos++;
+			}
+			else if(type == 0)
+			{
+				if(StackPos>0)
+				{
+					StackPos--;
+					var Duration = time - Stack[StackPos];
+					DurationArray[StackIndex[StackPos]] = Duration;
+					DurationArray[j] = Duration;
+				}
+				else
+				{
+					DurationArray[j] = 0;
+				}
+			}
+		}
+		for(var j = 0; j < StackPos; ++j)
+		{
+			DurationArray[j] = 0;
+		}
+		DurationArrays[nLog] = DurationArray;
+	}
+	ProfileLeave();
+	return DurationArrays;
+
+}
+function PreprocessLods()
+{
+	ProfileEnter("PreprocessLods");
+	var nNumLogs = S.Frames[0].ts.length;
+	var SplitArrays = PreprocessBuildSplitArray();
+	var DurationArrays = PreprocessBuildDurationArray();
+	var Source = S.LodData[0];
+	var SourceLogStart = Source.LogStart;
+	var NumFrames = SourceLogStart.length;
+
+	for(var i = 0; i < NumLodSplits-1; ++i)
+	{
+		var DestLogStart = Array(SourceLogStart.length);
+		for(var j = 0; j < DestLogStart.length; ++j)
+		{
+			DestLogStart[j] = Array(nNumLogs);
+		}
+		var MinDelta = Array(nNumLogs);
+		var TimeArray = Array(nNumLogs);
+		var IndexArray = Array(nNumLogs);
+		var TypeArray = Array(nNumLogs);
+
+
+
+		for(nLog = 0; nLog < nNumLogs; ++nLog)
+		{
+			var SourceTypeArray = Source.TypeArray[nLog];
+			var SourceTimeArray = Source.TimeArray[nLog];
+			var SourceIndexArray = Source.IndexArray[nLog];
+			var Duration = DurationArrays[nLog];
+			console.assert(Duration.length == SourceTypeArray.length, "must be equal!");
+			var SplitTime = SplitArrays[nLog][i];
+
+			MinDelta[nLog] = SplitTime;
+			if(SplitTime < SPLIT_LIMIT)
+			{
+				var SourceCount = SourceTypeArray.length;
+				var DestTypeArray = Array();
+				var DestTimeArray = Array();
+				var DestIndexArray = Array();
+				var RemapArray = Array(SourceCount);
+				var DiscardLast = 0;
+
+				for(var j = 0; j < SourceCount; ++j)
+				{
+					RemapArray[j] = DestTypeArray.length;
+					if(Duration[j] >= SplitTime || ((SourceTypeArray[j]&3) == 3 && 0 == DiscardLast))
+					{
+						DiscardLast = 0;
+						DestTypeArray.push(SourceTypeArray[j]);
+						DestTimeArray.push(SourceTimeArray[j]);
+						DestIndexArray.push(SourceIndexArray[j]);
+					}
+					else
+					{
+						DiscardLast = 1;
+					}
+				}
+				TimeArray[nLog] = DestTimeArray;
+				IndexArray[nLog] = DestIndexArray;
+				TypeArray[nLog] = DestTypeArray;
+				for(var j = 0; j < NumFrames; ++j)
+				{
+					var OldStart = SourceLogStart[j][nLog];
+					var NewStart = RemapArray[OldStart];
+					var FrameArray = DestLogStart[j];
+					FrameArray[nLog] = NewStart;
+				}
+			}
+			else
+			{
+
+				for(var j = 0; j < NumFrames; ++j)
+				{
+					var FrameArray = DestLogStart[j];
+
+					FrameArray[nLog] = 0;
+				}
+
+			}
+
+		}
+		MakeLod(i+1, MinDelta, TimeArray, TypeArray, IndexArray, DestLogStart);
+	}
+	ProfileLeave();
+}
+
+
+function HistogramCreate(MaxTime)
+{
+	let Histogram = new Object();
+	Histogram.MaxTime = MaxTime;
+	Histogram.MaxOccurence = 0;
+	Histogram.Occurences = new Uint32Array(100);
+	return Histogram;
+}
+function HistogramAdd(Histogram, Value)
+{
+	if(Value > Histogram.MaxTime)
+		debugger;
+	let Index = Math.floor(Value / Histogram.MaxTime);
+	Index = Math.max(0, Math.min(99, Index));
+	Occurrences[Index]++;
+	Histogram.MaxOccurence = Math.max(Histogram.MaxOccurence, Occurrences[Index]);
+
+}
+
+function PreprocessLogBarArray()
+{
+	ProfileEnter("PreprocessLogBarArray");
+
+	let NumLogs = S.NumLogs;
+	let Stack = Array(20);
+
+	let LogRows = new Array(NumLogs);
+	S.LogRows = LogRows;
+
+	for(let nLog = 0; nLog < NumLogs; nLog++)
+	{
+		let MaxStack = S.MaxStack[nLog];
+		let SectionColorStack = new Array(MaxStack);
+		SectionColorStack[0] = CIDFail;
+		let StackPos = 0;
+		let SectionColorStackPos = 1;
+
+		let Rows = new Array(MaxStack);
+		LogRows[nLog] = Rows;
+		for(let i = 0; i < MaxStack; ++i)
+		{
+			Row = new Object();
+			//Note; This has always got implied begin / end tied together
+			Row.Offset = i;
+			Row.Tree = new Array()
+			Row.Tree[0] = new Object();
+			Row.Tree[0].Source = new Array();
+			Row.Tree[0].Index_ = new Array();
+			Row.Tree[0].ColorIds_ = new Array();
+			Row.Tree[0].Begin_ = new Array();
+			Row.Tree[0].Duration_ = new Array();
+			Row.Tree[0].MaxDuration_ = new Array();
+			Row.Tree[0].SumDuration_ = new Array();
+			Row.Tree[0].SectionColor_ = new Array();
+			Row.Tree[0].Parent_ = -1;
+			Row.Tree[0].Tail = 0;
+			Row.Tree[0].Length = 0;
+
+			Rows[i] = Row;
+		}
+		let RootSectionColor = CIDFail;
+
+		let SrcTypeArray = S.TypeArray[nLog];
+		let SrcTimeArray = S.TimeArray[nLog];
+		let SrcIndexArray = S.IndexArray[nLog];
+		let len = SrcTypeArray.length;
+
+		for(let i = 0; i < len; ++i)
+		{
+			let type = SrcTypeArray[i];
+			let time = SrcTimeArray[i];
+			let index = SrcIndexArray[i];
+			let skipsection = false;
+
+			let TimerInfo = type < 2 ? S.TimerInfo[index] : null;
+			if(type == 1)
+			{
+				let IsSection = TimerInfo.flags & FLAGS_SECTION;
+				if(IsSection)
+				{
+					SectionColorStack[SectionColorStackPos] = TimerInfo.cid;
+					SectionColorStackPos++;
+				}
+				if(!IsSection)
+				{
+					Stack[StackPos] = i;
+					StackPos++;
+				}
+
+			}
+			else if(type == 0)
+			{
+				let IsSection = TimerInfo.flags & FLAGS_SECTION;	
+				if(IsSection)
+				{
+					if(SectionColorStackPos > 1)
+					{
+						SectionColorStackPos--;
+					}
+					else
+					{
+						//debugger;
+						// Hitting a close, without a start. tag all previously untagged to belong to this section.
+						for(let i = 0; i < MaxStack; ++i)
+						{
+							let sc = Rows[i].Tree[0].SectionColor_;
+							for(let j = 0; j < sc.length; ++j)
+							{
+								if(sc[j] == CIDFail)
+								{
+									sc[j] = TimerInfo.cid;
+								}
+							}
+						}
+
+					}
+
+				}
+				if(!IsSection && StackPos > 0)
+				{
+					StackPos--;
+					let stackindex = Stack[StackPos];
+					let sectioncolor = SectionColorStack[SectionColorStackPos-1];
+					let begintype = SrcTypeArray[stackindex];
+					let begintime = SrcTimeArray[stackindex];
+					let beginindex = SrcIndexArray[stackindex];
+
+					if(type != 0)
+						debugger;
+					if(begintype != 1)
+						debugger;
+					if(index != beginindex)
+						debugger;
+					if(StackPos >= MaxStack || StackPos < 0)
+						debugger;
+					let rt0 = Rows[StackPos].Tree[0];
+					rt0.Source.push(i);
+					rt0.Index_.push(beginindex);
+					rt0.ColorIds_.push(S.TimerInfo[beginindex].cid);
+					rt0.Begin_.push(begintime);
+					let Duration = time - begintime;
+					rt0.Duration_.push(Duration);
+					rt0.SumDuration_.push(Duration);
+					rt0.MaxDuration_.push(Duration);
+					rt0.SectionColor_.push(sectioncolor);
+					if(CheckExtType(SrcTypeArray[stackindex+1],ETOKEN_GPU_CPU_TIMESTAMP)) // (SrcTypeArray[stackindex+1]&3) == 3) // this is a gpu log with a cpu marker appended
+					{
+						//if((SrcTypeArray[stackindex+2]&3) != 3)
+						if(!CheckExtType(SrcTypeArray[stackindex+2], ETOKEN_GPU_CPU_SOURCE_THREAD))
+							debugger; //should be matching triplets
+
+						if(!CheckExtType(SrcTypeArray[i+1], ETOKEN_GPU_CPU_TIMESTAMP))
+							debugger; //should be matching pairs
+
+						let CustomToken1 = SrcTypeArray[stackindex+1] >> 2;
+						let CustomToken2 = SrcTypeArray[stackindex+2] >> 2;
+						
+						if(CustomToken1 != ETOKEN_GPU_CPU_TIMESTAMP)
+							debugger;
+						if(CustomToken2 != ETOKEN_GPU_CPU_SOURCE_THREAD)
+							debugger;
+
+
+						let CpuBegin = SrcTimeArray[stackindex+1];
+						let CpuEnd = SrcTimeArray[i+1];
+						let Thread = SrcIndexArray[stackindex+2];
+						if(!rt0.CpuDuration) //only there for gpu logs, so created on demand
+						{
+							rt0.CpuBegin = new Array();
+							rt0.CpuDuration = new Array();
+							rt0.CpuThread = new Array();
+							for(let j = 0; j < rt0.Length; ++j)
+							{
+								rt0.CpuBegin.push(0);
+								rt0.CpuDuration.push(0);
+								rt0.CpuThread.push(0);
+							}
+						}
+						rt0.CpuBegin.push(CpuBegin);
+						rt0.CpuDuration.push(CpuEnd - CpuBegin);
+						rt0.CpuThread.push(Thread);
+					}
+					else if(rt0.CpuDuration)
+					{
+						rt0.CpuBegin.push(0);
+						rt0.CpuDuration.push(0);
+						rt0.CpuThread.push(0);
+					}
+
+					rt0.Length++;
+				}
+
+			}
+			else if(type != 0)
+			{
+			}
+		}
+
+		for(let r = 0; r < Rows.length; ++r)
+		{
+			let Row = Rows[r];
+			let RowTreeIndex = 0;
+
+			Row.Tree[0].Index = new Int32Array(Row.Tree[0].Index_);
+			Row.Tree[0].ColorIds = new Int32Array(Row.Tree[0].ColorIds_);// = new Array();
+			Row.Tree[0].Begin = new Float32Array(Row.Tree[0].Begin_);
+			Row.Tree[0].Duration = new Float32Array(Row.Tree[0].Duration_);
+			Row.Tree[0].MaxDuration = new Float32Array(Row.Tree[0].MaxDuration_);
+			Row.Tree[0].SumDuration = new Float32Array(Row.Tree[0].SumDuration_);
+			Row.Tree[0].SectionColor = new Int32Array(Row.Tree[0].SectionColor_);
+
+			// stop at 100 elements...
+			while(Row.Tree[RowTreeIndex].Begin.length > 10)
+			{
+
+				//Use RowTreeIndex to build RowTreeIndex+1 with half as much data.
+				let RowTreeLevelParent = Row.Tree[RowTreeIndex];
+				let Size = Math.floor(RowTreeLevelParent.Index.length / 2);
+				let Tail = RowTreeLevelParent.Index.length % 2;
+				if(Size < 0)
+					debugger;
+
+				let RowTreeLevel = new Object();
+				RowTreeLevel.Index = new Int32Array(Size);
+				RowTreeLevel.ColorIds = new Int32Array(Size);
+				RowTreeLevel.Begin = new Float32Array(Size);
+				RowTreeLevel.Duration = new Float32Array(Size);
+				RowTreeLevel.SumDuration = new Float32Array(Size);
+				RowTreeLevel.MaxDuration = new Float32Array(Size);
+				RowTreeLevel.SectionColor = new Int32Array(Size);
+				RowTreeLevel.Parent = RowTreeIndex;
+				RowTreeLevel.Tail = Tail;
+				RowTreeLevel.Length = 0;
+
+				for(let i = 0; i < Size; ++i)
+				{
+					let i0 = i * 2;
+					let i1 = i0 + 1;
+					//Should do fancy color merging, but hey just taking the color of the largest seems to work well enough.
+					if(RowTreeLevelParent.MaxDuration[i1] > RowTreeLevelParent.MaxDuration[i0])
+					{
+						RowTreeLevel.Index[i] = i1;
+						RowTreeLevel.ColorIds[i] = RowTreeLevelParent.ColorIds[i1];
+						RowTreeLevel.MaxDuration[i] = RowTreeLevelParent.MaxDuration[i1];
+						RowTreeLevel.SectionColor[i] = RowTreeLevelParent.SectionColor[i1];
+					}
+					else
+					{
+						RowTreeLevel.Index[i] = i0;
+						RowTreeLevel.ColorIds[i] = RowTreeLevelParent.ColorIds[i0];
+						RowTreeLevel.MaxDuration[i] = RowTreeLevelParent.MaxDuration[i0];
+						RowTreeLevel.SectionColor[i] = RowTreeLevelParent.SectionColor[i0];
+					}
+					RowTreeLevel.SumDuration[i] = RowTreeLevelParent.SumDuration[i0] + RowTreeLevelParent.SumDuration[i1];
+					RowTreeLevel.Begin[i] =	RowTreeLevelParent.Begin[i0];
+					RowTreeLevel.Duration[i] = RowTreeLevelParent.Begin[i1] - RowTreeLevelParent.Begin[i0]  + RowTreeLevelParent.Duration[i1];
+					RowTreeLevel.Length++;
+				}
+
+
+				if(Row.Tree.length != RowTreeIndex+1)
+					debugger;
+				Row.Tree.push(RowTreeLevel);
+				Row.MaxTree = Row.Tree.length;
+				RowTreeIndex++;
+			}
+		}
+	}
+	ProfileLeave();
+}
+
+function PreprocessGlobalArray()
+{
+	ProfileEnter("PreprocessGlobalArray");
+	var nNumLogs = S.Frames[0].ts.length;
+	var CaptureStart = S.Frames[0].framestart;
+	var CaptureEnd = S.Frames[S.Frames.length-1].frameend;
+	S.TypeArray = new Array(nNumLogs);
+	S.TimeArray = new Array(nNumLogs);
+	S.IndexArray = new Array(nNumLogs);
+	S.NumLogs = nNumLogs;
+	var LogStartArray = new Array(S.Frames.length);
+	for(var i = 0; i < S.Frames.length; i++)
+	{
+		S.Frames[i].LogStart = new Array(nNumLogs);
+		LogStartArray[i] = S.Frames[i].LogStart;
+
+		S.Frames[i].LogEnd = new Array(nNumLogs);
+	}
+	var MinDelta = Array(nNumLogs);
+	for(nLog = 0; nLog < nNumLogs; nLog++)
+	{
+		MinDelta[nLog] = 0;
+		var Discard = 0;
+		var TypeArray = new Array();
+		var TimeArray = new Array();
+		var IndexArray = new Array();
+		for(var i = 0; i < S.Frames.length; i++)
+		{
+			var Frame_ = S.Frames[i];
+			Frame_.LogStart[nLog] = TimeArray.length;
+			var CanDiscard = !S.ISGPU[nLog] || Frame_.frameendgpu > 0; //in case of no reference, we cannot discard gpu markers. This happens when there is no gpu/cpu tick reference
+
+			var FrameDiscard = (S.ISGPU[nLog] ? Frame_.frameendgpu : Frame_.frameend) + 33;//if timestamps are more than 33ms after current frame, we assume buffer has wrapped.
+			var tt = Frame_.tt[nLog];
+			var ts = Frame_.ts[nLog];
+			var ti = Frame_.ti[nLog];
+			var len = tt.length;
+			var DiscardLast = 0;
+			for(var xx = 0; xx < len; ++xx)
+			{
+				var Skip = (tt[i]&3 == 3) ? DiscardLast : (CanDiscard && ts[xx] > FrameDiscard);
+				if(Skip)
+				{
+					Discard++;
+					DiscardLast = 1;
+				}
+				else
+				{
+					DiscardLast = 0;
+					TypeArray.push(tt[xx]);
+					TimeArray.push(ts[xx]);
+					IndexArray.push(ti[xx]);
+				}
+			}
+			Frame_.LogEnd[nLog] = TimeArray.length;
+		}
+		S.TypeArray[nLog] = TypeArray;
+		S.TimeArray[nLog] = TimeArray;
+		S.IndexArray[nLog] = IndexArray;
+		if(Discard)
+		{
+			console.log('discarded ' + Discard + ' markers from ' + S.ThreadNames[nLog]);
+		}
+	}
+	MakeLod(0, MinDelta, S.TimeArray, S.TypeArray, S.IndexArray, LogStartArray);
+	ProfileLeave();
+}
+
+function InitThreadLogAutoHidden()
+{
+	let nNumLogs = S.Frames[0].ts.length;
+	if(!S.ThreadLogAutoHidden)
+	{
+		S.ThreadLogAutoHidden = Array();
+	}
+	while(S.ThreadLogAutoHidden.length < nNumLogs)
+	{
+		S.ThreadLogAutoHidden.push(0);
+	}
+	if(!S.ThreadLogTypesUsed)
+	{
+		S.ThreadLogTypesUsed = Array();
+	}
+	while(S.ThreadLogTypesUsed.length < nNumLogs)
+	{
+		S.ThreadLogTypesUsed.push([]);
+	}
+}
+
+function UpdateThreadLogAutoHide()
+{
+	let AutoHide = ThreadLogAutoHide;
+	let nNumLogs = S.Frames[0].ts.length;
+	InitThreadLogAutoHidden();
+	for(let nLog = 0; nLog < nNumLogs; ++nLog)
+	{
+		if(AutoHide)
+		{
+			let TypesUsed = S.ThreadLogTypesUsed[nLog];
+			S.ThreadLogAutoHidden[nLog] = 1;
+			for(let i = 0; i < TypesUsed.length; ++i)
+			{
+				if(TypesUsed[i])
+				{
+					S.ThreadLogAutoHidden[nLog] = 0;
+					break;
+				}
+			}
+		}
+		else
+		{
+			S.ThreadLogAutoHidden[nLog] = 0;
+		}
+		console.log("AutoHide ", nLog, " ", S.ThreadLogAutoHidden[nLog]);
+	}
+}
+
+function PreprocessGatherLogTypes()
+{
+	ProfileEnter("PreprocessGatherLogTypes");
+	let TimerCount = S.TimerInfo.length;
+	let nNumLogs = S.Frames[0].ts.length;
+	InitThreadLogAutoHidden();
+	for(let nLog = 0; nLog < nNumLogs; nLog++)
+	{
+		S.ThreadLogAutoHidden[nLog] = 0;
+		let TypesUsed = Array(TimerCount);
+		for(let i = 0; i < TypesUsed.length; ++i)
+		{
+			TypesUsed[i] = 0;
+		}
+		for(let i = 0; i < S.Frames.length; i++)
+		{
+			let F = S.Frames[i];
+			console.assert(F.tt.length == nNumLogs);
+			let Data = F.ti[nLog];
+			for(let j in Data)
+			{
+				let t = Data[j];
+				console.assert(t < TimerCount);
+				TypesUsed[t] = 1;
+			}
+		}
+		S.ThreadLogTypesUsed[nLog] = TypesUsed;
+	}
+	ProfileLeave();
+}
+
+function PreprocessFindFirstFrames()
+{
+	ProfileEnter("PreprocesFindFirstFrames");
+	//create arrays that show how far back we need to start search in order to get all markers.
+	let nNumLogs = S.Frames[0].ts.length;
+	for(let i = 0; i < S.Frames.length; i++)
+	{
+		S.Frames[i].FirstFrameIndex = new Array(nNumLogs);
+		for(let j = 0; j < S.Frames[i].FirstFrameIndex.length; ++j)
+		{
+			S.Frames[i].FirstFrameIndex[j] = 0;
+		}
+	}
+
+	let StackPos = 0;
+	let Stack = Array(20);
+	S.MaxStack = Array(nNumLogs);
+
+	for(nLog = 0; nLog < nNumLogs; nLog++)
+	{
+		let MaxStack = 0;
+		StackPos = 0;
+		for(let i = 0; i < S.Frames.length; i++)
+		{
+			let Frame_ = S.Frames[i];
+			let tt = Frame_.tt[nLog];
+			let count = tt.length;
+
+			let FirstFrame = i;
+			if(StackPos>0)
+			{
+				FirstFrame = Stack[0];
+			}
+			S.Frames[i].FirstFrameIndex[nLog] = FirstFrame;
+
+			for(let j = 0; j < count; j++)
+			{
+				let type = tt[j];
+				if(type == 1)
+				{
+					Stack[StackPos] = i;//store the frame which it comes from
+					StackPos++;
+					if(StackPos > MaxStack)
+					{
+						MaxStack = StackPos;
+					}
+				}
+				else if(type == 0)
+				{
+					if(StackPos>0)
+					{
+						StackPos--;
+					}
+				}
+			}
+		}
+		S.MaxStack[nLog] = MaxStack;
+	}
+	S.MaxStack2 = Array(S.MaxStack.length);
+	for(let i = 0; i < S.MaxStack2.length; ++i)
+		S.MaxStack2[i] = 0;
+	S.SecondActive = 0;
+	ProfileLeave();
+}
+function PreprocessMeta()
+{
+	return;
+	MetaLengths = Array(MetaNames.length);
+	MetaLengthsAvg = Array(MetaNames.length);
+	MetaLengthsMax = Array(MetaNames.length);
+	for(var i = 0; i < MetaNames.length; ++i)
+	{
+		MetaLengths[i] = MetaNames[i].length+1;
+		MetaLengthsAvg[i] = MetaNames[i].length+5;
+		MetaLengthsMax[i] = MetaNames[i].length+5;
+		if(MetaLengths[i]<12)
+			MetaLengths[i] = 12;
+		if(MetaLengthsAvg[i]<12)
+			MetaLengthsAvg[i] = 12;
+		if(MetaLengthsMax[i]<12)
+			MetaLengthsMax[i] = 12;
+	}
+	for(var i = 0; i < S.TimerInfo.length; ++i)
+	{
+		var Timer = S.TimerInfo[i];
+		for(var j = 0; j < MetaNames.length; ++j)
+		{
+			var Len = FormatMeta(Timer.meta[j],0).length + 2;
+			var LenAvg = FormatMeta(Timer.meta[j],2).length + 2;
+			var LenMax = FormatMeta(Timer.meta[j],0).length + 2;
+			if(Len > MetaLengths[j])
+			{
+				MetaLengths[j] = Len;
+			}
+			if(LenAvg > MetaLengthsAvg[j])
+			{
+				MetaLengthsAvg[j] = LenAvg;
+			}
+			if(LenMax > MetaLengthsMax[j])
+			{
+				MetaLengthsMax[j] = LenMax;
+			}
+		}
+	}
+}
+
+function StringHash(s) //note: matching code in microprofile.cpp: uint32_t MicroProfileStringHash(const char* pString)
+{
+	let h = 0xfeedba3e;
+	for(let i = 0; i < s.length; ++i)
+	{
+		h = s.charCodeAt(i) + (h << 5) - h;
+		h = h & h;
+	}
+	return Math.abs(h);
+}
+
+function StringColorIndex(Name)
+{
+	let h = StringHash(Name);
+	let cidx = Math.floor(360*(h  / (1<<32-1)) );
+	return cidx;
+}
+
+function ColorFromString(Name, S, L)
+{
+	let H = StringColorIndex(Name);
+	return "hsl(" + H + "," + S + "%, " + L+ "%)";
+}
+function LerpColor(v)
+{
+	let R_0 = 0;
+	let G_0 = 1;
+	let B_0 = 0;
+
+	let R_1 = 1;
+	let G_1 = 0.5;
+	let B_1 = 0;
+
+	let R_2 = 1;
+	let G_2 = 0;
+	let B_3 = 0;
+	let R;
+	let G;
+	if(v < 0.5)
+	{
+		v *= 2;
+		let v0 = (1-v);
+		R = R_0 * v0 + R_1 * v;
+		G = G_0 * v0 + G_1 * v;
+
+	}
+	else
+	{
+		v = (v-0.5) * 2;
+		let v0 = (1-v);
+		R = R_1 * v0 + R_2 * v;
+		G = G_1 * v0 + G_2 * v;
+	}
+	R *= 255;
+	G *= 255;
+	return "rgb(" + R.toFixed(0) + "," + G.toFixed(0) + ",0)";
+
+}
+
+function PreprocessThreadColors(S)
+{
+	S.ThreadColors = Array(S.ThreadNames.length);
+	for(let i = 0; i < S.ThreadNames.length; ++i)
+	{
+		var cidx = StringColorIndex(S.ThreadNames[i]);
+		var color = "hsl(" + cidx + ",50%, 60%)";
+		var coloroff = "hsl(" + cidx + ",85%, 50%)";
+		var colordark = "hsl(" + cidx + ",80%, 30%)";
+		var colordark_cid = GetColorIndex(colordark);
+		var colortrans = "hsla(" + cidx + ",55%, 80%, 0.2)";
+		S.ThreadColors[i] = {"color":color, "colordark":colordark, "cidx":cidx, "gradient":null,"gradientoff":null, "coloroff":coloroff, "colordark_cid":colordark_cid, "colortrans":colortrans};
+	}
+}
+
+function PreprocessWidths()
+{
+	let context = CanvasHistory.getContext('2d');
+	context.font = Font;
+	S.TimerNameWidth = 0;
+	S.GroupNameWidth = 0;
+
+	for(let i in S.TimerInfo)
+	{
+		let str = S.GroupInfo[S.TimerInfo[i].group].name + "XXX" + S.TimerInfo[i].name;
+		let width = context.measureText(str).width;
+		let widthname = context.measureText(S.TimerInfo[i].name).width;
+		S.TimerInfo[i].wtotal = width;
+		S.TimerInfo[i].w = widthname;
+		S.TimerNameWidth = Math.max(S.TimerNameWidth, widthname);
+	}
+	for(let i in S.GroupInfo)
+	{
+		let widthname = context.measureText(S.TimerInfo[i].name).width;
+		S.GroupNameWidth = Math.max(S.GroupNameWidth, widthname);
+	}
+	for(let i in S.ThreadNames)
+	{
+		let w = context.measureText(S.ThreadNames[i]).width;
+		S.ThreadNameWidth = Math.max(S.ThreadNameWidth, w);
+	}
+	for(let i in S.CategoryInfo)
+	{
+		let w = context.measureText(S.CategoryInfo[i]).width;
+		S.ThreadCategoryWidth = Math.max(S.ThreadCategoryWidth, w);
+	}
+}
+
+function PreprocessTimeline()
+{
+	Timeline.Times = S.TimelineArray;
+	Timeline.Ids = S.TimelineIdArray;
+	Timeline.Colors = new Array(S.TimelineArray.length);
+	Timeline.Names = S.TimelineNames;
+	Timeline.Ends = new Array(S.TimelineArray.length);
+	Timeline.Pairs = new Array(S.TimelineArray.length);
+	Timeline.SearchMatch = new Array(S.TimelineArray.length);
+	Timeline.Tracks = new Array();
+	Timeline.Positions = new Array();
+	for(var i = 0; i < Timeline.Times.length; ++i)
+	{
+		Timeline.Positions[i] = -1;
+		Timeline.Ends[i] = -1;
+		Timeline.Pairs[i] = -1;
+		Timeline.SearchMatch[i] = false;
+		var Color = S.TimelineColorArray[i]
+		if(!Color || Color == '')
+		{
+			Color = '#777777'
+		}
+		Timeline.Colors[i] = GetColorIndex(Color);
+		if(null == Timeline.Colors[i])
+			debugger;
+		Timeline.Colors[i] = GetColorIndex(Color);
+	}
+
+
+	var LinearizeTrack = function(Track)
+	{
+		var b = new Array();
+		var e = new Array();
+		// var n = new Array();
+		var k = new Array();
+		var h = Track.h;
+		while(h != -1)
+		{
+			b.push(Track.b[h]);
+			e.push(Track.e[h]);
+			k.push(Track.k[h]);
+
+			h = Track.n[h];
+		}
+	}
+
+	var CreateTrack = function()
+	{
+		var Track = {};
+		Track.b = new Array();
+		Track.e = new Array();
+		Track.n = new Array();
+		Track.k = new Array();
+		Track.h = -1;
+		return Track;
+	}
+
+
+	var TryAddToTrack = function(Track, b, e, k)
+	{
+		var Invalid = 0;
+		var prev = -1;
+		var next = Track.h;
+		while(next != -1)
+		{
+			var B = Track.b[next];
+			var E = Track.e[next];
+			if(Math.max(B, b) < Math.min(E, e))
+			{
+				Invalid = 1;
+				break;
+			}
+			if(E < b)
+			{
+				//should be after next, continue
+			}else if(e < B)
+			{
+				//insert at this spot
+				break;
+			}
+			prev = next;
+			next = Track.n[next];
+		}
+		if(!Invalid)
+		{
+			var idx = Track.b.length;
+			Track.b.push(b);
+			Track.e.push(e);
+			Track.k.push(k);
+			Track.n.push(next);
+			if(prev == -1)
+			{
+				Track.h = idx;
+			}
+			else
+			{
+				var h = Track.n[prev];
+				if(h != next)
+				{
+					debugger;
+				}
+				Track.n[prev] = idx;
+			}
+			return true;
+		}
+		else
+		{
+			return false;
+		}
+	};
+
+
+	var AddToTrack = function(b, e, k)
+	{
+		var Tracks = Timeline.Tracks;
+
+		for(var i = 0; i < Tracks.length; ++i)
+		{
+			var Track = Tracks[i];
+			if(TryAddToTrack(Track, b, e, k))
+			{
+				return i;
+			}
+		}
+		var NewTrack = CreateTrack();
+		var i = Timeline.Tracks.length;
+		Timeline.Tracks.push(NewTrack);
+		if(!TryAddToTrack(NewTrack, b, e, k))
+		{
+			debugger;
+		}
+		return i;
+
+	};
+
+	let HasMatchingName = function(index)
+	{
+		let name = Timeline.Names[index];
+		return name && name.length > 0;
+	};
+
+
+
+
+
+	var Matching = {};
+	var Pairs = Timeline.Pairs;
+	var Ids = Timeline.Ids;
+	var Ends = Timeline.Ends;
+	var Times = Timeline.Times;
+	if(Ids)
+	{
+		for(var i = 0; i < Ids.length; ++i)
+		{
+			Pairs[i] = -1;
+			var ID = Ids[i];
+			var match = Matching[ID];
+			if(match >= 0)
+			{
+				if(match > Ids.length || match < 0)
+					debugger;
+				Pairs[match] = i;
+				Pairs[i] = match;
+				if(match > i)
+					debugger;
+				Ends[match] = Times[i];
+				var Track = AddToTrack(Times[match], Ends[match], match);
+				Timeline.Positions[match] = Track;
+				delete Matching[ID];
+			}
+			else
+			{
+				if(HasMatchingName(i))
+				{
+					Matching[ID] = i;
+				}
+			}
+		}
+	}
+	// add any unclosed markers
+	for(let id in Matching)
+	{
+		let index = Matching[id];
+		let name = Timeline.Names[index];
+		if(HasMatchingName(index)) // only close if there is a matching name...
+		{
+			let StartTime = Times[index];
+			let EndTime = S.CaptureEndTime;
+			if(StartTime >= EndTime)
+			{
+				EndTime = EndTime + 42;
+				console.log("End marker after captureend time. this should not happen. adding 42");
+				debugger;
+			}
+
+			Ends[index] = S.CaptureEndTime;
+			let Track = AddToTrack(Times[index], Ends[index], index);
+			Timeline.Positions[index] = Track;
+		}
+	}
+}
+
+function Preprocess_S()
+{
+	console.log('preprocessing\n');
+	S.LodData = new Array();
+	S.CSwitchCache = {};
+	S.CSwitchOnlyThreads = [];
+	S.GroupNameWidth = 200;
+	S.TimerNameWidth = 200;
+	S.ThreadNameWidth = 150;
+	S.ThreadCategoryWidth = 150;
+
+	PreprocessCalculateAllTimers();
+	PreprocessFindFirstFrames();
+	PreprocessGatherLogTypes();
+
+	PreprocessGlobalArray();
+	PreprocessLogBarArray();
+	PreprocessLods();//kill
+	PreprocessMeta();//kill
+	PreprocessThreadColors(S);
+
+	PreprocessContextSwitchCache();
+	PreprocessWidths();
+
+	UpdateThreadLogAutoHide();
+
+	console.log('preprocessing done\n');
+	console.log("SS " + S.LodData.length);
+}
+function Preprocess()
+{
+	var ProfileModeOld = ProfileMode;
+	ProfileMode = 1;
+	ProfileModeClear();
+	ProfileEnter("Preprocess");
+	Preprocess_S();
+	UpdateReferenceTime();
+
+	ProfileLeave();
+	ProfileModeDump();
+	ProfileMode = ProfileModeOld;
+	PreprocessTimeline();
+	Initialized = 1;
+}
+
+function ToggleColumn(idx, isMeta)
+{
+	ColumnsEnabled[idx] = !ColumnsEnabled[idx];
+	UpdateColumnsMenu();
+	WriteCookie();
+	Invalidate = 0;
+}
+function UpdateColumnsMenu()
+{
+	var ulColumnMenu = document.getElementById('ColumnsSubMenu');
+	var Lis = ulColumnMenu.getElementsByTagName('li');
+	for(var i = 0; i < Lis.length; ++i)
+	{
+		if(ColumnsEnabled[i])
+		{
+			Lis[i].style['text-decoration'] = 'underline';
+		}
+		else
+		{
+			Lis[i].style['text-decoration'] = 'none';
+		}
+	}
+}
+
+function ResetColumnWidth()
+{
+	if(ColumnsWidth)
+	{
+		for(var i = 0; i < ColumnsWidth.length; ++i)
+		{
+			ColumnsWidth[i] = 0;
+		}
+	}
+}
+var Comp0 = new Date();
+var Comp1 = new Date();
+var Comp2 = new Date();
+var Comp3 = new Date();
+
+function SetGlobal(Name, Value)
+{
+	this[Name] = Value;
+}
+
+
+//compare todo:
+//	**Match threads
+//	**match tokens.
+//	**Calculate shared screen positions.
+//	**Invert second pass
+//	**fix hovertoken
+//	**fix range display
+// 	todo: isgpu
+//  todo: group numtimers.
+//	implement timer view
+
+function CompareFixup(S0, S1) // S0 is the reference
+{
+	var GroupRemap = Array(S1.GroupInfo.length);
+	var ThreadRemap = Array(S1.ThreadNames.length);
+	var TimerRemap = Array(S1.TimerInfo.length);
+	GroupRemapReverse = Array(S0.GroupInfo.length + S1.GroupInfo.length);
+	TimerRemapReverse = Array(S0.TimerInfo.length + S1.TimerInfo.length);
+	ThreadRemapReverse = Array(S0.ThreadNames.length + S1.ThreadNames.length);
+
+	for(var i = 0; i < GroupRemapReverse.length; ++i)
+		GroupRemapReverse[i] = -1;
+	for(var i = 0; i < TimerRemapReverse.length; ++i)
+		TimerRemapReverse[i] = -1;
+	for(var i = 0; i < ThreadRemapReverse.length; ++i)
+		ThreadRemapReverse[i] = -1;
+
+
+
+	// var dump = function(SS, str)
+	// {
+	// 	console.log(str);
+	// 	for(var i = 0; i < SS.GroupInfo.length; ++i)
+	// 	{
+	// 		console.log("G" + i + ":" + SS.GroupInfo[i].name);
+	// 	}
+	// 	for(var i = 0; i < SS.TimerInfo.length; ++i)
+	// 	{
+	// 		console.log("T" + i + ":" + SS.TimerInfo[i].name);
+	// 	}
+
+	// };
+	// dump(S0, "S0be4");
+	// dump(S1, "S1be4");
+
+	for(var i = 0; i < S1.GroupInfo.length; ++i)
+	{
+		var n = S1.GroupInfo[i].name;
+		var idx = S0.GroupInfo.findIndex(function(G){ return G.name == n; });
+		if(idx != -1)
+		{
+			GroupRemap[i] = idx;
+		}
+		else
+		{
+			GroupRemap[i] = S0.GroupInfo.length;
+			S0.GroupInfo.push(S1.GroupInfo[i]);
+		}
+		GroupRemapReverse[GroupRemap[i]] = i;
+	}
+	// for(var i = 0; i < S0.TimerInfo.length; ++i)
+	// {
+	// 	var n = S0.TimerInfo[i].name;
+	// 	console.log('OG ', n, ' idx ', i);
+	// }
+
+	for(var i = 0; i < S1.TimerInfo.length; ++i)
+	{
+		var TI = S1.TimerInfo[i];
+		var n = TI.name;
+		var g = GroupRemap[TI.group];
+		var idx = S0.TimerInfo.findIndex(function(T){ return T.name == n && T.group == g; });
+		TI.group = GroupRemap[TI.group];
+		if(idx != -1)
+		{
+			TimerRemap[i] = idx;
+		}
+		else
+		{
+			console.log('added timer ' + TI.name + ' idx ' + S0.TimerInfo.length);
+			TimerRemap[i] = S0.TimerInfo.length;
+			TI.id = S0.TimerInfo.length;
+			S0.TimerInfo.push(TI);
+		}
+		TimerRemapReverse[TimerRemap[i]] = i;
+	}
+
+	var NumThreads = S0.ThreadNames.length;
+
+
+	for(var i = 0; i < S1.ThreadNames.length; ++i)
+	{
+		var n = S1.ThreadNames[i];
+		var idx = S0.ThreadNames.indexOf(n);
+		if(idx != -1)
+		{
+			ThreadRemap[i] = idx;
+		}
+		else
+		{
+			ThreadRemap[i] = S0.ThreadNames.length;
+			S0.ThreadNames.push(n);
+			NumThreads++;
+		}
+		ThreadRemapReverse[ThreadRemap[i]] = i;
+	}
+
+
+	PreprocessThreadColors(S0);
+	PreprocessThreadColors(S1);
+
+	var Fix = function(a, r)
+	{
+		for(var i in a)
+		{
+			a[i] = r[a[i]];
+		}
+	};
+	var FixArray = function(a, s)
+	{
+		if(!s)
+			return;
+		for(var i = 0; i < a.length; ++i)
+		{
+			if(!a[i])
+				a[i] = [];
+		}
+		while(a.length != s)
+			a.push([]);
+	};
+
+	for(var i in S0.Frames)
+	{
+		var F = S0.Frames[i];
+		FixArray(F.ti, NumThreads);
+		FixArray(F.ts, NumThreads);
+		FixArray(F.tt, NumThreads);
+	}
+
+	for(var i in S1.Frames)
+	{
+		var F = S1.Frames[i];
+		var ti = F.ti;
+		var ts = F.ts;
+		var tt = F.tt;
+
+		F.ti = new Array(NumThreads);
+		F.ts = new Array(NumThreads);
+		F.tt = new Array(NumThreads);
+
+		for(var j in ti)
+		{
+
+			Fix(ti[j], TimerRemap);
+			F.ti[ThreadRemap[j]] = ti[j];
+		}
+		FixArray(F.ti, NumThreads);
+		for(var i = 0; i < NumThreads; ++i)
+		{
+			if(!F.ti[i])
+				debugger;
+		}
+		for(var j in ts)
+		{
+			F.ts[ThreadRemap[j]] = ts[j];
+		}
+		FixArray(F.ts, NumThreads);
+		for(var i = 0; i < NumThreads; ++i)
+		{
+			if(!F.ts[i])
+				debugger;
+		}
+		for(var j in tt)
+		{
+			F.tt[ThreadRemap[j]] = tt[j];
+		}
+		FixArray(F.tt, NumThreads);
+
+		for(var i = 0; i < NumThreads; ++i)
+		{
+			if(!F.tt[i])
+				debugger;
+		}
+		//assert length is the same
+		if(F.tt.length != S0.Frames[0].tt.length)
+		{
+			debugger;
+		}
+		if(F.ti.length != S0.Frames[0].ti.length)
+		{
+			debugger;
+		}
+		if(F.ts.length != S0.Frames[0].ts.length)
+		{
+			debugger;
+		}
+		// console.log('log ' + i +  ':', F.ts.length, ':', F.ti.length, ':', F.tt.length);
+	}
+
+	var NewTimerInfo = Array(S0.TimerInfo.length);
+	for(var i = 0; i < S1.TimerInfo.length; ++i)
+	{
+		let xx = TimerRemap[i];
+		NewTimerInfo[xx] = S1.TimerInfo[i];
+		NewTimerInfo[xx].id = xx;
+		NewTimerInfo[xx].group = S0.TimerInfo[xx].group;
+
+		if(NewTimerInfo[xx].id != S0.TimerInfo[xx].id)
+		{
+			debugger;
+		}
+		if(NewTimerInfo[xx].group != S0.TimerInfo[xx].group)
+		{
+			debugger;
+		}
+
+	}
+	for(var i = 0; i < NewTimerInfo.length; ++i)
+	{
+		if(!NewTimerInfo[i])
+		{
+			NewTimerInfo[i] = CloneTimer(S0.TimerInfo[i]);
+			NewTimerInfo[i].id = i;
+			if(NewTimerInfo[i].id != S0.TimerInfo[i].id)
+			{
+				debugger;
+			}
+			if(NewTimerInfo[i].group != S0.TimerInfo[i].group)
+			{
+				debugger;
+			}
+
+		}
+	}
+	S1.TimerInfo = NewTimerInfo;
+	var NewGroupInfo = Array(S0.GroupInfo.length);
+
+	for(let i = 0; i < S1.GroupInfo.length; ++i)
+	{
+		let xx = GroupRemap[i];
+		NewGroupInfo[xx] = S1.GroupInfo[i];
+		NewGroupInfo[xx].id = xx;
+	}
+	for(let i = 0; i < NewGroupInfo.length; ++i)
+	{
+		if(!NewGroupInfo[i])
+		{
+			NewGroupInfo[i] = CloneGroup(S0.GroupInfo[i]);
+			NewGroupInfo[i].id = i;
+		}
+	}
+	S1.GroupInfo = NewGroupInfo;
+	for(let i = 0; i < S1.GroupInfo.length; ++i)
+	{
+		if(S1.GroupInfo[i].id != i)
+			debugger;
+		if(S0.GroupInfo[i].id != i)
+			debugger;
+	}
+
+	//debugging:
+	if(S0.TimerInfo.length != S1.TimerInfo.length)
+		debugger;
+	for(let i = 0; i < S0.TimerInfo.length; ++i)
+	{
+		let t0 = S0.TimerInfo[i];
+		let t1 = S1.TimerInfo[i];
+		if(t0.id != t1.id)
+			debugger;
+		if(t0.name != t1.name)
+			debugger;
+		if(t0.group != t1.group)
+			debugger;
+	}
+
+	if(S0.GroupInfo.length != S1.GroupInfo.length)
+		debugger;
+	for(let i = 0; i < S0.GroupInfo.length; ++i)
+	{
+		let t0 = S0.GroupInfo[i];
+		let t1 = S1.GroupInfo[i];
+		if(t0.id != t1.id)
+			debugger;
+		if(t0.name != t1.name)
+			debugger;
+	}
+}
+
+function ReadHtmlFile(File)
+{
+	if (!File)
+	{
+		return;
+	}
+	var Reader = new FileReader();
+	Reader.onload = function(e) {
+		if(!ParseCompareData(e.target.result))
+		{
+			ShowFlashMessage("Failed to parse file", 50);
+		}
+	};
+	Reader.onprogress = function(e)
+	{
+		var m = e.loaded + ":" + e.total + " :: " + e.lengthComputable;
+		console.log(m);
+	};
+	Reader.readAsText(File);
+}
+
+function ReadHtmlFileHandler(e)
+{
+	ReadHtmlFile(e.target.files[0]);
+}
+
+function ParseCompareData(Data)
+{
+	S.AA = "Original";
+	Comp1 = new Date();
+
+	var idxbegin = Data.indexOf("//EBEGIN");
+	if(idxbegin == -1)
+		return false;
+	idxbegin += "//EBEGIN".length + 1;
+	var idxend = Data.indexOf("//EEND", idxbegin);
+	if(idxend == -1)
+		return false;
+
+	Comp2 = new Date();
+	var SOriginal = S;
+	S = {};
+
+	var idx = idxbegin;
+	while(idx < idxend)
+	{
+		var idx0 = Data.indexOf('\n', idx);
+		var s = Data.substring(idx, idx0);
+		// console.log(s);
+		eval(s);
+		idx = idx0+1;
+	}
+
+	S.AA = "Parsed";
+	var SParsed = S;   //note: the calls to eval, will make a new "S" in local scope.
+	SetGlobal("S", S); //Set global S to point to new object, while its preprocessed
+	Comp3 = new Date();
+
+
+	CompareFixup(SOriginal, SParsed);
+	Preprocess_S();
+
+	var MaxStack2 = SParsed.MaxStack;
+
+	var Comp4 = new Date();
+	SetGlobal("S2", SParsed);
+	SetGlobal("S", SOriginal);
+
+	Preprocess_S(); //since indices are rebased, a repreprocessing is needed.
+
+	SOriginal.MaxStack2 = SParsed.MaxStack;
+	SParsed.MaxStack2 = SOriginal.MaxStack;
+	SOriginal.SecondActive = 1;
+
+
+	ThreadOrderSort();
+
+	console.log('file loaded ' + idxbegin + ' ' + idxend );
+	console.log('time ' + (Comp1 - Comp0));
+	console.log('time ' + (Comp2 - Comp1));
+	console.log('time ' + (Comp3 - Comp2).toFixed(2));
+	console.log('time ' + (Comp4 - Comp3).toFixed(2));
+	document.getElementById('file-input').removeEventListener('change', ReadHtmlFileHandler, false);
+	let fname = document.getElementById('file-input').value;
+	let index = 1+Math.max(fname.lastIndexOf('/'), fname.lastIndexOf('\\'));
+	if(index < fname.length)
+		fname = fname.substring(index);
+	let CompStr = 'Compare [' + fname + ']';
+	RequestRedraw();
+	return true;
+}
+
+function ComparePrompt()
+{
+	document.getElementById('file-input').addEventListener('change', ReadHtmlFileHandler, false);
+	document.getElementById('file-input').click();
+}
+
+
+// magic from stack-overflow somewhere..
+function WindowDragEnter(e)
+{
+    LastDropTarget = e.target;
+    document.querySelector(".dropzone").style.visibility = "";
+    document.querySelector(".dropzone").style.opacity = 1;
+};
+
+function WindowDragLeave(e)
+{
+    if(e.target === LastDropTarget || e.target === document)
+    {
+        document.querySelector(".dropzone").style.visibility = "hidden";
+        document.querySelector(".dropzone").style.opacity = 0;
+    }
+};
+function DropHandler(ev)
+{
+	document.querySelector(".dropzone").style.visibility = "hidden";
+	document.querySelector(".dropzone").style.opacity = 0;
+	LastDropTarget = null;
+
+	if(ev.dataTransfer.files.length > 0)
+	{
+		let File = ev.dataTransfer.files[0];
+		let Name = File.name
+		let ExtMatch = Name.match(/\.[0-9a-zA-Z]+$/);
+		let Ext = ExtMatch ? ExtMatch[0] : "";
+		if(Ext.toLowerCase() == ".html")
+		{
+			ReadHtmlFile(File);
+		}
+		else
+		{
+			window.alert("Not a .html file!\n" + Name);
+		}
+	}
+  	ev.preventDefault();	
+}
+
+function DragOverHandler(ev)
+{
+  ev.preventDefault();	
+}
+
+var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x
+
+CanvasDetailedView.addEventListener('mousemove', MouseMove, false);
+CanvasDetailedView.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
+CanvasDetailedView.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
+CanvasDetailedView.addEventListener('mouseout', MouseOut);
+CanvasDetailedView.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
+CanvasDetailedView.addEventListener(mousewheelevt, MouseWheel, false);
+CanvasHistory.addEventListener('mousemove', MouseMove);
+CanvasHistory.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
+CanvasHistory.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
+CanvasHistory.addEventListener('mouseout', MouseOut);
+CanvasHistory.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
+CanvasHistory.addEventListener(mousewheelevt, MouseWheel, false);
+CanvasMenu.addEventListener('mousemove', MouseMove);
+CanvasMenu.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
+CanvasMenu.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
+CanvasMenu.addEventListener('mouseout', MouseOut);
+CanvasMenu.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
+CanvasMenu.addEventListener(mousewheelevt, MouseWheel, false);
+FilterInputTimer.addEventListener('keyup', FilterKeyUp);
+FilterInputGroup.addEventListener('keyup', FilterKeyUp);
+
+window.addEventListener('keydown', KeyDown);
+window.addEventListener('keyup', KeyUp);
+window.addEventListener('resize', ResizeCanvas, false);
+window.addEventListener("dragenter", WindowDragEnter);
+window.addEventListener("dragleave", WindowDragLeave);
+
+
+InitGroups();
+ReadCookie();
+MeasureFont();
+ThreadOrderSort();
+InitOrderArrays();
+InitMenu();
+InitFrameInfo();
+ResizeCanvas();
+Preprocess();
+OnPageReady();
+Draw(1);
+
+
+</script>
+</body>
+</html>
\ No newline at end of file
--- /dev/null
+++ microprofile-4.0+dfsg/src/microprofilelive.html
@@ -0,0 +1,7804 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<title>MicroProfile Live</title>
+<style>
+/* about css: http://bit.ly/1eMQ42U */
+body {margin: 0px;padding: 0px; font: 12px Courier New;background-color:#343434; color:white;overflow:hidden;}
+ul {list-style-type: none;margin: 0;padding: 0;}
+li{display: inline; float:left;border:5px; position:relative;text-align:center;}
+a {
+    float:left;
+    text-decoration:none;
+    display: inline;
+    text-align: center;
+	padding:5px;
+	padding-bottom:0px;
+	padding-top:0px;
+    color: #FFFFFF;
+    background-color: #343434;
+}
+a:hover, a:active{
+	background-color: #000000;
+}
+
+ul ul {
+    position:absolute;
+    left:0;
+    top:100%;
+    margin-left:-999em;
+}
+li:hover ul {
+    margin-left:0;
+    margin-right:0;
+}
+ul li ul{ display:block;float:none;width:100%;}
+ul li ul li{ display:block;float:none;width:100%;}
+li li a{ display:block;float:none;width:100%;text-align:left;}
+#nav li:hover div {margin-left:0;}
+.dropzone {display:flex;justify-content:center;align-items:center;font-size:50px;position: fixed; top: 0; left: 0; z-index: 9999999999; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);transition: visibility 175ms, opacity 175ms;}
+.help {position:absolute;z-index:5;text-align:left;padding:2px;margin-left:-999em;background-color: #313131;width:300px;}
+.helpstart {position:absolute;z-index:5;text-align:left;padding:2px;background-color: #313131;width:300px;display:none}
+.root {z-index:1;position:absolute;top:0px;left:0px;}
+.filterinputsearchdiv{position:fixed; background-color: #313131;display:none;}
+.filterinputsearch{width:100px;}
+</style>
+</head>
+<body style="">
+<div style="visibility:hidden; opacity:0" class="dropzone" ondrop="DropHandler(event);" ondragover="DragOverHandler(event);">drop .csv files to view CSV data</div>
+<div class="filterinputsearchdiv" id="FilterInputDiv">Filter<br><input type="text" id="FilterInput" class="filterinputsearch"></div>
+<div class="helpstart" id="helpwindow" style="left:20px;top:20px">
+History View:<br>
+Right Click + Drag : Select Region<br>
+Click + Drag: Move Selection<br>
+Click Frame : Center on frame<br>
+<hr>
+Main View:<br>
+space: Freeze capturing<br>
+x : Toggle View<br>
+/ : Rotate connection port % 3<br>
+Ctrl + Drag: Pan<br>
+Click + Drag: Pan<br>
+Enter: Capture selection/Next N Frames
+<hr>
+<table style="width:100%">
+<tr>
+<td width="50%" align="left"><a href='javascript:void(0)' onclick="ShowHelp(0);">Close</a></td>
+</tr>
+</table>
+</div>
+<canvas id="DetailedView" height="100%" style="background-color:#343434;margin:0px;padding:0px;"></canvas>
+<script>
+"use strict"
+
+var FRAME_HISTORY_COLOR_CPU = '#ff7f27';
+var FRAME_HISTORY_COLOR_GPU = '#ffffff';
+
+var Settings = {};
+var Cookie = {};
+
+const PERCENTILE_SAMPLES = 1000;
+
+var HistoryHeight = 100;
+var CanvasDetailedView = document.getElementById('DetailedView');
+var CanvasDetailedOffscreen = document.createElement('canvas');
+var FilterInput = document.getElementById('FilterInput');
+var FilterInputDiv = document.getElementById('FilterInputDiv');
+var FilterInputDivPos = {"x":-1,"y":-1,"w":-1,"h":-1};
+var FilterInputValueLast = '';
+
+var CanvasArray0 = [];
+var CanvasArray1 = [];
+var Views = [];
+
+var ViewIndex = 0;
+
+var nWidth = CanvasDetailedView.width;
+var nHeight = CanvasDetailedView.height;
+var nBackColors = ['#292929', '#343434' ];
+var nBackColorsDark = ['#292929', '#272727' ];
+var nBackColorOffset = '#404040';
+var FontHeight = 10;
+var FontHeightLarge = 12;
+var FontWidth = 1;
+var FontAscent = 3; //Set manually
+var Font = 'Bold ' + FontHeight + 'px Courier New';
+var FontLarge = 'Bold ' + FontHeightLarge + 'px Courier New';
+var FontFlash = 'Bold ' + 35 + 'px Courier New';
+var BoxHeight = FontHeight + 2;
+var MouseX = 0;
+var MouseY = 0;
+var MouseReleased = false;
+var MouseMoveTime = new Date();
+
+var nBarsWidth = 80;
+var nOffsetBarsX = 0;
+var nOffsetBarsY = 0;
+var nOffsetCountersY = 0;
+var nOffsetMenuTimers = 0;
+var nOffsetMenuGroup = 0;
+var nOffsetMenuFunctions = 0;
+var nOffsetMenuModules = 0;
+var nOffsetMenuPatched = 0;
+
+var nHoverCounter = -1;
+
+var MouseDragOff = 0;
+var MouseDragDown = 1;
+var MouseDragUp = 2;
+var MouseDragMove = 3;
+var MouseDragState = MouseDragOff;
+var MouseDragTarget = 0;
+var MouseDragButton = 0;
+var MouseDragKeyShift = 0;
+var MouseDragKeyCtrl = 0;
+var MouseDragX = 0;
+var MouseDragY = 0;
+var MouseDragXLast = 0;
+var MouseDragYLast = 0;
+var MouseDragXStart = 0;
+var MouseDragYStart = 0;
+
+var MouseDragActiveXStart = 0;
+var MouseDragActiveXEnd = -1;
+var MouseInCaptureButton = 0;
+
+var ToolTipCallback = null;
+
+var DPR = 0;
+var C_HUGE = 1e10;
+
+var ActivePreset = "Default";
+var ActivePresetRO = 0;
+var PresetPending = 0;
+var Presets = [];
+var PresetsCache = {};
+var ReadOnlyPresets = [];
+var ReadOnlyPresetsCache = {};
+
+Settings.SubGraphSettings = {};
+Settings.ReferenceTime = 50.0;
+var ReferencePresets = [5.0, 10.0, 15.0, 20, 30, 33.33, 50, 66.66,100.0,250.0,500,1000.0];
+var PercentilePresets = [0.0, 1.0, 5.0, 10.0, 50.0, 75.0, 99.0];
+var ReferenceTimeTweak = -1;
+var PercentileTweak = -1;
+
+Settings.TargetTime = 30;
+var TargetTimeTweak = -1;
+
+
+var AggregateFrames = 60;
+Settings.AggregateFrames = 60;
+var AggregatePresets = [0, 10,20,30,60,90,120,500];
+var AggregateHistorySize = 5;
+var AggregateTweak = -1;
+var AggregateCurrent = 0;
+
+var AutoCaptureCooldown = -1;
+var AutoCaptureEnabled = 0;
+var AutoCaptureDefaultThreshold = 66;
+Settings.AutoCaptureTheshold = AutoCaptureDefaultThreshold;
+Settings.AutoCaptureRepeat = 1;
+var AutoCaptureThesholdPresets = [1,3,5,10,15,30,50,66,90,100,250,500,1000];
+var AutoCaptureRepeatPresets = [1,2,3,4,5,6,7,8,9,10, 25, 50, 100];
+var AutoCaptureTweak = -1;
+var AutoCaptureRepeatTweak = -1;
+var AutoCaptureSourceTweak = -1;
+var AutoCaptureSourceIndex = -1;
+
+var CaptureFramesDefault = 30;
+Settings.CaptureFrames = CaptureFramesDefault;
+Settings.CaptureDelay = 0;
+var CaptureFramesPresets = [5,10,15,30,50,66,90,100];
+var CaptureDelayPresets = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
+var CaptureTweak = -1;
+var CaptureDelayTweak = -1;
+
+var CaptureTriggerTime = null;
+var CaptureTriggerTimeType = 0;
+var CaptureTriggerDelta = 0;
+
+let LastDropTarget = null;
+
+
+
+var ProfileData = {};
+var ProfileStackTime = [];
+var ProfileStackName = [];
+var ProfileMode = 0;
+var ProfileRedraw0 = 0;
+var ProfileRedraw1 = 0;
+var ProfileRedraw2 = 0;
+var ProfileFps = 0;
+var ProfileMs = 0;
+var ProfileFpsAggr = 0;
+var ProfileFpsCount = 0;
+var ProfileLastTimeStamp = new Date();
+var PlotfArray = new Array();
+
+var ConnectionStr = ["\\", "|", "/", "-" ];
+var ConnectionIdx = 0;
+var EnabledArray = [];
+
+
+var FrameData = {};
+var FRAME_COUNT = 256;
+var FramePending = 0;
+
+var WSConnected = 0;
+var WSIsOpen = 0;
+var WSSeconds = 0;
+var WSFail = 0;
+var WS;
+var WSHost = location.hostname ? location.hostname : "localhost";
+var WSPort = location.port ? location.port : 1338;
+var WSPath;
+
+var CaptureButtonX = 0;
+var CaptureButtonY = 0;
+var GroupsEnabled = 0;
+var TimersEnabled = 0;
+
+var TimersActiveOnly = 0;
+
+
+var MSG_TIMER_TREE = 1;
+var MSG_ENABLED = 2;
+var MSG_FRAME = 3;
+var MSG_LOADSETTINGS = 4;
+var MSG_PRESETS = 5;
+var MSG_CURRENTSETTINGS = 6;
+var MSG_COUNTERS = 7;
+var MSG_FUNCTION_RESULTS = 8;
+var MSG_INACTIVE_FRAME = 9;
+var MSG_FUNCTION_NAMES = 10;
+var MSG_INSTRUMENT_ERROR = 11;
+// var MSG_MODULE_NAME = 12;
+
+
+var TYPE_NONE = 0;
+var TYPE_TIMER = 1;
+var TYPE_GROUP = 2;
+var TYPE_CATEGORY = 3;
+var TYPE_SETTING = 4;
+var TYPE_COUNTER = 5;
+
+
+var WSSend = 0;
+var WSReceive = 0;
+var WSSendBytes = 0;
+var WSReceiveBytes = 0;
+var WSOpenTime = 0;
+
+
+var TimerArray = [];
+var CounterArray = [];
+var Empty = {"id":0, "w":0, "depth":0, "sibling":-1,"parent":-1,"firstchild":-1};
+var WidthArray = [];
+var FunctionQueryArray = [];
+var FunctionQueryPending = null;
+var FunctionQueryLastRequest = 0;
+var FunctionQueryReceived = 0;
+var WidthTree = 0;
+Settings.ViewActive = 0;
+Settings.ViewCompressed = 0;
+Settings.AllowHighDPI = 1;
+var ViewNames = ["Graph", "Graph", "Graph", "Bars", "Bars", "Bars", "Counters"];
+var ViewNames2 = ["[split]", "[percentile]","[group/thread]","[table]", "[all]", "[single]", ""];
+
+var VIEW_GRAPH_SPLIT = 0;
+// var VIEW_GRAPH = 1;
+var VIEW_GRAPH_PERCENTILE = 1;
+var VIEW_GRAPH_THREAD_GROUP = 2;
+var VIEW_BAR = 3;
+var VIEW_BAR_ALL = 4;
+var VIEW_BAR_SINGLE = 5;
+var VIEW_COUNTERS = 6;
+var VIEW_SIZE = 7;
+
+var GRAPH_ALPHA = 0.5;
+
+
+// Settings.FancyGraph = 1;
+Settings.AutomaticReference = 1;
+Cookie.CodeReportMode = 0; // 0: prompt, 1:always send, 2: never send, never prompt
+
+
+var ReferenceHistory = 0;
+var ReferenceGraph = 0;
+var ReferenceBar = 0;
+var ReferenceHistoryAutomatic = 0;
+var ReferenceGraphAutomatic = 0;
+var ReferenceGraphAutomaticGroup = 0;
+var ReferenceBarAutomatic = 0;
+
+var SingleTimerBars = 0;
+var History;
+var MainView;
+var X7Views;
+var X7LegendView;
+var X7BarColumnRemap = [0,1,2,3,4,5,6];
+var X7BarColumnMask = -1;
+var X7LegendOffset = 25;
+var X7BarLastView = -1;
+var X7BarFirstView = -1;
+
+
+var ViewBarMaxMsTextLength = 0;
+
+Settings.SortColumnOrderFlip = 0;
+Settings.SortColumnName = "";
+var SortColumnMouseOverNext = "";
+
+
+var KeyShiftDown = 0;
+var KeyCtrlDown = 0;
+
+var IsFrozen = 0;
+
+var PresetToLoad;
+var PresetToLoadRO = 0;
+var HelpFade;
+
+
+TimerArray.push(Empty); // 0 is root of tree
+
+var StrTime = "Time";
+var StrExclusive = "Excl Time";
+var StrGroup = "Group";
+var StrThread = "Thread";
+var StrTimer = "Timer";
+var StrAverage = "Average";
+var StrMax = "Max";
+var StrTotal = "Total";
+var StrExclTotal = "Excl Total";
+var StrMin = "Min";
+var StrSpike = "Spike%";
+var StrCallAverage = "Call Average";
+var StrCount = "Count";
+var StrExclAverage = "Excl Average";
+var StrExclMax = "Excl Max";
+var StrExclMin = "Excl Max";
+var StrCallExclAverage = "Call Excl Avg";
+
+
+var CounterNameWidth = 100;
+var CounterValueWidth = 100;
+var CounterLimitWidth = 100;
+
+var FormatCounterDefault = 0;
+var FormatCounterBytes = 1;
+var FormatCounterBytesExt = ["b","kb","mb","gb","tb","pb","eb","zb","yb"];
+
+var BarColumnNamesTable = [StrTime, StrExclusive, StrAverage, StrMax, StrMin, StrTotal, StrExclAverage, StrExclMax, StrExclTotal, StrSpike, StrCallAverage, StrCallExclAverage, StrCount];
+var BarColumnNamesMulti = [StrTime, StrAverage, StrMax, StrMin, StrExclAverage, StrExclMax, StrExclMin];
+var BarColumnNamesSingle = [StrAverage, StrMax, StrMin, StrExclAverage, StrExclMax, StrExclMin, StrCallAverage];
+
+// var SYMBOLSTATE_DEFAULT = 0;
+// var SYMBOLSTATE_LOADING = 1;
+// var SYMBOLSTATE_DONE = 2;
+
+
+var SymbolState;
+var ModuleState = [];
+
+var FunctionsInstrumented = [];
+var FunctionsInstrumentedUnmangled = [];
+var FunctionsInstrumentedModule = [];
+var PopupsAllowed = 0;
+var PopupsFailed = 0;
+var PopupTestPending = 0;
+
+var ThreadInfo = {};
+
+/**
+ * From https://gist.github.com/vahidk/05184faf3d92a0aa1b46aeaa93b07786
+ *
+ * @param {number} h
+ * @param {number} s
+ * @param {number} l
+ */
+function ConvertHslToRGB(h, s, l) {
+	const c = (1 - Math.abs(2 * l - 1)) * s;
+	const hp = h / 60.0;
+	const x = c * (1 - Math.abs((hp % 2) - 1));
+	let rgb1;
+	if (isNaN(h)) rgb1 = [0, 0, 0];
+	else if (hp <= 1) rgb1 = [c, x, 0];
+	else if (hp <= 2) rgb1 = [x, c, 0];
+	else if (hp <= 3) rgb1 = [0, c, x];
+	else if (hp <= 4) rgb1 = [0, x, c];
+	else if (hp <= 5) rgb1 = [x, 0, c];
+	else if (hp <= 6) rgb1 = [c, 0, x];
+	const m = l - c * 0.5;
+	const color = (Math.round(255 * (rgb1[0] + m)) << 16)
+		| (Math.round(255 * (rgb1[1] + m)) << 8)
+		| Math.round(255 * (rgb1[2] + m));
+	return ("000000" + color.toString(16)).slice(-6);
+}
+
+
+function GetBarColumnNames()
+{
+	if(Settings.ViewActive == VIEW_BAR_ALL)
+	{
+		return BarColumnNamesMulti;
+	}
+	else if(Settings.ViewActive == VIEW_BAR_SINGLE)
+	{
+		return BarColumnNamesSingle;
+	}
+	else
+	{
+		return BarColumnNamesTable;
+	}
+}
+function GetBarColumnEnabled()
+{
+	if(Settings.ViewActive == VIEW_BAR_ALL)
+	{
+		return Settings.BarColumnEnabledMulti;
+	}
+	else if(Settings.ViewActive == VIEW_BAR_SINGLE)
+	{
+		return Settings.BarColumnEnabledSingle;
+	}
+	else
+	{
+		return Settings.BarColumnEnabledTable;
+	}
+}
+
+Settings.BarColumnEnabledTable = new Array(BarColumnNamesTable.length);
+Settings.BarColumnEnabledSingle = new Array(BarColumnNamesSingle.length);
+Settings.BarColumnEnabledMulti = new Array(BarColumnNamesMulti.length);
+var ColumnsWidth = new Array(BarColumnNamesTable.length);
+function ClearEnabled(E)
+{
+	for(var i = 0; i < E.length; ++i)
+	{
+		E[i] = 1;
+		ColumnsWidth[i] = 10;
+	}
+}
+ClearEnabled(Settings.BarColumnEnabledTable);
+ClearEnabled(Settings.BarColumnEnabledSingle);
+ClearEnabled(Settings.BarColumnEnabledMulti);
+
+function Plotf(str)
+{
+	PlotfArray.push(str);
+}
+function PlotfClear()
+{
+	PlotfArray = new Array();
+}
+
+function ProfileModeClear()
+{
+	if(ProfileMode)
+	{
+		for(var idx in ProfileData)
+		{
+			if(idx == "Plot")
+				continue;
+			var Timer = ProfileData[idx];
+			Timer.Count = 0;
+			Timer.Time = 0;
+		}
+
+		// ProfileData = new Object();
+		ProfileStackTime = new Array();
+		ProfileStackName = new Array();
+	}
+}
+function ProfileEnter(Name)
+{
+	if(ProfileMode)
+	{
+		ProfileStackTime.push(performance.now());
+		ProfileStackName.push(Name);
+	}
+}
+function ProfileLeave()
+{
+	if(ProfileMode)
+	{
+		var Time = performance.now();
+		var Delta = Time - ProfileStackTime.pop();
+		var Name = ProfileStackName.pop();
+		var Obj = ProfileData[Name];
+		if(!Obj)
+		{
+			Obj = new Object();
+			Obj.Count = 0;
+			Obj.Name = Name;
+			Obj.Time = 0;
+			Obj.AggrCount = 0;
+			Obj.AggrTime = 0;
+			Obj.AggrMax = 0;
+			Obj.AvgTime = 0;
+			Obj.MaxTime = 0;
+			Obj.TotalTime = 0;
+			ProfileData[Name] = Obj;
+		}
+		Obj.Time += Delta;
+		Obj.Count += 1;
+	}
+}
+
+function ProfilePlot(s)
+{
+	if(ProfileMode)
+	{
+		var A = ProfileData.Plot;
+		if(!A)
+		{
+			ProfileData.Plot = Array();
+			A = ProfileData.Plot;
+		}
+		if(A.length<10)
+		{
+			A.push(s);
+		}
+	}
+}
+function ProfileModeDump()
+{
+	for(var idx in ProfileData)
+	{
+		var Timer = ProfileData[idx];
+		console.log(Timer.Name + " " + Timer.Time + "ms " + Timer.Count);
+	}
+
+}
+function ProfileModeDraw(Canvas)
+{
+	if(ProfileMode)
+	{
+		ProfileFpsCount ++ ;
+		var AggrFrames = 60;
+		var StringArray = [];
+		function FormatTime(f)
+		{
+			return ("             " + f.toFixed(2)).slice(-12);
+		}
+		function FormatStr(t, count, avg, max, total)
+		{
+			var str = FormatTime(t) + "ms " + ("        #" + count).slice(-8) +
+			"" + FormatTime(avg) + "ms " + FormatTime(max) + "ms " + FormatTime(total) + "ms";
+			return str;
+		}
+		StringArray.push("");
+		StringArray.push("time    count         avg            max       total/" +  AggrFrames + "  ");
+
+		for(var idx in ProfileData)
+		{
+			if(idx == "Plot")
+				continue;
+			var Timer = ProfileData[idx];
+			Timer.AggrCount += Timer.Count;
+			Timer.AggrTime += Timer.Time;
+			Timer.AggrMax = Math.max(Timer.AggrMax, Timer.Time);
+			if(ProfileFpsCount == AggrFrames)
+			{
+				Timer.AvgTime = Timer.AggrTime / AggrFrames;
+				Timer.MaxTime = Timer.AggrMax;
+				Timer.TotalTime = Timer.AggrTime;
+				Timer.AggrCount = 0;
+				Timer.AggrTime = 0;
+				Timer.AggrMax = 0;
+			}
+			StringArray.push(Timer.Name);
+			StringArray.push(FormatStr(Timer.Time, Timer.Count, Timer.AvgTime, Timer.MaxTime, Timer.TotalTime));
+		}
+		var Time = new Date();
+		var Delta = Time - ProfileLastTimeStamp;
+		ProfileLastTimeStamp = Time;
+		StringArray.push("Frame Delta");
+		StringArray.push(Delta + "ms");
+		{
+			ProfileFpsAggr += Delta;
+
+			if(ProfileFpsCount == AggrFrames)
+			{
+				ProfileMs = ProfileFpsAggr / AggrFrames;
+				ProfileFps = 1000 / (ProfileFpsAggr / AggrFrames);
+				ProfileFpsAggr = 0;
+				ProfileFpsCount = 0;
+			}
+			StringArray.push("Avg FPS");
+			StringArray.push("" + ProfileFps.toFixed(2));
+			StringArray.push("Avg MS");
+			StringArray.push("" + ProfileMs.toFixed(2));
+		}
+		for(var i = 0; i < ProfileData.Plot; ++i)
+		{
+			StringArray.push("");
+			StringArray.push(ProfileData.Plot[i]);
+		}
+		ProfileData.Plot = Array();
+		DrawToolTip(StringArray, Canvas, 0, 200);
+	}
+}
+
+
+
+function MeasureFont()
+{
+	var context = CanvasDetailedView.getContext('2d');
+	context.font = Font;
+	FontWidth = context.measureText('W').width;
+
+}
+function ResizeCanvasDPR(w, h, c)
+{
+	DPR = Settings.AllowHighDPI ? window.devicePixelRatio : 0;
+	if(DPR)
+	{
+		c.style.width = w + 'px';
+		c.style.height = h + 'px';
+		c.width = w * DPR;
+		c.height = h * DPR;
+		c.getContext('2d').scale(DPR,DPR);
+	}
+	else
+	{
+		DPR = 1;
+		c.width = w;
+		c.height = h;
+	}
+
+}
+
+function ResizeCanvasDPR2(w, h, c)
+{
+	DPR = window.devicePixelRatio;
+	if(DPR)
+	{
+		c.style.width = w + 'px';
+		c.style.height = h + 'px';
+		c.width = w * DPR;
+		c.height = h * DPR;
+		c.getContext('2d').scale(DPR,DPR);
+	}
+	else
+	{
+		c.width = w;
+		c.height = h;
+	}
+
+}
+function ResizeView(View, x, y, w, h)
+{
+	View.x = x;
+	View.y = y;
+	View.w = w;
+	View.h = h;
+	var c0 = View.Canvas[0];
+	var c1 = View.Canvas[1];
+	ResizeCanvasDPR(w, h, c0);
+	ResizeCanvasDPR(w, h, c1);
+	c0.getContext('2d').clearRect(0, 0, w, h);
+	c1.getContext('2d').clearRect(0, 0, w, h);
+	View.OffscreenData[0] = c0.getContext('2d').getImageData(0, 0, c0.width, c0.height);
+	View.OffscreenData[1] = c1.getContext('2d').getImageData(0, 0, c1.width, c1.height);
+
+}
+function CreateView(x, y, w, h, name, DisplayFunc, visible, index)
+{
+	var idx = Views.length;
+	var c0 = CanvasArray0[idx];
+	var c1 = CanvasArray1[idx];
+	if(!c0)
+	{
+		c0 = document.createElement('canvas');
+		CanvasArray0[idx] = c0;
+	}
+	if(!c1)
+	{
+		c1 = document.createElement('canvas');
+		CanvasArray1[idx] = c1;
+	}
+	var View = {};
+	View.x = x;
+	View.y = y;
+	View.w = w;
+	View.h = h;
+	View.Canvas = [c0, c1];
+	View.OffscreenData = [null, null];
+	View.visible = visible;
+	View.index = index;
+	ResizeCanvasDPR(w, h, c0);
+	ResizeCanvasDPR(w, h, c1);
+
+	c0.getContext('2d').clearRect(0, 0, w, h);
+	c1.getContext('2d').clearRect(0, 0, w, h);
+	View.OffscreenData[0] = c0.getContext('2d').getImageData(0, 0, c0.width, c0.height);
+	View.OffscreenData[1] = c1.getContext('2d').getImageData(0, 0, c1.width, c1.height);
+	View.BackBuffer = 0;
+	View.DisplayFunc = DisplayFunc;
+	Views.push(View);
+	return View;
+}
+
+function CreateViews(Width, Height, ViewCompressed)
+{
+	Views = [];
+	var HistoryH = ViewCompressed ? 0 : HistoryHeight;
+	History = CreateView(0, 0, Width, HistoryHeight, "History", DrawHistory, true, 0);
+	History.visible = !ViewCompressed;
+	MainView = CreateView(0, HistoryH, Width, Height-HistoryH, "Main", DrawGraphSplit, true);
+	X7Views = [];
+	var w = Width / 7;
+	var x = 0;
+	X7Views.push(CreateView(w*0, HistoryH, w, Height - HistoryH, "x5_0", DrawBars, false, 0) );
+	X7Views.push(CreateView(w*1, HistoryH, w, Height - HistoryH, "x5_1", DrawBars, false, 1) );
+	X7Views.push(CreateView(w*2, HistoryH, w, Height - HistoryH, "x5_2", DrawBars, false, 2) );
+	X7Views.push(CreateView(w*3, HistoryH, w, Height - HistoryH, "x5_3", DrawBars, false, 3) );
+	X7Views.push(CreateView(w*4, HistoryH, w, Height - HistoryH, "x5_4", DrawBars, false, 4) );
+	X7Views.push(CreateView(w*5, HistoryH, w, Height - HistoryH, "x5_3", DrawBars, false, 5) );
+	X7Views.push(CreateView(w*6, HistoryH, w, Height - HistoryH, "x5_3", DrawBars, false, 6) );
+	X7LegendView = CreateView(0, Height-X7LegendOffset, Width, X7LegendOffset, "x7_legend", DrawBarsLegend, false, 0);
+
+}
+
+function ResizeCanvas()
+{
+	nWidth = window.innerWidth;
+	nHeight = window.innerHeight;
+	DPR = Settings.AllowHighDPI ? window.devicePixelRatio : 0;
+	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedView);
+	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedOffscreen);
+
+	if(DPR)
+	{
+		CanvasDetailedView.style.width = nWidth + 'px';
+		CanvasDetailedView.style.height = nHeight + 'px';
+		CanvasDetailedView.width = nWidth * DPR;
+		CanvasDetailedView.height = nHeight * DPR;
+		CanvasDetailedView.getContext('2d').scale(DPR,DPR);
+
+		CanvasDetailedOffscreen.style.width = nWidth + 'px';
+		CanvasDetailedOffscreen.style.height = nHeight + 'px';
+		CanvasDetailedOffscreen.width = nWidth * DPR;
+		CanvasDetailedOffscreen.height = nHeight * DPR;
+		CanvasDetailedOffscreen.getContext('2d').scale(DPR,DPR);
+
+	}
+	else
+	{
+		DPR = 1;
+		CanvasDetailedView.width = nWidth;
+		CanvasDetailedView.height = nHeight;
+		CanvasDetailedOffscreen.width = nWidth;
+		CanvasDetailedOffscreen.height = nHeight;
+	}
+	MeasureFont();
+	CreateViews(nWidth, nHeight, Settings.ViewCompressed);
+	ActivateView(Settings.ViewActive);
+}
+
+
+function FormatTime(Time)
+{
+	return Time.toFixed(2);
+}
+var hh = 0;
+
+
+function DrawBarsLegend(View, LocalMouseX, LocalMouseY, SubIndex)
+{
+	ProfileEnter("DrawBar");
+	var TimerMap = FrameData.TimerMap;
+	if(!TimerMap)
+		return;
+	if(Settings.ViewCompressed)
+		return;
+	var Canvas = View.Canvas[View.BackBuffer];
+	var context = Canvas.getContext('2d');
+	context.clearRect(0, 0, View.w, View.h);
+	var X = 0;
+	var Y = View.h/2;
+	var XSpace = 5;
+	var XSpace2 = XSpace * 2;
+	function DrawEntry(T)
+	{
+		X += XSpace2*2;
+		context.fillStyle = T.color;
+		context.fillRect(X-XSpace,Y-XSpace,XSpace2,XSpace2);
+		X += XSpace + 2;
+		context.fillStyle = 'white';
+		var w = context.measureText(T.name).width;
+		context.fillText(T.name, X, Y + FontHeight/2);
+		X += w;
+	}
+
+	if(SingleTimerBars == 0)
+	{
+		for(var key in TimerMap)
+		{
+			var idx = GetTimer(key);
+			var T = TimerArray[idx];
+			if(T.e)
+			{
+				DrawEntry(T);
+			}
+		}
+	}
+	else if(EnabledArray.length > 0)
+	{
+		var idx = EnabledArray[0];
+		var T = TimerArray[idx];
+		DrawEntry(T);
+	}
+}
+
+function DrawBars(View, LocalMouseX, LocalMouseY, SubIndex)
+{
+	var TimerMap = FrameData.TimerMap;
+	if(!TimerMap)
+		return;
+	if(!SubIndex)
+		SubIndex = 0;
+
+	ProfileEnter("DrawBar");
+	var Canvas = View.Canvas[View.BackBuffer];
+	var context = Canvas.getContext('2d');
+
+	context.clearRect(0, 0, View.w, View.h);
+	var bgcolor = nBackColors[ViewIndex%2];
+	context.fillStyle = bgcolor;
+	context.fillRect(0, 0, View.w, View.h);
+	var Title = "?";
+	var TitleName = null;
+	var nNumBars = 0;
+	var BarNames = [];
+	var BarTimes = [];
+	var BarColors = [];
+	var AggregateIndex = Settings.AggregateFrames <= 0 ? AggregateHistorySize-1 : AggregateHistorySize-2; //fix med
+	var GetTime = null;
+	var SubIndex = X7BarColumnRemap[SubIndex];
+
+	if(SingleTimerBars == 0)
+	{
+		if(SubIndex == 0)
+		{
+			Title = "Time";
+			GetTime = function(FD){ return FD.FrameTime; };
+		}
+		else if(SubIndex == 1)
+		{
+			Title = "Average";
+			GetTime = function(FD){ return FD.TimeAvg[AggregateIndex]; };
+		}
+		else if(SubIndex == 2)
+		{
+			Title = "Max";
+			GetTime = function(FD){ return FD.TimeMax[AggregateIndex]; };
+		}
+		else if(SubIndex == 3)
+		{
+			Title = "Min";
+			GetTime = function(FD){ return FD.TimeMin[AggregateIndex]; };
+		}
+		else if(SubIndex == 4)
+		{
+			Title = "Exclusive Avg";
+			GetTime = function(FD){ return FD.TimeExclAvg[AggregateIndex]; };
+		}
+		else if(SubIndex == 5)
+		{
+			Title = "Exclusive Max";
+			GetTime = function(FD){ return FD.TimeExclMax[AggregateIndex]; };
+		}
+		else if(SubIndex == 6)
+		{
+			Title = "Exclusive Min";
+			GetTime = function(FD){ return FD.TimeExclMin[AggregateIndex]; };
+		}
+		for(var key in TimerMap)
+		{
+			var idx = GetTimer(key);
+			var T = TimerArray[idx];
+			if(T.e)
+			{
+				nNumBars++;
+				var FD = TimerMap[key];
+				var Time = GetTime(FD);
+				BarNames.push(T.name);
+				BarTimes.push(Time);
+				BarColors.push(T.color);
+			}
+		}
+
+	}
+	else if(EnabledArray.length > 0)
+	{
+		var idx = EnabledArray[0];
+		var T = TimerArray[idx];
+		var FD =  GetFrameData(T.id);
+		var Property = null;
+		if(SubIndex == 0)
+		{
+			Title = "Average";
+			Property = "TimeAvg";
+		}
+		else if(SubIndex == 1)
+		{
+			Title = "Max";
+			Property = "TimeMax";
+		}
+		else if(SubIndex == 2)
+		{
+			Title = "Min";
+			Property = "TimeMin";
+		}
+		else if(SubIndex == 3)
+		{
+			Title = "Exclusive Average";
+			Property = "TimeExclAvg";
+		}
+		else if(SubIndex == 4)
+		{
+			Title = "Exclusive Max";
+			Property = "TimeExclMax";
+		}
+		else if(SubIndex == 5)
+		{
+			Title = "Exclusive Min";
+			Property = "TimeExclMin";
+		}
+		else if(SubIndex == 6)
+		{
+			Title = "Call Average";
+			Property = "TimeCallAvg";
+		}
+		else if(SubIndex == 7)
+		{
+			Title = "Call Excl Average";
+			Property = "TimeCallExclAvg";
+		}
+		TitleName = T.name;
+		for(var i = 0; i < AggregateHistorySize; ++i)
+		{
+			nNumBars++;
+			var A = FD[Property];
+			var Time = A[i];
+			BarTimes.push(Time);
+			BarColors.push(T.color);
+		}
+	}
+
+
+	if(!nNumBars)
+	{
+		ProfileLeave();
+		return;
+	}
+
+	var h = View.h;
+	var w = View.w;
+	var MsTextExtraSpace = Math.cos(3.14/4.0) * (ViewBarMaxMsTextLength);
+	var DrawXLeft = Settings.ViewCompressed ? 3 : 15;
+	DrawXLeft = Math.max(DrawXLeft, MsTextExtraSpace);
+	var DrawXRight = Settings.ViewCompressed ? 3: 10;
+	var DrawY = 35 * 2;
+	if(Settings.ViewCompressed)
+	{
+		DrawY = (MsTextExtraSpace) + 35;
+	}
+	var DrawWidth = w - DrawXLeft - DrawXRight;
+	var DrawHeight = h - DrawY;
+	var SpaceWidth = 5;
+	var BarWidth = (DrawWidth-SpaceWidth*(nNumBars-1))/ nNumBars;
+	for(var x = 0; x < 2; ++x)
+	{
+		if(BarWidth < 14)
+		{
+			SpaceWidth -= 1;
+			BarWidth = (DrawWidth-SpaceWidth*(nNumBars-1))/ nNumBars;
+		}
+	}
+	if(BarWidth > 50)
+		BarWidth = 50;
+	var BarHeight = DrawHeight - 5;
+
+	var ReferenceTime = ReferenceBar;
+
+	var fHeightScale = h / ReferenceTime;
+	var MouseDragging = 0;
+	var fWidth = w / FRAME_COUNT;
+	var Keys = [];
+	var X = DrawXLeft;
+	var offset = 0;
+	context.textAlign = 'center';
+	context.fillStyle = '#ffffff';
+	context.fillText(Title, w / 2.0, FontHeight);
+	context.textAlign = 'left';
+	context.fillStyle = 'wheat';
+	var BaseY = 20;
+	if(SubIndex == X7BarFirstView)
+	{
+		context.fillText(ReferenceTime.toFixed(2) + 'ms', 0, BaseY - 5 + DrawHeight - BarHeight);
+	}
+	else if(SubIndex == X7BarLastView)
+	{
+		context.textAlign = 'right';
+		context.fillText(ReferenceTime.toFixed(2) + 'ms', w, BaseY - 5 + DrawHeight - BarHeight);
+	}
+	context.textAlign = 'right';
+	var BarFont = FontLarge;
+	var DrawNames = true;
+	if(BarWidth < 14)
+	{
+		DrawNames = BarWidth > 4;
+		var FontXX = 'Bold ' + Math.floor(BarWidth) + 'px Courier New';
+		BarFont = FontXX;
+
+	}
+	context.font = BarFont;
+	for(var i = 0; i < BarTimes.length; ++i)
+	{
+		var TimeText = FormatTime(Time);
+		var w = context.measureText(TimeText).width;
+		ViewBarMaxMsTextLength = Math.max(w, ViewBarMaxMsTextLength);
+
+
+	}
+	for(var i = 0; i < BarTimes.length; ++i)
+	{
+		var Time = BarTimes[i];
+		var TimeText = FormatTime(Time);
+		ReferenceBarAutomatic = Math.max(Time, ReferenceBarAutomatic);
+		var Color = BarColors[i];
+		var fPrc = Time / ReferenceTime;
+		if(fPrc > 1.0)
+			fPrc = 1.0;
+		var BarH = fPrc * BarHeight;
+
+		var X0 = X;
+		var Y0 = BaseY + DrawHeight - BarH;
+		context.fillStyle = Color;
+		context.fillRect(X0, Y0, BarWidth, BarH);
+		context.fillStyle = '#ffffff';
+		var MouseOver = LocalMouseX > X0 && LocalMouseX < X0 + BarWidth;
+		if(MouseOver || (Settings.ViewCompressed&&DrawNames))
+		{
+			context.save();
+			context.translate(X0 + BarWidth * 0.5, BaseY + DrawHeight - 2);
+			context.rotate(-3.14/2.0);
+			context.font = BarFont;
+			context.textAlign = 'left';
+			context.textBaseline = 'middle';
+			var m = context.measureText(BarNames[i]);
+			context.fillStyle = 'black';
+			context.fillText(BarNames[i], -1, -1);
+			context.fillStyle = 'white';
+			context.fillText(BarNames[i], 0, 0);
+			context.textAlign = 'right';
+			context.restore();
+		}
+		context.save();
+		var XText = X+BarWidth;
+		var YText = BaseY + DrawHeight + FontHeight;
+		context.translate(XText, YText);
+		context.rotate(-3.14/4.0);
+		context.font = BarFont;
+		context.fillText(TimeText, 0, 0);
+		context.restore();
+
+		X += BarWidth + SpaceWidth;
+	}
+	context.font = Font;
+	ProfileLeave();
+}
+
+function SortColumnFromName(Name)
+{
+	//should match switch in drawtableview
+	if(Name == StrAverage)
+	{
+		return 1;
+	}
+	else if(Name == StrMax)
+	{
+		return 2;
+	}
+	else if(Name == StrTotal)
+	{
+		return 3;
+	}
+	else if(Name == StrMin)
+	{
+		return 4;
+	}
+	else if(Name == StrSpike)
+	{
+		return 5;
+	}
+	else if(Name == StrCallAverage)
+	{
+		return 6;
+	}
+	else if(Name == StrCount)
+	{
+		return 7;
+	}
+	else if(Name == StrExclAverage)
+	{
+		return 8;
+	}
+	else if(Name == StrExclMax)
+	{
+		return 9;
+	}
+	else if(Name == StrGroup)
+	{
+		return -1;
+	}
+	else if(Name == StrTimer)
+	{
+		return -2;
+	}
+	return 0;
+}
+
+function DrawTableView(View, LocalMouseX, LocalMouseY, SubIndex)
+{
+	ProfileEnter("DrawTableView");
+	var Canvas = View.Canvas[View.BackBuffer];
+	var context = Canvas.getContext('2d');
+	var Height = BoxHeight;
+	var Width = nWidth;
+	var Y = Height;
+	var XBase = 0;
+	var nColorIndex = 0;
+	var bMouseIn = 0;
+	var RcpReferenceTime = 1.0 / Settings.ReferenceTime;
+	var CountWidth = 12 * FontWidth;
+	var InnerBoxHeight = BoxHeight-2;
+	var TimerLen = 8;
+	var TimerWidth = TimerLen * FontWidth;
+	var nWidthBars = nBarsWidth+2;
+	var nWidthMs = TimerWidth+2+10;
+	var NameWidth = 200;
+	var R = 0;
+
+	var OffsetY = BoxHeight;
+
+
+	context.clearRect(0, 0, View.w, View.h);
+	context.fillStyle = 'white';
+	context.font = Font;
+
+
+	function HeaderMouseHandle(XBegin, X, Y, Header)
+	{
+		if(Header == null)
+			debugger;
+		var bMouseIn = LocalMouseY >= Y && LocalMouseY < BoxHeight+Y && LocalMouseX < X && LocalMouseX > XBegin;
+		if(bMouseIn)
+		{
+			SortColumnMouseOverNext = Header;
+		}
+	}
+	function HeaderString(Header)
+	{
+		if(Header == Settings.SortColumnName)
+		{
+			return Header + (Settings.SortColumnOrderFlip ? '<' : '>');
+		}
+		else
+		{
+			return Header;
+		}
+
+	}
+	function DrawHeaderSplit(Header, Y)
+	{
+		if(Settings.BarColumnEnabledTable[R])
+		{
+			context.fillStyle = 'white';
+			context.fillText(HeaderString(Header), X, Y + Height-FontAscent);
+			var XBegin = X;
+			X += nWidthBars;
+			context.fillStyle = nBackColorOffset;
+			X += ColumnsWidth[R];
+
+			if(X >= NameWidth)
+			{
+				context.fillRect(X-3, Y, 1, nHeight);
+			}
+			HeaderMouseHandle(XBegin, X, Y, Header);
+		}
+		R++;
+	}
+	function DrawHeaderSplitSingle(Header, Y)
+	{
+		if(Settings.BarColumnEnabledTable[R])
+		{
+			context.fillStyle = 'white';
+			context.fillText(HeaderString(Header), X, Y + Height-FontAscent);
+			var XBegin = X;
+			X += ColumnsWidth[R];
+			context.fillStyle = nBackColorOffset;
+			if(X >= NameWidth)
+			{
+				context.fillRect(X-3, Y, 1, nHeight);
+			}
+			HeaderMouseHandle(XBegin, X, Y, Header);
+		}
+		R++;
+	}
+	function DrawHeaderSplitLeftRight(HeaderLeft, HeaderRight, Y, Width)
+	{
+		var HeaderLeftS = HeaderString(HeaderLeft);
+		var HeaderRightS = HeaderString(HeaderRight);
+		context.textAlign = 'left';
+		context.fillStyle = 'white';
+		context.fillText(HeaderLeftS, X, Y + Height-FontAscent);
+		var wLeft = context.measureText(HeaderLeftS).width;
+		var XBegin = X;
+		X += Width;
+		context.textAlign = 'right';
+		context.fillText(HeaderRightS, X-5, Y + Height-FontAscent);
+		context.textAlign = 'left';
+		context.fillStyle = nBackColorOffset;
+		if(X >= NameWidth)
+		{
+			context.fillRect(X-3, 0, 1, nHeight);
+		}
+		HeaderMouseHandle(XBegin, XBegin + wLeft, Y, HeaderLeft);
+		HeaderMouseHandle(XBegin + wLeft, X, Y, HeaderRight);
+
+	}
+	function DrawTimer(Value, Color)
+	{
+		if(Settings.BarColumnEnabledTable[R])
+		{
+			if(null == Value)
+			{
+				X += nWidthBars + ColumnsWidth[R];
+				console.log("Should not happen2\n");
+				debugger;
+				return;
+			}
+			var Prc = Value * RcpReferenceTime;
+			var YText = Y+Height-FontAscent;
+			if(Prc > 1)
+			{
+				Prc = 1;
+			}
+			context.textAlign = 'left';
+			context.fillStyle = Color;
+			context.fillRect(X+1, Y+1, Prc * nBarsWidth, InnerBoxHeight);
+			X += nWidthBars;
+			context.fillStyle = 'white';
+			var TimerText = Value.toFixed(2);
+			var W = context.measureText(TimerText).width + FontWidth;
+			ColumnsWidth[R] = Math.max(W, ColumnsWidth[R]);
+			X += ColumnsWidth[R];
+			context.textAlign = 'right';
+			context.fillText(TimerText, X - FontWidth, YText);
+			context.textAlign = 'left';
+		}
+		R++;
+	}
+	function DrawCount(Str)
+	{
+		if(Settings.BarColumnEnabledTable[R])
+		{
+			X += ColumnsWidth[R];
+			context.fillStyle = 'white';
+			context.textAlign = 'right';
+			var YText = Y+Height-FontAscent;
+			context.fillText(Str, X-6, YText);
+			var W = Math.max(80, context.measureText(Str).width + FontWidth * 2);
+			ColumnsWidth[R] = Math.max(W, ColumnsWidth[R]);
+
+		}
+		R++;
+
+	}
+	function DrawMeta(Value, Width, Dec, YText)
+	{
+		Value = FormatMeta(Value, Dec);
+		X += (FontWidth*Width);
+		context.textAlign = 'right';
+		context.fillText(Value, X-FontWidth, YText);
+		context.textAlign = 'left';
+	}
+
+	function DrawTimerRow(idx, showgroup)
+	{
+		R = 0;
+		var T = TimerArray[idx];
+		var key = T.id;
+		var FD = TimerMap[key];
+		var AggregateIndex = Settings.AggregateFrames <= 0 ? AggregateHistorySize-1 : AggregateHistorySize-2;
+
+		var YText = Y+Height-FontAscent;
+		X = NameWidth + XBase;
+
+		nColorIndex = 1-nColorIndex;
+		bMouseIn = LocalMouseY >= Y && LocalMouseY < Y + BoxHeight;
+		context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+		context.fillRect(0, Y, Width, FontHeight+2);
+
+		DrawTimer(T.time, T.color);
+		DrawTimer(T.excl, T.color);
+
+		DrawTimer(T.average, T.color);
+		DrawTimer(T.max, T.color);
+		DrawTimer(T.min, T.color);
+		DrawTimer(T.total, T.color);
+
+		DrawTimer(T.exclaverage, T.color);
+		DrawTimer(T.exclmax, T.color);
+		DrawTimer(T.excltotal, T.color);
+
+		DrawCount((T.spike?T.spike.toFixed(2):"0") + '%');
+		DrawTimer(T.callaverage, T.color);
+		DrawTimer(T.callexclaverage, T.color);
+		DrawCount('' + T.callcount);
+
+		context.fillStyle = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+		context.fillRect(0, Y, NameWidth, Height);
+		if(T.idtype == TYPE_GROUP)
+		{
+			context.textAlign = 'left';
+			context.fillStyle = T.color;
+			context.fillText(T.name, 1, YText);
+		}
+		else
+		{
+			context.textAlign = 'right';
+			context.fillStyle = T.color;
+			context.fillText(T.name, NameWidth - 5, YText);
+			context.textAlign = 'left';
+			let P = TimerArray[T.parent];
+			context.fillStyle = P.color;
+			var ParentName = P.name;
+			context.fillText(ParentName, 1, YText);
+		}
+	}
+	function FilterMatch(FilterArray, value)
+	{
+		if(!FilterArray)
+			return true;
+		for(var i = 0; i < FilterArray.length; ++i)
+		{
+			var res = value.search(FilterArray[i]);
+			if(res<0)
+				return false;
+		}
+		return true;
+	}
+	var TimerMap = FrameData.TimerMap;
+	if(!TimerMap)
+	{
+		return;
+	}
+
+	var wfirst = 100;
+	var OrderArray = new Array();
+	var nTotalRows = 0;
+	for(var key in TimerMap)
+	{
+		var idx = GetTimer(key);
+		var T = TimerArray[idx];
+		if(T.e)
+		{
+			OrderArray.push(idx);
+			wfirst = wfirst < T.wtotal ? T.wtotal : wfirst;
+			nTotalRows++;
+		}
+	}
+	NameWidth = wfirst + 20;
+
+
+	var nTotalRowPixels = nTotalRows * Height;
+	var nFrameRows = nHeight - HistoryHeight - BoxHeight;
+	if(nTotalRowPixels > nFrameRows)
+	{
+		if(nOffsetBarsY + nFrameRows > nTotalRowPixels)
+		{
+			nOffsetBarsY = nTotalRowPixels - nFrameRows;
+		}
+	}
+	else
+	{
+		nOffsetBarsY = 0;
+	}
+	Y = Y - nOffsetBarsY;
+	Y += OffsetY;
+	XBase = XBase - nOffsetBarsX;
+
+	if(1)
+	{
+		let Flip = Settings.SortColumnOrderFlip == 1 ? -1 : 1;
+		let StringCompare = function(Key)
+		{
+			let F = function(A, B)
+			{
+				let s1 = Key(A);
+				let s2 = Key(B);
+				return Flip * s2.localeCompare(s1);
+			};
+			return F;
+		};
+		let NumberCompare = function(Key)
+		{
+			let F = function(A, B)
+			{
+				let v0 = Key(B);
+				let v1 = Key(A);
+				return Flip * (v0 - v1);
+					//Key(B) - Key(A));
+			};
+			return F;
+		};
+		let N = Settings.SortColumnName;
+		if(N == StrTime)
+		{
+			let Do = function()
+			{
+				for(var i = 0; i < OrderArray.length; ++i)
+				{
+					let t = TimerArray[OrderArray[i]];
+					console.log("", i, OrderArray[i], t.name, t.id, t.time);
+				};
+
+			};
+			// Do();
+			OrderArray.sort( NumberCompare( function (a) {
+				return TimerArray[a].time;
+			} ) );
+			// Do();
+		}
+		else if(N == StrExclusive)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].excl; } ) );
+		}
+		else if(N == StrAverage)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].average; } ) );
+		}
+		else if(N == StrMax)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].max; } ) );
+		}
+		else if(N == StrTotal)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].total; } ) );
+		}
+		else if(N == StrMin)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].min; } ) );
+		}
+		else if(N == StrSpike)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].spike; } ) );
+		}
+		else if(N == StrCallAverage)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].callaverage; } ) );
+		}
+		else if(N == StrCount)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].count; } ) );
+		}
+		else if(N == StrExclAverage)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].exclaverage; } ) );
+		}
+		else if(N == StrExclMax)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].exclmax; } ) );
+		}
+		else if(N == StrExclTotal)
+		{
+			OrderArray.sort( NumberCompare( function (a) { return TimerArray[a].excltotal; } ) );
+		}
+		else if(N == StrGroup)
+		{
+			OrderArray.sort( StringCompare( function (a) { return TimerArray[TimerArray[a].parent].name; } ) );
+		}
+		else if(N == StrTimer)
+		{
+			OrderArray.sort( StringCompare( function (a) { return TimerArray[a].name; } ) );
+		}
+		else
+		{
+			if(N != "")
+			{
+				console.log("unhandle sortkey", N);
+				debugger;
+			}
+
+			OrderArray.sort( StringCompare( function (a) { return TimerArray[a].sortkey; } ) );
+		}
+	}
+
+	let ColorHigh = '#85929e';
+
+
+	for(var i = 0; i < OrderArray.length; ++i)
+	{
+		var idx = OrderArray[i];
+		var T = TimerArray[idx];
+		if(T.idtype == TYPE_GROUP)
+		{
+			DrawTimerRow(idx, 1);
+			Y += Height;
+		}
+	}
+	let SplitY = Y;
+
+	for(var i = 0; i < OrderArray.length; ++i)
+	{
+		var idx = OrderArray[i];
+		var T = TimerArray[idx];
+		if(T.idtype != TYPE_GROUP)
+		{
+			DrawTimerRow(idx, 1);
+			Y += Height;
+		}
+	}
+
+	var X = 0;
+	context.fillStyle = nBackColorOffset;
+	context.fillRect(0, 0, Width, 2*Height);
+	context.fillStyle = 'white';
+	SortColumnMouseOverNext = null;
+	X = NameWidth + XBase;
+	R = 0;
+
+	let Aggr = Settings.AggregateFrames <= 0 ? AggregateCurrent : Settings.AggregateFrames;
+	let Headers = ["Per Frame", "Aggregate/" + Aggr + " Frames", "Call/" + Aggr + " Frames"];
+	let SplitX = [0,0,0];
+
+	DrawHeaderSplit(StrTime,OffsetY);
+	DrawHeaderSplit(StrExclusive, OffsetY);
+	SplitX[0] = X;
+
+	DrawHeaderSplit(StrAverage, OffsetY);
+	DrawHeaderSplit(StrMax, OffsetY);
+	DrawHeaderSplit(StrMin, OffsetY);
+	DrawHeaderSplit(StrTotal, OffsetY);
+
+	DrawHeaderSplit(StrExclAverage, OffsetY);
+	DrawHeaderSplit(StrExclMax, OffsetY);
+	DrawHeaderSplit(StrExclTotal, OffsetY);
+
+	DrawHeaderSplitSingle(StrSpike, OffsetY);
+	SplitX[1] = X;
+
+	DrawHeaderSplit(StrCallAverage, OffsetY);
+	DrawHeaderSplit(StrCallExclAverage, OffsetY);
+	DrawHeaderSplitSingle(StrCount, OffsetY);
+	SplitX[2] = X;
+
+	context.fillStyle = 'white';
+	for(var i = 0; i < SplitX.length; ++i)
+	{
+		var X0 = i == 0 ? (NameWidth + XBase) : SplitX[i-1];
+		var X1 = SplitX[i];
+		if(X0 != X1)
+		{
+			context.fillText(Headers[i], X0 + 1, Height-FontAscent);
+		}
+	}
+
+
+	X = 0;
+	context.fillStyle = nBackColorOffset;
+	context.fillRect(0, 0, NameWidth, Height * 2);
+	context.fillStyle = 'white';
+	DrawHeaderSplitLeftRight(StrGroup, StrTimer, 0, NameWidth);
+
+
+	for(var i = 0; i < SplitX.length; ++i)
+	{
+		var X0 = i == 0 ? (NameWidth + XBase) : SplitX[i-1];
+		var X1 = SplitX[i];
+		if(X0 != X1)
+		{
+			context.fillStyle = ColorHigh;
+			if(X1 >= NameWidth)
+				context.fillRect(X1-2.5, 0, 2, nHeight);
+			if(X0 >= NameWidth)
+				context.fillRect(X0-2.5, 0, 2, nHeight);
+		}
+	}
+	context.fillStyle = ColorHigh;
+	context.fillRect(0, 2*Height-1, nWidth, 2);
+
+	context.fillStyle = ColorHigh;
+	context.fillRect(0, SplitY-1, nWidth, 2);
+
+
+	ProfileLeave();
+}
+function DrawGraphThreadGroup(View, LocalMouseX, LocalMouseY, SubIndex)
+{
+	DrawGraphThreadExclusive(View, LocalMouseX, LocalMouseY, SubIndex);
+}
+function DrawGraphSplit(View, LocalMouseX, LocalMouseY, SubIndex)
+{
+	DrawGraph(View, LocalMouseX, LocalMouseY, SubIndex, 1);
+}
+
+function DrawGraphThreadExclusive(View, LocalMouseX, LocalMouseY, SubIndex, Split)
+{
+	var TimerMap = FrameData.TimerMap;
+	if(!TimerMap)
+		return;
+
+	ProfileEnter("DrawGraphThreadExclusive");
+	var Canvas = View.Canvas[View.BackBuffer];
+	var context = Canvas.getContext('2d');
+	context.clearRect(0, 0, View.w, View.h);
+
+	var h = View.h;
+	var w = View.w;
+	var fHeightScale = h / ReferenceGraph;
+	var MouseDragging = 0;
+	var fWidth = w / FRAME_COUNT;
+	var MouseTime = ReferenceGraph * (1-(LocalMouseY / h));
+	var HighlightKey = 0;
+	var HighlightFrame = -1;
+
+
+	var NumGraphs = 0;
+	for(let k in ThreadInfo)
+	{
+		NumGraphs++;
+	}
+	if(NumGraphs)
+	{
+		let hstart = 0;
+		let gh = h / NumGraphs;
+		let cidx = 1;
+		let Count = FRAME_COUNT;
+		let Last = AllocClearedArray(Count);
+		let FT = FrameData.Time;
+		let RcpFT = AllocClearedArray(Count);
+		if(FT.length != RcpFT.length)
+			debugger;
+		for(let k = 0; k < RcpFT.length; ++k)
+		{
+			if(FT[k] != 0)
+			{
+				RcpFT[k] = 1.0 / FT[k];
+			}
+			else
+			{
+				RcpFT[k] = 0;
+			}
+		}
+
+		for(let k in ThreadInfo)
+		{
+			for(let j = 0; j < Last.length; ++j)
+				Last[j] = 0.0;
+			let TI = ThreadInfo[k];
+			let X = 0;
+			let Y = hstart + gh;
+			var YStart = Y;
+			if(LocalMouseX >= 0 && LocalMouseY >= hstart && LocalMouseX < w && LocalMouseY <= Y)
+			{
+				HighlightKey = k;
+				HighlightFrame = Math.floor(FRAME_COUNT * LocalMouseX / w);
+			}
+
+
+			context.globalAlpha = 1;
+			context.fillStyle = nBackColorsDark[cidx];
+			cidx = 1-cidx;
+			context.fillRect(0, hstart, w, gh);
+			context.strokeStyle = 'white';
+			context.fillStyle = 'white';
+			for(let l = 0; l < TI.a.length; ++l)
+			{
+				X = 0;
+				let a = TI.a[l];
+				if(a.length != Count)
+				{
+					console.log("should not happen!\n");
+					debugger;
+				}
+				let idx = GetTimer(TI.ids[l]);
+				let c = TimerArray[idx].color;
+				context.strokeStyle = c;
+				context.fillStyle = c;
+				context.beginPath();
+
+				for(let m = Last.length-1;m >= 0; m--)
+				{
+					let XX = X + fWidth * m;
+					Y = Math.max(YStart - Last[m] * gh, hstart);
+					if(m == Last.length-1)
+					{
+						context.moveTo(XX, Y);
+					}
+					else
+					{
+						context.lineTo(XX, Y);
+					}
+				}
+
+				for(let m = 0; m < a.length; ++m)
+				{
+
+					let h = a[m] * RcpFT[m];
+					if(h > 1.1)
+					{
+						console.log("should not happen ", a[m], RcpFT[m], h);
+						debugger;
+						h = 1;
+						//todo...
+					}
+					let hm = h + Last[m];
+					if(hm > 1.1)
+					{
+						console.log("should not happen ", hm, h, Last[m]);
+						debugger;
+						hm = 1;
+						//todo...
+					}
+					Y = Math.max(YStart - hm * gh, hstart);
+					context.lineTo(X, Y);
+					X += fWidth;
+					Last[m] = hm;
+				}
+				context.fill();
+
+			}
+			context.fillStyle = 'wheat';
+			context.textAlign='right';
+			context.fillText('100%', nWidth, hstart + FontHeight);
+			context.textAlign='left';
+			context.fillText(TI.n, 0, hstart + FontHeight);
+			hstart += gh;
+		}
+	}
+
+	if(HighlightKey != 0 && SubMenuActive == -1)
+	{
+		ToolTipCallback = function(canvas, x, y)
+		{
+			let TI = ThreadInfo[HighlightKey];
+			let ret = [];
+			let colors = [];
+			for(let l = 0; l < TI.a.length; ++l)
+			{
+				let a = TI.a[l];
+				let idx = GetTimer(TI.ids[l]);
+				let c = TimerArray[idx].color;
+				colors.push(c);
+				ret.push(TimerArray[idx].name);
+				let t = FormatTime(a[HighlightFrame]) + 'ms';
+				colors.push('white');
+				ret.push(t);
+			}
+			return {c:colors, a:ret};
+		}
+	}
+
+	ProfileLeave();
+}
+
+function DrawGraphPercentile(View, LocalMouseX, LocalMouseY, SubIndex)
+{
+	let TimerMap = FrameData.TimerMap;
+	if(!TimerMap)
+		return;
+
+	ProfileEnter("DrawGraphPercentile");
+	let Canvas = View.Canvas[View.BackBuffer];
+	let context = Canvas.getContext('2d');
+	context.clearRect(0, 0, View.w, View.h);
+
+	let h = View.h;
+	let w = View.w;
+	let NumGraphs = 0;
+	let ToolTips = Array();
+	for(let key in TimerMap)
+	{
+		if(!IsGroup(key))
+		{
+			let idx = GetTimer(key);
+			if(TimerArray[idx].e)
+			{
+				NumGraphs++;
+			}
+		}
+	}
+	if(NumGraphs)
+	{
+		let hstart = 0;
+		let gh = h / NumGraphs;
+		let Keys = [];
+		let cidx = 1;
+
+		if(LocalMouseX >= 0 && LocalMouseY >= 0 && LocalMouseX < w && LocalMouseY < h && SubMenuActive == -1)
+		{
+			ToolTipCallback = function(canvas, x, y)
+			{
+				let TimerMap = FrameData.TimerMap;
+				let context = canvas.getContext('2d');
+				context.font = Font;
+				let XPos = x - 20;
+				for(let key in TimerMap)
+				{
+					let idx = GetTimer(key);
+					let TimerState = TimerMap[key];
+					let T = TimerArray[idx];
+					if(!IsGroup(key) && T.e && TimerState.PercentileMax > TimerState.PercentileMin)
+					{
+						let HighlightIndex = -1;
+						let Max = TimerState.PercentileMax;
+						let Min = TimerState.PercentileMin;
+						let h = View.h;
+						let w = View.w;
+						let tooltipstring = TimerState.tooltipstring;
+
+						if(LocalMouseX >= 0 && LocalMouseY >= 0 && LocalMouseX < w && LocalMouseY < h && SubMenuActive == -1 && tooltipstring)
+						{
+							if(TimerState.tooltipysoft)
+							{
+								let RATE = 0.05;
+								if(Math.abs(TimerState.tooltipysoft - TimerState.tooltipy) > 6)
+								{
+									TimerState.tooltipysoft = TimerState.tooltipy * RATE + TimerState.tooltipysoft * (1-RATE);
+								}
+							}
+							else
+							{
+								TimerState.tooltipysoft = TimerState.tooltipy;
+							}
+							let Y = TimerState.tooltipysoft;
+							let wtext = context.measureText(tooltipstring, XPos, Y).width;
+							let X = Math.max(0, XPos - wtext);
+							context.fillStyle = 'black';
+							context.fillRect(X - 1, Y-1 , wtext+2, BoxHeight+2);
+							context.fillStyle = 'white';
+							context.textAlign = 'right';
+							context.fillText(tooltipstring, X + wtext, Y+BoxHeight-2);
+
+						}
+					}
+					context.textAlign = 'left';
+				}
+			}
+		}
+
+
+		for(let key in TimerMap)
+		{
+			let idx = GetTimer(key);
+			let TimerState = TimerMap[key];
+			TimerState.tooltipstring = null;
+			let Valid = TimerState.PercentileMax > TimerState.PercentileMin;
+			if(!IsGroup(key) && TimerArray[idx].e)
+			{
+				let Max = Valid ? TimerState.PercentileMax : 1;
+				let Min = Valid ? TimerState.PercentileMin : 0;
+				let SubGraphSettings = GetSubGraphSettings(key);
+				let Percentile = 0.0;
+				if(Percentile == null)
+					Percentile = 0.0;
+				Percentile = Math.max(0.0, Math.min(99.0, Percentile));
+				if(!SubGraphSettings.AutomaticReference)
+				{
+					Max = SubGraphSettings.ReferenceTime;
+				}
+				let Reference = Max;
+				let PercentileData = TimerState.Percentile;
+				let PercentileCount = TimerState.PercentileCount;
+				let BasePrc = 0;
+				if(PercentileCount > PERCENTILE_SAMPLES)
+				{
+					BasePrc = 100 * (1- PERCENTILE_SAMPLES / PercentileCount);
+				}
+				let Total = PercentileData.length-1;
+				let NumElementsOnScreen = Total * (100 - Percentile) / (100);
+				let WidthPerElement = w / NumElementsOnScreen;
+				let TotalWidth = Total * WidthPerElement;
+				let PercentilePrc = Percentile / 100;
+				let PercentileOffset = PercentilePrc * TotalWidth;
+				let fHeightScale2 = gh / Max;
+				let color = TimerArray[idx].color;
+				let X = 0;
+				let Y = hstart + gh;
+				let YStart = Y;
+				let MouseInside = LocalMouseX >= 0 && LocalMouseY >= 0 && LocalMouseX < w && LocalMouseY < h && SubMenuActive == -1;
+
+				context.globalAlpha = 1;
+				context.fillStyle = nBackColorsDark[cidx];
+				cidx = 1-cidx;
+				context.fillRect(0, hstart, w, gh);
+				context.strokeStyle = color;
+				context.fillStyle = color;
+				let PercentileStart = Math.max(0, Math.floor(0.01*Percentile / PercentileData.length));
+				{
+					context.beginPath();
+					context.moveTo(X,Y);
+					for(let i = PercentileStart; i < PercentileData.length; ++i)
+					{
+						X = i * WidthPerElement - PercentileOffset;
+						Y = Math.max(YStart - PercentileData[i] * fHeightScale2, hstart);
+						context.lineTo(X, Y);
+					}
+					context.stroke();
+					context.lineTo(X, YStart);
+					context.globalAlpha = GRAPH_ALPHA;
+					context.fill();
+				}
+				context.globalAlpha = 1;
+				context.fillStyle = 'wheat';
+				context.textAlign='right';
+				context.fillText(FormatTime(Reference) + 'ms', nWidth, hstart + FontHeight);
+				context.fillText('100%', nWidth, hstart + gh-2);
+				context.textAlign='centered';
+				Percentile = BasePrc;
+				context.fillText( ((Percentile + 100)/2).toFixed(2) + '%', nWidth/2, hstart + gh-2);
+				context.textAlign='left';
+				context.fillText(Percentile.toFixed(2) + "%  [Samples:" + PercentileCount + "]", 0, hstart + gh-2);
+				context.fillText(TimerArray[idx].name, 15, hstart + FontHeight);
+				context.fillText(Percentile + '%', nWidth, hstart + FontHeight);
+
+				if(MouseInside)
+				{
+					let Element = (PercentileOffset + LocalMouseX) / WidthPerElement;
+					let Rounded = Math.round(Element);
+					let HighlightIndex = Math.max(0, Math.min(Rounded, PercentileData.length-1));
+					X = HighlightIndex * WidthPerElement - PercentileOffset;
+					let Y = YStart - Math.min(PercentileData[HighlightIndex], Reference) * fHeightScale2;
+					context.strokeStyle = color;
+					context.beginPath();
+					let CrossX = X;
+					let CrossY = Y;
+					context.moveTo(CrossX-2, CrossY-2);
+					context.lineTo(CrossX+2, CrossY+2);
+					context.moveTo(CrossX+2, CrossY-2);
+					context.lineTo(CrossX-2, CrossY+2);
+					context.moveTo(CrossX, hstart);
+					context.lineTo(CrossX, hstart + gh);
+					context.stroke();
+					TimerState.tooltipy = Math.min(YStart - BoxHeight, Y) + View.y;
+					let Perc = 0;
+					if(PERCENTILE_SAMPLES < PercentileCount)
+					{
+						let Idx = PercentileCount - PERCENTILE_SAMPLES + HighlightIndex;
+						Perc = 100 * Idx / (PercentileCount-1);
+					}
+					else
+					{
+						let Idx = HighlightIndex - (PERCENTILE_SAMPLES - PercentileCount);
+						Idx = Math.max(Idx, 0);
+						Perc = 100 * (Idx / (PercentileCount-1))
+					}
+					TimerState.tooltipstring = FormatTime(Perc) + '% ' + FormatTime(PercentileData[HighlightIndex]) + 'ms';;
+				}
+				hstart += gh;
+			}
+		}
+	}
+	ProfileLeave();
+}
+
+
+
+function DrawGraph(View, LocalMouseX, LocalMouseY, SubIndex, Split)
+{
+	var TimerMap = FrameData.TimerMap;
+	if(!TimerMap)
+		return;
+
+	ProfileEnter("DrawGraph");
+	var Canvas = View.Canvas[View.BackBuffer];
+	var context = Canvas.getContext('2d');
+	context.clearRect(0, 0, View.w, View.h);
+
+	var h = View.h;
+	var w = View.w;
+	var fHeightScale = h / ReferenceGraph;
+	var MouseDragging = 0;
+	var fWidth = w / FRAME_COUNT;
+	var HighlightFrame = -1;
+	var GraphKey = null;
+	var GraphBest = 0;
+	var MouseTime = ReferenceGraph * (1-(LocalMouseY / h));
+
+	if(LocalMouseX >= 0 && LocalMouseY >= 0 && LocalMouseX < w && LocalMouseY < h && SubMenuActive == -1)
+	{
+		var index = Math.floor(FRAME_COUNT * LocalMouseX / w);
+		HighlightFrame = index;
+		for(var key in TimerMap)
+		{
+			var idx = GetTimer(key);
+			var T = TimerArray[idx];
+			var TimerState = TimerMap[key];
+			var Time = TimerState.Time;
+			if(Time[index] >= MouseTime && (GraphBest == 0 || Time[index] <= GraphBest))
+			{
+				GraphKey = key;
+				GraphBest = Time[index];
+			}
+		}
+		ToolTipCallback = function(canvas, x, y)
+		{
+			if(Split)
+			{
+				var TimerMap = FrameData.TimerMap;
+				var context = canvas.getContext('2d');
+				context.font = Font;
+				var XPos = x - 20;
+				for(var key in TimerMap)
+				{
+					var idx = GetTimer(key);
+					var T = TimerArray[idx];
+					var TimerState = TimerMap[key];
+					var Time = TimerState.Time;
+					if(TimerState.tooltipysoft)
+					{
+						var RATE = 0.05;
+						if(Math.abs(TimerState.tooltipysoft - TimerState.tooltipy) > 6)
+						{
+							TimerState.tooltipysoft = TimerState.tooltipy * RATE + TimerState.tooltipysoft * (1-RATE);
+						}
+					}
+					else
+					{
+						TimerState.tooltipysoft = TimerState.tooltipy;
+					}
+					var Y = TimerState.tooltipysoft;
+					var str = '' + FormatTime(Time[index]) + 'ms';
+					var w = context.measureText(str, XPos, Y).width;
+					var X = Math.max(0, XPos - w);
+					context.fillStyle = 'black';
+					context.fillRect(X - 1, Y-1 , w+2, BoxHeight+2);
+					context.fillStyle = 'white';
+					context.textAlign = 'right';
+					context.fillText(str, X + w, Y+BoxHeight-2);
+
+				}
+				context.textAlign = 'left';
+			}
+			else
+			{
+				var StringArray = [];
+				var ColorArray = [];
+				var TimerMap = FrameData.TimerMap;
+				for(var key in TimerMap)
+				{
+					if(!IsGroup(key))
+					{
+						var idx = GetTimer(key);
+						var T = TimerArray[idx];
+						var TimerState = TimerMap[key];
+						var Time = TimerState.Time;
+						ColorArray.push(TimerArray[idx].color);
+						StringArray.push('' + T.name);
+						ColorArray.push('white');
+						StringArray.push('' + FormatTime(Time[index]) + 'ms') ;
+					}
+				}
+				return {c:ColorArray,a:StringArray};
+			}
+		}
+
+	}
+
+	if(Split)
+	{
+		var NumGraphs = 0;
+		for(var key in TimerMap)
+		{
+			if(!IsGroup(key))
+			{
+				NumGraphs++;
+			}
+		}
+		if(NumGraphs)
+		{
+			var hstart = 0;
+			var gh = h / NumGraphs;
+			var Keys = [];
+			var cidx = 1;
+			for(var key in TimerMap)
+			{
+				var idx = GetTimer(key);
+				var TimerState = TimerMap[key];
+				if(!IsGroup(key))
+				{
+					let SubGraphSettings = GetSubGraphSettings(key);
+					var Reference = GetSubGraphReferenceTime(SubGraphSettings, TimerState);
+					var fHeightScale2 = gh / Reference;
+
+					var Time = TimerState.Time;
+					var color = TimerArray[idx].color;
+					var X = w - Time.length*fWidth;
+					var Y = hstart + gh;
+					var YStart = Y;
+					context.globalAlpha = 1;
+					context.fillStyle = nBackColorsDark[cidx];
+					cidx = 1-cidx;
+					context.fillRect(0, hstart, w, gh);
+					context.strokeStyle = color;
+					context.fillStyle = color;
+					context.beginPath();
+					context.moveTo(X,Y);
+					for(var i = 0; i < Time.length; ++i)
+					{
+						Y = Math.max(YStart - Time[i] * fHeightScale2, hstart);
+						context.lineTo(X, Y);
+						X += fWidth;
+
+					}
+					context.stroke();
+					context.lineTo(X, YStart);
+					context.globalAlpha = GRAPH_ALPHA;
+					context.fill();
+
+
+					context.globalAlpha = 1;
+					context.fillStyle = 'wheat';
+					context.textAlign='right';
+					context.fillText(FormatTime(Reference) + 'ms', nWidth, hstart + FontHeight);
+					context.textAlign='left';
+					context.fillText(TimerArray[idx].name, 15, hstart + FontHeight);
+
+					if(HighlightFrame >= 0)
+					{
+						var X = w - Time.length * fWidth + fWidth * HighlightFrame;
+						var Y = YStart - Math.min(Time[HighlightFrame], Reference) * fHeightScale2;
+						context.strokeStyle = color;
+						context.beginPath();
+						var CrossX = X;
+						var CrossY = Y;
+						context.moveTo(CrossX-2, CrossY-2);
+						context.lineTo(CrossX+2, CrossY+2);
+						context.moveTo(CrossX+2, CrossY-2);
+						context.lineTo(CrossX-2, CrossY+2);
+						context.moveTo(CrossX, hstart);
+						context.lineTo(CrossX, hstart + gh);
+						context.stroke();
+						TimerState.tooltipy = Math.min(YStart - BoxHeight, Y) + View.y;
+					}
+					hstart += gh;
+				}
+			}
+		}
+	}
+	else
+	{
+		var Keys = [];
+		var Prev = Array();
+		var He = Array();
+		for(var key in TimerMap)
+		{
+			if(!IsGroup(key))
+			{
+				var idx = GetTimer(key);
+				var TimerState = TimerMap[key];
+				var Time = TimerState.Time;
+				var color = TimerArray[idx].color;
+				var X = w - Time.length*fWidth;
+				var Y = h;
+				while(Time.length > He.length)
+				{
+					He.push(0.0);
+				}
+				for(var i = 0; i < Time.length; ++i)
+				{
+					He[i] += Time[i];
+				}
+			}
+		}
+		if(1) // graph with clipping. this code seems way to complicated
+		{
+			var NumGraphs = 0;
+			var Len = 0;
+			for(let key in TimerMap)
+			{
+				if(!IsGroup(key))
+				{
+					var idx = GetTimer(key);
+					var TimerState = TimerMap[key];
+					var Time = TimerState.Time;
+					Len = Math.max(Len, Time.length);
+					NumGraphs++;
+				}
+			}
+			let g = Array(Len);
+			for(let i = 0; i < g.length; ++i)
+				g[i] = Array(NumGraphs);
+			let i = 0;
+			for(let key in TimerMap)
+			{
+				if(!IsGroup(key))
+				{
+					var TimerState = TimerMap[key];
+					var Time = TimerState.Time;
+					let x = GetTimer(key);
+					for(let j = 0; j < Time.length; ++j)
+					{
+						g[j][i] = {k:key, v: Time[j], x:x, c:TimerArray[x].color,n:TimerArray[x].name};
+					}
+					i++;
+				}
+			}
+			for(let i = 0; i < g.length; ++i)
+			{
+				let a = g[i];
+				a.sort( function(l, r){
+					return l.v-r.v;
+				});
+			}
+			let cvt = function(t){ return h - t * fHeightScale; };
+			if(1)
+			{
+				let Segments = Array();
+				let MakeSegment = function(b,e)
+				{
+					let s = {b:b, e:e, a:[]};
+					Segments.push(s);
+					return s;
+				};
+				let MakeEntry = function(y0l, y0h, y1l, y1h, c)
+				{
+					let e ={y0l:y0l,y0h:y0h,y1h:y1h,y1l:y1l,c:c,t:0};
+					return e;
+				};
+
+				let X = 0;
+				for(let i = 1; i < g.length; ++i)
+				{
+					let a0 = g[i-1];
+					let a1 = g[i];
+					let s = MakeSegment(X, X + fWidth);
+					if(a0.length != a1.length)
+					{
+						console.log("should not happen!!");
+						debugger;
+					}
+					let FailIndex = -1;
+					for(let j = 0; j < a0.length; ++j)
+					{
+						if(a0[j].k != a1[j].k)
+						{
+							FailIndex = j;
+							break;
+						}
+
+						let t0l = j > 0 ? a0[j-1].v : 0;
+						let t0h = a0[j].v;
+						let t1l = j > 0 ? a1[j-1].v : 0;
+						let t1h = a1[j].v;
+						let c = a1[j].c;
+						let e = MakeEntry(t0l, t0h, t1l, t1h, c);
+						s.a.push(e);
+					}
+					if(FailIndex >= 0)
+					{
+						let l = a0.length;
+						let ax = Array(l);
+						if(FailIndex + 1 >= l)
+							debugger;///no lines, should not happen.
+						for(let j = FailIndex; j < l; ++j)
+						{
+							//find matching
+							for(let k = FailIndex; k < l; ++k)
+							{
+								if(a1[k].k == a0[j].k)
+								{
+									if(ax[j])
+									{
+										console.log("should never happen");
+										debugger;//should not happen
+									}
+									ax[j] = a1[k];
+									break;
+								}
+							}
+						}
+						//find all intersections within [0-1]
+						let I = [];
+						I.push(0);
+						for(let j = FailIndex; j < l; ++j)
+						{
+							let ya = a0[j].v;
+							let yam = ax[j].v;
+							let ka = yam-ya;
+							for(let k = j + 1; k < l; ++k)
+							{
+								let yb = a0[k].v;
+								let ybm = ax[k].v;
+								let kb = ybm-yb;
+								let num = yb-ya;
+								let denom = ka-kb;
+								if(denom>0.00001||denom < -0.00001)
+								{
+									let x = num/denom;
+									if(x>=0 && x <= 1)
+									{
+										I.push(x);
+									}
+								}
+							}
+						}
+						I.push(1);
+						if(I.length)
+						{
+							I.push(I[0]);
+							I.push(I[0]);
+							I.sort();
+
+							let i = 0;
+							let DIST = 0.00001;
+							while(i+1 < I.length)
+							{
+								if(Math.abs(I[i] - I[i+1]) < DIST)
+								{
+									I.splice(i, 1);
+								}
+								else
+								{
+									i++;
+								}
+							}
+						}
+						for(let i = 0; i < I.length-1; ++i)
+						{
+							let x0 = I[i];
+							let x1 = I[i+1];
+							let xm =  0.5 * (x0+x1);
+							let b = X + x0 * fWidth;
+							let e = X + x1 * fWidth;
+							let c = X + xm * fWidth;
+							let s = MakeSegment(b, e);
+							for(let j = FailIndex; j < l; ++j)
+							{
+								let y = a0[j].v;
+								let yx = ax[j].v;
+								let yd = yx - y;
+								let y0 = y + yd * x0;
+								let y1 = y + yd * x1;
+								let ym = y + yd * xm;
+								let e = MakeEntry(ym, y0, ym, y1, a0[j].c);
+								s.a.push(e);
+							}
+							s.a.sort(function(l, r){
+								return l.y0l-r.y0l;
+							});
+							for(let j = 0; j < s.a.length; ++j)
+							{
+								if(j == 0)
+								{
+									s.a[j].y0l = 0;
+									s.a[j].y1l = 0;
+								}
+								else
+								{
+									s.a[j].y0l = s.a[j-1].y0h;
+									s.a[j].y1l = s.a[j-1].y1h;
+								}
+							}
+						}
+					}
+					X += fWidth;
+				}
+				for(let i = 0; i < Segments.length; ++i)
+				{
+					let s = Segments[i];
+					let X0 = s.b;
+					let X1 = s.e;
+					for(let j = 0; j < s.a.length; ++j)
+					{
+						let e = s.a[j];
+						let xs = [];
+						let ytop = [];
+						let ybot = [];
+						if(!e.t)
+						{
+							e.t = 1;
+							let XB = X0;
+							let XE = X1;
+							xs.push(XB);
+							ytop.push(cvt(e.y0h));
+							ybot.push(cvt(e.y0l));
+							let yeh = e.y1h;
+							let yel = e.y1l;
+							let k = i + 1;
+							let Found = true;
+							while(k < Segments.length && Found)
+							{
+								Found = false;
+								let s = Segments[k];
+								for(let l = 0; l < s.a.length && !Found; ++l)
+								{
+									let e1 = s.a[l];
+									if(!e1.t && e1.c == e.c && Math.abs(e1.y0l-e.y1l) < 0.0001 && Math.abs(e1.y0h - e.y1h) < 0.0001)
+									{
+										e1.t = 1;
+										xs.push(XE);
+										ytop.push(cvt(yeh));
+										ybot.push(cvt(yel));
+										XE = s.e;
+										yeh = e1.y1h;
+										yel = e1.y1l;
+										Found = true;
+										e = e1;
+									}
+								}
+								k++;
+							}
+							xs.push(XE);
+							ytop.push(cvt(yeh));
+							ybot.push(cvt(yel));
+						}
+						if(xs.length)
+						{
+							context.strokeStyle = e.c;
+							context.fillStyle = e.c;
+							context.globalAlpha = GRAPH_ALPHA;
+							context.beginPath();
+							context.moveTo(xs[0], ytop[0]);
+							for(let k = 1; k < xs.length; ++k)
+							{
+								context.lineTo(xs[k], ytop[k]);
+							}
+							for(let k = xs.length-1; k >= 0; --k)
+							{
+								context.lineTo(xs[k], ybot[k]);
+							}
+							context.fill();
+							context.beginPath();
+							context.moveTo(xs[0], ytop[0]);
+							for(let k = 1; k < xs.length; ++k)
+							{
+								context.lineTo(xs[k], ytop[k]);
+							}
+							context.globalAlpha = 1.0;
+							context.stroke();
+						}
+					}
+				}
+			}
+		}
+		if(0) //old graph code, no clipping
+		{
+			for(var key in TimerMap)
+			{
+				if(!IsGroup(key))
+				{
+					var idx = GetTimer(key);
+					var TimerState = TimerMap[key];
+					var Time = TimerState.Time;
+					var color = TimerArray[idx].color;
+					var X = w - Time.length*fWidth;
+					var Y = h;
+					context.strokeStyle = color;
+					context.fillStyle = color;
+
+					context.beginPath();
+					context.moveTo(X,Y);
+					for(var i = 0; i < Time.length; ++i)
+					{
+						Y = h - Time[i] * fHeightScale;
+						context.lineTo(X, Y);
+						X += fWidth;
+					}
+					context.stroke();
+					context.lineTo(X, h);
+					context.globalAlpha = GRAPH_ALPHA;
+					context.fill();
+					context.globalAlpha = 1;
+				}
+			}
+		}
+		if(HighlightFrame >= 0)
+		{
+			for(var key in TimerMap)
+			{
+				if(!IsGroup(key))
+				{
+					var idx = GetTimer(key);
+					var TimerState = TimerMap[key];
+					var Time = TimerState.Time;
+					var color = TimerArray[idx].color;
+					var X = w - Time.length*fWidth + fWidth * HighlightFrame;
+					var Y = h - Time[HighlightFrame] * fHeightScale;
+					context.strokeStyle = color;
+					context.beginPath();
+					var CrossX = X;
+					var CrossY = Y;
+					context.moveTo(CrossX-2, CrossY-2);
+					context.lineTo(CrossX+2, CrossY+2);
+					context.moveTo(CrossX+2, CrossY-2);
+					context.lineTo(CrossX-2, CrossY+2);
+					context.stroke();
+				}
+			}
+		}
+		context.fillStyle = 'wheat';
+		context.textAlign='right';
+		context.fillText(FormatTime(ReferenceGraph) + 'ms', nWidth, FontHeight);
+		context.textAlign='left';
+	}
+
+	ProfileLeave();
+}
+
+function StringHash(s) //note: matching code in microprofile.cpp: uint32_t MicroProfileStringHash(const char* pString)
+{
+	var h = 0xfeedba3e;
+	for(var i = 0; i < s.length; ++i)
+	{
+		h = s.charCodeAt(i) + ((h << 5) - h);
+		h = h & h;
+	}
+	return Math.abs(h);
+}
+
+function StringColorIndex(Name)
+{
+	var h = StringHash(Name);
+	var cidx = Math.floor(360*(h  / (1<<32-1)) );
+	return cidx;
+}
+
+function ColorFromString(Name, S, L)
+{
+	var H = StringColorIndex(Name);
+	return "hsl(" + H + "," + S + "%, " + L+ "%)";
+}
+
+function LerpColor(v)
+{
+	var R_0 = 0;
+	var G_0 = 1;
+	var B_0 = 0;
+
+	var R_1 = 1;
+	var G_1 = 0.5;
+	var B_1 = 0;
+
+	var R_2 = 1;
+	var G_2 = 0;
+	var B_3 = 0;
+	var R;
+	var G;
+	if(v < 0.5)
+	{
+		v *= 2;
+		var v0 = (1-v);
+		R = R_0 * v0 + R_1 * v;
+		G = G_0 * v0 + G_1 * v;
+
+	}
+	else
+	{
+		v = (v-0.5) * 2;
+		var v0 = (1-v);
+		R = R_1 * v0 + R_2 * v;
+		G = G_1 * v0 + G_2 * v;
+	}
+	R *= 255;
+	G *= 255;
+	return "rgb(" + R.toFixed(0) + "," + G.toFixed(0) + ",0)";
+
+}
+
+function DrawRange(context, X, XEnd, Y, YEnd, ColorBack, ColorFront)
+{
+	if(X < XEnd)
+	{
+		var W = XEnd - X;
+		var H = YEnd - Y;
+		context.globalAlpha = 0.1;
+		context.fillStyle = ColorBack;
+		context.fillRect(X, Y, W, H);
+		context.globalAlpha = 1;
+		context.strokeStyle = ColorFront;
+		context.beginPath();
+		context.moveTo(X, 0);
+		context.lineTo(X, H);
+		context.moveTo(X+W, 0);
+		context.lineTo(X+W, H);
+		// context.closePath();
+		context.stroke();
+	}
+}
+
+
+function DrawHistory(View, LocalMouseX, LocalMouseY)
+{
+	ProfileEnter("DrawHistory");
+	var Canvas = View.Canvas[View.BackBuffer];
+	var context = Canvas.getContext('2d');
+	context.clearRect(0, 0, View.w, View.h);
+	if(!FrameData.Time)
+		return;
+	var fHeight = View.h;
+	var fWidth = nWidth / FRAME_COUNT;
+	var fHeightScale = fHeight / ReferenceHistory;
+	var fX = 0;
+	var FrameIndex = -1;
+	var MouseDragging = 0;
+	var GreenTime = (Settings.TargetTime * 0.9);
+	var RedBegin = (Settings.TargetTime * 1.1);
+	var LerpDist = 1.0 / (RedBegin - GreenTime);
+	var id0 = -1;
+	var id1 = -1;
+
+	if(MouseDragActiveXEnd > MouseDragActiveXStart)
+	{
+		var idx0 = Math.ceil(FRAME_COUNT * MouseDragActiveXStart / nWidth);
+		var idx1 = Math.floor(FRAME_COUNT * MouseDragActiveXEnd / nWidth);
+		idx0 = Clamp(idx0, 0, FRAME_COUNT-1);
+		idx1 = Clamp(idx1, 0, FRAME_COUNT-1);
+		id0 = FrameData.Ids[idx0];
+		id1 = FrameData.Ids[idx1];
+	}
+
+
+	var ToolTipFrame = -1;
+	for(var i = 0; i < FRAME_COUNT; i++)
+	{
+		var fMs = FrameData.Time[i];
+		var fPrc = (fMs - GreenTime) * LerpDist;
+		fPrc = Clamp(fPrc, 0, 1);
+		var color = LerpColor(fPrc);
+		var fid = FrameData.Ids[i];
+		if(fid >= id0 && fid <= id1)
+		{
+			color = 'cyan';
+		}else if(FrameData.Frozen[i])
+		{
+			color = 'purple';
+		}
+
+
+		var fH = fHeightScale * fMs;
+		var bMouse = LocalMouseX > fX && LocalMouseX < fX + fWidth+1 && MouseY <= HistoryHeight;
+		if(bMouse && !MouseDragging)
+		{
+			context.fillStyle = FRAME_HISTORY_COLOR_GPU;
+			ToolTipFrame = i;
+		}
+		else
+		{
+			context.fillStyle = color;
+		}
+		context.fillRect(fX, fHeight - fH, fWidth-1, fH);
+		fX += fWidth;
+	}
+
+
+	DrawRange(context, MouseDragActiveXStart, MouseDragActiveXEnd, 0, HistoryHeight, '#59d0ff', '#00ddff');
+
+
+	var fH = fHeight - fHeightScale * Settings.TargetTime;
+	context.fillStyle = 'wheat';
+	context.strokeStyle = 'wheat';
+	context.beginPath();
+	context.moveTo(0, fH);
+	context.lineTo(nWidth, fH);
+	// context.closePath();
+	context.stroke();
+	var YText;
+	if(fH > HistoryHeight * 0.25)
+	{
+		YText = fH - FontAscent;
+	}
+	else
+	{
+		YText = fH + FontHeight;
+	}
+
+	context.fillText(Settings.TargetTime + 'ms', 3, YText);
+	context.textAlign='right';
+	context.fillText(FormatTime(ReferenceHistory) + 'ms', nWidth, FontHeight);
+	context.textAlign='left';
+
+
+
+	if(ToolTipFrame >= 0)
+	{
+		var fMs = FrameData.Time[ToolTipFrame];
+		var Frozen = FrameData.Frozen[ToolTipFrame];
+		ToolTipCallback = function()
+		{
+			var StringArray = [];
+			StringArray.push("Frame");
+			StringArray.push("" + ToolTipFrame);
+			StringArray.push("Time");
+			StringArray.push("" + fMs.toFixed(3));
+			if(Frozen)
+			{
+				StringArray.push("Frozen & Unreliable");
+				StringArray.push("");
+			}
+			return StringArray;
+		}
+	}
+
+
+	ProfileLeave();
+
+}
+function MouseInRect(Rect)
+{
+	return MouseInside(Rect.x, Rect.y, Rect.w, Rect.h);
+}
+function MouseInside(X, Y, W, H)
+{
+	return MouseX >= X && MouseX <= X + W && MouseY >= Y && MouseY <= Y + H;
+}
+
+var MessageText = "";
+var MessageTimeout = -1;
+var MessageTimeoutLast = new Date();
+var MessageShowSpinner = 0;
+function SetMessage(text, TimeOut, ShowSpinner)
+{
+	if(TimeOut)
+	{
+		MessageTimeout = TimeOut;
+	}
+	else
+	{
+		MessageTimeout = -1;
+	}
+	MessageText = text;
+	MessageShowSpinner = ShowSpinner;
+}
+function ClearMessage(Message)
+{
+	if(Message == MessageText)
+	{
+		MessageText = "";
+		MessageTimeout = -1;
+	}
+}
+
+function DrawMessage()
+{
+	var context = CanvasDetailedView.getContext('2d');
+	var Now = new Date();
+	var Delta = Now - MessageTimeoutLast;
+	if(MessageTimeout>0)
+	{
+		MessageTimeout -= Delta;
+		if(MessageTimeout<= 0)
+		{
+			MessageText = "";
+			MessageTimeout = -1;
+		}
+
+	}
+	MessageTimeoutLast = Now;
+
+	var Text = MessageText;
+	var X = nWidth / 2;
+
+	var Y = nHeight / 2;
+	context.font = FontFlash;
+	context.textAlign = 'center';
+	context.fillStyle = 'red';
+
+	function MSG(a, Spinner)
+	{
+		context.fillText(a, X, Y);
+		if(Spinner)
+		{
+			var w = context.measureText(a).width;
+			SpinnerDraw(1, context, SpinnerText0, X + 3 + w*0.5, Y - 25,  30, 30);
+			SpinnerDraw(1, context, SpinnerText1, X - 3 - w*0.5 - 30, Y - 25,  30, 30);
+		}
+		Y -= 60;
+	}
+	if(!HelpFade)
+		HelpFade = new Date();
+	var HelpFadeTime = new Date() - HelpFade;
+	if(HelpFadeTime < 2000)
+	{
+		var Alpha = 1 - (HelpFadeTime/2000);
+		context.globalAlpha = Alpha;
+		context.fillText("Press 'h' for help", X, 200);
+		context.globalAlpha = 1;
+	}
+
+	if(Text != "")
+	{
+		MSG(Text);
+	}
+	if(IsFrozen)
+	{
+		MSG("FROZEN[space]");
+	}
+
+	PresetPending++; //hack: wait 20 frames before showing enable messages to prevent it from showing when loading settings. [[[test]]]
+	if(WSIsOpen && PresetPending > 20)
+	{
+		if(Settings.ViewActive != VIEW_COUNTERS)
+		{
+			if(GroupsEnabled == 0)
+			{
+				MSG("Paused: Enable groups in 'Control' menu to unpause");
+			}
+			if(TimersEnabled == 0 && Settings.ViewActive != VIEW_GRAPH_THREAD_GROUP)
+			{
+				MSG("Enable Timers or Functions");
+			}
+		}
+	}
+	context.textAlign = 'left';
+	context.font = Font;
+}
+
+function DrawGraphSettingsMenu(context, XBase, Y, width, height)
+{
+	if(SubMenuActive != SubMenuGraphSettings)
+	{
+		SubMenuGraphSettingsIndex = -1;
+		SubMenuGraphSettingsKey = "";
+	}
+	if(!ShowMenu())
+	{
+		return;
+	}
+	if(!(Settings.ViewActive == VIEW_GRAPH_SPLIT || Settings.ViewActive == VIEW_GRAPH_PERCENTILE))
+	{
+		return;
+	}
+	let NumGraphs = 0;
+	let TimerMap = FrameData.TimerMap;
+
+	for(let key in TimerMap)
+	{
+		if(!IsGroup(key))
+		{
+			let idx = GetTimer(key);
+			if(TimerArray[idx].e)
+			{
+				NumGraphs++;
+			}
+		}
+	}
+	let h = height;
+	let w = width;
+	let hstart = Y;
+	let gh = h / NumGraphs;
+	NumGraphs = 0;
+	for(let key in TimerMap)
+	{
+		if(!IsGroup(key))
+		{
+			let idx = GetTimer(key);
+			if(TimerArray[idx].e)
+			{
+				let X = XBase+1;
+				let Y = hstart+1;
+				let MenuText = ">";
+				let w2 = 2 + context.measureText(MenuText).width;
+				let bMouseInside = MouseInside(X, Y, w2, 4 + FontHeight);
+				context.fillStyle = bMouseInside || (SubMenuGraphSettings == SubMenuActive && SubMenuGraphSettingsIndex == NumGraphs) ? nBackColors[1] : 'black';
+				context.fillRect(X, Y, w2, 4 + FontHeight);
+				context.fillStyle = '#ffffff';
+				context.fillText(MenuText, X, Y + FontHeight);
+				context.textAlign = 'left';
+				if(bMouseInside)
+				{
+					SubMenuGraphSettingsIndex = NumGraphs;
+					SubMenuGraphSettingsKey = key;
+					CaptureButtonX = X + w2 + 2;
+					CaptureButtonY = Y;
+					EnableMenu(SubMenuGraphSettings);
+				}
+				NumGraphs++;
+				hstart += gh;
+
+
+			}
+		}
+	}
+}
+
+function DrawCaptureMenu(context)
+{
+	MouseInCaptureButton = 0;
+	if(!ShowMenu())
+	{
+		return;
+	}
+
+	var CaptureRange = MouseDragActiveXStart < MouseDragActiveXEnd ? "Selection" : (""+Settings.CaptureFrames);
+	var CaptureText = "Capture[" + CaptureRange + "]";
+	var w = 10 + context.measureText(CaptureText).width;
+	var X = nWidth / 2 - w / 2;
+	var XCenter = nWidth / 2;
+	var Y = nHeight - 30;
+	MouseInCaptureButton = MouseInside(X, Y, w, 4 + FontHeight);
+	context.textAlign = 'center';
+	context.fillStyle = MouseInCaptureButton ? nBackColors[1] : 'black';
+	context.fillRect(X, Y, w, 4 + FontHeight);
+	context.fillStyle = '#ffffff';
+	context.fillText(CaptureText, XCenter, Y + FontHeight);
+
+
+
+	X += w + 2;
+	var MenuText = "^";
+	var w2 = 10 + context.measureText(MenuText).width;
+	var bMouseInCaptureMenu = MouseInside(X, Y, w2, 4 + FontHeight);
+	context.fillStyle = bMouseInCaptureMenu ? nBackColors[1] : 'black';
+	context.fillRect(X, Y, w2, 4 + FontHeight);
+
+	context.fillStyle = '#ffffff';
+	context.fillText(MenuText, X + w2*0.5, Y + FontHeight);
+
+	let X1 = X + w2 + 10;
+	if(CaptureTriggerDelta)
+	{
+		let text = FormatTime(CaptureTriggerDelta);
+		let w = 10 + context.measureText("text").width;
+		context.fillStyle = 'black';
+		context.fillRect(X1, Y, w, 4 + FontHeight);
+		context.fillStyle = '#ffffff';
+		context.fillText(text, X1 + w*0.5, Y + FontHeight);
+		X1 += w;
+	}
+
+	let Pending = (CaptureTriggerTime != null && CaptureTriggerTimeType == 2);
+	if(AutoCaptureEnabled || Pending)
+	{
+		let d = Dots();
+		let AutoStatus = Pending ? (" pending" + Dots()) : "";
+		let Source = GetAutoCaptureString();
+		let Threshold = FormatTime(Settings.AutoCaptureTheshold);
+		let str = "Autocapture " + AutoStatus + " Source:'" + Source + "' Threshold:" + Threshold + "ms Repeat=" + (Pending?Settings.AutoCaptureRepeat:AutoCaptureEnabled);
+		let w = 10 + context.measureText(str).width;
+		context.fillStyle = 'black';
+		context.fillRect(X1, Y, w, 4 + FontHeight);
+		context.fillStyle = '#ffffff';
+		context.fillText(str, X1 + w*0.5, Y + FontHeight);
+		X1 += w;
+	}
+
+	context.textAlign = 'left';
+	if(bMouseInCaptureMenu)
+	{
+		CaptureButtonX = X + w2;
+		CaptureButtonY = Y;
+		EnableMenu(SubMenuCapture);
+	}
+}
+function UpdateX7Views()
+{
+	if(Settings.ViewActive == VIEW_BAR_SINGLE || Settings.ViewActive == VIEW_BAR_ALL)
+	{
+		var NumSubViews = 0;
+		var BarColumnEnabled = GetBarColumnEnabled();
+		X7BarFirstView = -1;
+		X7BarLastView = -1;
+		var ViewMask = 0;
+		for(var i = 0; i < BarColumnEnabled.length; ++i)
+		{
+			if(BarColumnEnabled[i])
+			{
+				if(X7BarFirstView == -1)
+					X7BarFirstView = i;
+				X7BarColumnRemap[NumSubViews++] = i;
+				ViewMask = ViewMask | (1 << i);
+				X7BarLastView = i;
+			}
+		}
+		if(ViewMask != X7BarColumnMask)
+		{
+			console.log("resizing views");
+			var w = NumSubViews ? nWidth / NumSubViews : 1;
+			for(var i = 0; i < X7Views.length; ++i)
+			{
+				X7Views[i].visible = i < NumSubViews;
+				if(i < NumSubViews)
+				{
+					var HistoryH = Settings.ViewCompressed ? 0 : HistoryHeight;
+					ResizeView(X7Views[i], w*i, HistoryH, w, nHeight - HistoryH);
+				}
+			}
+			X7BarColumnMask = ViewMask;
+		}
+		X7LegendView.visible = true;
+		ReferenceBarAutomatic = 0;
+	}
+}
+function DrawViews()
+{
+	Plotf("DrawViews");
+	UpdateX7Views();
+	ProfileEnter("UpdateViews");
+	ViewIndex = 0;
+	for(var i = 0; i < Views.length; ++i)
+	{
+		var View = Views[i];
+		if(View.visible)
+		{
+			var LocalMouseX = MouseX - View.x;
+			var LocalMouseY = MouseY - View.y;
+			View.DisplayFunc(View, LocalMouseX, LocalMouseY, View.index);
+			var Canvas = View.Canvas[View.BackBuffer];
+			var Context = Canvas.getContext('2d');
+			ViewIndex++;
+		}
+	}
+	ProfileLeave();
+	var context = CanvasDetailedView.getContext('2d');
+	context.clearRect(0, 0, nWidth, nHeight);
+	ProfileEnter("BlitViews");
+	for(var i = 0; i < Views.length; ++i)
+	{
+		var View = Views[i];
+		if(View.visible)
+		{
+			context.drawImage(View.Canvas[View.BackBuffer], Math.floor(View.x), Math.floor(View.y), View.w, View.h);
+		}
+	}
+
+	DrawCaptureMenu(context);
+	DrawGraphSettingsMenu(context, MainView.x, MainView.y, MainView.w, MainView.h);
+
+	ProfileLeave();
+
+}
+var SubMenuGroup = 0;
+var SubMenuTimers = 1;
+var SubMenuModules = 2;
+var SubMenuFunctions = 3;
+var SubMenuPatched = 4;
+var SubMenuSettings = 5;
+var SubMenuViews = 6;
+var SubMenuPresets = 7;
+var SubMenuColumns = 8;
+var SubMenuCapture = 9;
+var SubMenuGraphSettings = 10;
+var SubMenuGraphSettingsIndex = -1;
+var SubMenuGraphSettingsKey = "";
+
+var SubMenuActive = -1;
+var SubMenuTimeoutBase = 0.7;
+var SubMenuMouseX = 0;
+var SubMenuMouseY = 0;
+var SubMenuTimeout = new Date();
+var MenuItems = [];
+var FilterInputTimersValue = '';
+var FilterInputGroupsValue = '';
+var FilterInputModulesValue = '';
+var FilterInputFunctionsValue = '';
+var FilterInputPatchedValue = '';
+
+
+function MakeMenuItem(name, f, visible)
+{
+	var Item = {};
+	Item.name = name;
+	Item.f = f;
+	Item.w = name.length;
+	Item.x = 0;
+	Item.y = 0;
+	Item.visible = visible;
+	return Item;
+}
+function EnableMenu(m)
+{
+	if(m != SubMenuActive)
+	{
+		if(SubMenuActive == SubMenuTimers)
+		{
+			FilterInputTimersValue = FilterInput.value;
+		}
+		else if(SubMenuActive == SubMenuGroup)
+		{
+			FilterInputGroupsValue = FilterInput.value;
+		}
+		else if(SubMenuActive == SubMenuModules)
+		{
+			FilterInputModulesValue = FilterInput.value;
+		}
+		else if(SubMenuActive == SubMenuFunctions)
+		{
+			FilterInputFunctionsValue = FilterInput.value;
+		}
+		else if(SubMenuActive == SubMenuPatched)
+		{
+			FilterInputPatchedValue = FilterInput.value;
+		}
+
+		SubMenuActive = m;
+		SubMenuTimeout = new Date();
+
+		if(SubMenuActive == SubMenuTimers)
+		{
+			FilterInput.value = FilterInputTimersValue;
+		}
+		else if(SubMenuActive == SubMenuGroup)
+		{
+			FilterInput.value = FilterInputGroupsValue;
+		}
+		else if(SubMenuActive == SubMenuModules)
+		{
+			FilterInput.value = FilterInputModulesValue;
+		}
+		else if(SubMenuActive == SubMenuFunctions)
+		{
+			FilterInput.value = FilterInputFunctionsValue;
+		}
+		else if(SubMenuActive == SubMenuPatched)
+		{
+			FilterInput.value = FilterInputPatchedValue;
+		}
+
+		FilterInputValueLast = FilterInput.value;
+	}
+	if(m == -1)
+	{
+		SubMenuTimeout = 0;
+	}
+
+	if(SubMenuActive == SubMenuTimers || SubMenuActive == SubMenuGroup || SubMenuActive == SubMenuModules || SubMenuActive == SubMenuFunctions || SubMenuActive == SubMenuPatched)
+	{
+		FilterInputDiv.style['display'] = 'inline';
+		FilterInput.focus();
+	}
+	else
+	{
+		FilterInputDiv.style['display'] = 'none';
+	}
+}
+
+function Clamp(v, low, high)
+{
+	return v < low ? low : (v > high ? high : v);
+}
+function TriggerCapture()
+{
+	if(Settings.CaptureDelay <= 0)
+	{
+		Capture();
+	}
+	else
+	{
+		CaptureTriggerTime = new Date();
+		CaptureTriggerTimeType = 1;
+	}
+}
+function CaptureUpdate()
+{
+	if(CaptureTriggerTime)
+	{
+		let Time = new Date();
+		let Delta = Time - CaptureTriggerTime;
+		CaptureTriggerDelta = Math.max(0.0, (Settings.CaptureDelay * 1000 - Delta) / 1000.0);
+		if(Delta > Settings.CaptureDelay * 1000)
+		{
+			if(CaptureTriggerTimeType == 1)
+			{
+				Capture();
+			}
+			else if(CaptureTriggerTimeType == 2)
+			{
+				AutoCaptureEnabled = Settings.AutoCaptureRepeat > 0 ? Settings.AutoCaptureRepeat : 1;
+			}
+			CaptureTriggerTime = null;
+			CaptureTriggerDelta = 0;
+			CaptureTriggerTimeType = 0;
+		}
+	}
+
+}
+function Capture()
+{
+	AutoCaptureCooldown = Settings.CaptureFrames + 5;
+	var ext = '' + Settings.CaptureFrames;
+	if(MouseDragActiveXEnd > MouseDragActiveXStart)
+	{
+		var idx0 = Math.ceil(FRAME_COUNT * MouseDragActiveXStart / nWidth);
+		var idx1 = Math.floor(FRAME_COUNT * MouseDragActiveXEnd / nWidth);
+		idx0 = Clamp(idx0, 0, FRAME_COUNT-1);
+		idx1 = Clamp(idx1, 0, FRAME_COUNT-1);
+		var id0 = FrameData.Ids[idx0];
+		var id1 = FrameData.Ids[idx1];
+		ext = 'r/'+id0+'/'+id1;
+	}
+	var url = 'http://' + WSHost + ':' + WSPort + '/' + ext;
+	window.open(url);
+}
+function InitMenu()
+{
+	MenuItems = [];
+	MenuItems.push(MakeMenuItem("Control", function(){EnableMenu(SubMenuGroup); } ));
+	MenuItems.push(MakeMenuItem("Timers", function(){EnableMenu(SubMenuTimers); } ));
+	MenuItems.push(MakeMenuItem("Modules", function(){EnableMenu(SubMenuModules); } ));
+	MenuItems.push(MakeMenuItem("Functions", function(){EnableMenu(SubMenuFunctions); } ));
+	MenuItems.push(MakeMenuItem("Patched", function(){EnableMenu(SubMenuPatched); }, function(){ return FunctionsInstrumented.length > 0;} ));
+	MenuItems.push(MakeMenuItem("Settings", function(){ EnableMenu(SubMenuSettings); } ));
+	MenuItems.push(MakeMenuItem("Views", function(){ EnableMenu(SubMenuViews); } ));
+	MenuItems.push(MakeMenuItem("Presets", function(){ EnableMenu(SubMenuPresets); } ));
+	MenuItems.push(MakeMenuItem("Columns", function(){ EnableMenu(SubMenuColumns); } ));
+}
+function DrawTopMenu()
+{
+	var context = CanvasDetailedView.getContext('2d');
+	var X = 2;
+	var Y = 0;
+	var MouseInY = MouseY < BoxHeight;
+	for(var i = 0; i < MenuItems.length; ++i)
+	{
+		if(i == SubMenuColumns)
+		{
+			if(Settings.ViewActive == VIEW_GRAPH_SPLIT ||
+				Settings.ViewActive == VIEW_GRAPH_THREAD_GROUP ||
+				Settings.ViewActive == VIEW_GRAPH_PERCENTILE ||
+				Settings.ViewActive == VIEW_COUNTERS)
+			{
+				continue;
+			}
+		}
+		var Item = MenuItems[i];
+		if(Item.visible == null || Item.visible())
+		{
+			var w = context.measureText(Item.name).width + 4;
+			var MouseIn = MouseInY && MouseX >= X && MouseX < X + w;
+			var color = MouseIn ? nBackColors[1] : "black";
+			Item.x = X;
+			Item.y = Y + BoxHeight;
+			if(MouseIn)
+			{
+				context.fillStyle = 'white';
+				context.fillRect(X-2, Y, w+4, BoxHeight);
+				// Enable
+				EnableMenu(i);
+			}
+			context.fillStyle = color;
+			context.fillRect(X, Y, w, BoxHeight);
+			context.fillStyle = "white";
+			context.fillText(Item.name, X+2, Y+BoxHeight-FontAscent);
+			if(MouseIn && MouseReleased)
+			{
+				Item.f();
+			}
+			X += w + 6;
+		}
+	}
+}
+
+function AggregateMenuSize()
+{
+	var w = 250 + 5 + FontWidth;
+	return WindowRect(nWidth / 2 - w / 2,HistoryHeight + 50, w, nHeight);
+}
+function TimerMenuSize()
+{
+	return MenuSize(WidthArray[TYPE_TIMER] + WidthArray[TYPE_GROUP] + 5 + FontWidth);
+}
+
+function GroupMenuSize()
+{
+	return MenuSize(WidthTree);
+}
+
+function MenuSize(w)
+{
+	return WindowRect(nWidth / 2 - w / 2, HistoryHeight + 50,w, nHeight);
+}
+
+function CreateFilter(Filter)
+{
+	if(!Filter || Filter.length == 0)
+	{
+		return null;
+	}
+	Filter = Filter.split(' ');
+
+	var regexp = "";
+	for(var i = 0; i < Filter.length; ++i)
+	{
+		regexp = regexp + ".*" + Filter[i];
+	}
+	Filter = new Array();
+	regexp = regexp + ".*";
+	Filter.push(new RegExp(regexp, "i"));
+	return Filter;
+}
+
+function FilterMatch(FilterArray, value)
+{
+	if(!FilterArray)
+		return true;
+	for(var i = 0; i < FilterArray.length; ++i)
+	{
+		var res = value.search(FilterArray[i]);
+		if(res<0)
+			return false;
+	}
+	return true;
+}
+
+function AddPreset(Name)
+{
+	var O = {};
+	O[Name] = {};
+	var OO = {};
+	OO.p = O;
+	OO.r = {};
+	AddPresets(OO);
+}
+function JSONTryParse(str)
+{
+	if(typeof str == 'string')
+	{
+		try{
+			return JSON.parse(str);
+		}
+		catch(e){}
+	}
+	return {};
+}
+
+function ProcessPresets(Data, Names, Cache)
+{
+	for(var idx in Data)
+	{
+		if(Names.indexOf(idx) == -1)
+		{
+			Names.push(idx);
+		}
+		Cache[idx] = JSONTryParse(Data[idx]);
+	}
+}
+function AddPresets(Obj)
+{
+	var Names = Obj.p;
+	var ReadOnlyNames = Obj.r;
+	ProcessPresets(Obj.p, Presets, PresetsCache);
+	ProcessPresets(Obj.r, ReadOnlyPresets, ReadOnlyPresetsCache);
+}
+function GetFullName(T)
+{
+	var parent = T.parent;
+	var ParentName = "unknown";
+	var Name = T.name;
+	if(parent && parent < TimerArray.length)
+	{
+		ParentName = TimerArray[parent].name;
+	}
+	return ParentName + "/" + Name;
+}
+
+function ColorFromFullName(name, type)
+{
+	for(var i = 0; i < TimerArray.length; ++i)
+	{
+		var t = TimerArray[i];
+		if(t.idtype == type && GetFullName(t) == name)
+		{
+			return t.color;
+		}
+	}
+	return 'white';
+
+}
+function EnableByName(name, type)
+{
+	for(var i = 0; i < TimerArray.length; ++i)
+	{
+		var t = TimerArray[i];
+		if(t.idtype == type && GetFullName(t) == name)
+		{
+			WSSendMessage("c" + t.id);
+		}
+	}
+}
+
+
+function OnLoadPreset(NewSettings, Apply, RO)
+{
+	if(Apply)
+	{
+		WSSendMessage("d");
+		PresetPending = 0;
+	}
+	ActivePreset = NewSettings.PresetName;
+	ActivePresetRO = RO ? 1 : 0;
+	console.log('loading preset ' + ActivePresetRO);
+	var EnableCount = 0;
+	for(var idx in NewSettings)
+	{
+		if(idx == 'Timers')
+		{
+			if(Apply)
+			{
+				var Timers = NewSettings[idx];
+				for(var i = 0; i < Timers.length; ++i)
+				{
+					var FullName = Timers[i];
+					EnableCount++;
+					EnableByName(FullName, TYPE_TIMER);
+				}
+			}
+		}
+		else if(idx == 'Groups')
+		{
+			if(Apply)
+			{
+				var Groups = NewSettings[idx];
+				for(var i = 0; i < Groups.length; ++i)
+				{
+					var FullName = Groups[i];
+					EnableByName(FullName, TYPE_GROUP);
+
+				}
+			}
+		}
+		else
+		{
+			Settings[idx] = NewSettings[idx];
+		}
+	}
+
+	if(Settings.FunctionsInstrumented && Apply)
+	{
+		if(Settings.FunctionsInstrumented.length == Settings.FunctionsInstrumentedModule.length && Settings.FunctionsInstrumented.length == Settings.FunctionsInstrumentedUnmangled.length)
+		{
+			var Msg = "D" + Settings.FunctionsInstrumented.length + " ";
+			for(var i = 0; i < Settings.FunctionsInstrumented.length; ++i)
+			{
+				Msg += Settings.FunctionsInstrumentedModule[i] + "!" + Settings.FunctionsInstrumentedUnmangled[i] + "!";
+			}
+			WSSendMessage(Msg);
+		}
+	}
+	if(Settings.ViewActive >= 0)
+	{
+		ResizeCanvas();
+	}
+}
+function SanitizeString(s)
+{
+	let r = "";
+	for(let i = 0; i < s.length; ++i)
+	{
+		let c = s[i];
+		if(!((c>='a' && c<='z') || (c >='A' && c <= 'Z') || (c >= '0' && c <= '9')))
+		{
+			r += '_';
+		}
+		else
+		{
+			r += c;
+		}
+	}
+	return r;
+}
+function LoadPreset(Name, RO)
+{
+	Name = SanitizeString(Name);
+	WSSendMessage((RO?"m":"l")+Name);
+}
+
+function SavePreset(Name)
+{
+	Name = SanitizeString(Name);
+	AddPreset(Name);
+	var Timers = [];
+	var Groups = [];
+	for(var i = 0; i < TimerArray.length; ++i)
+	{
+		var t = TimerArray[i];
+		var idtype = TimerArray[i].idtype;
+		if(t.e)
+		{
+			if(idtype == TYPE_TIMER)
+			{
+				Timers.push(GetFullName(t));
+			}
+			else if(idtype == TYPE_GROUP)
+			{
+				Groups.push(GetFullName(t));
+			}
+		}
+	}
+
+	Settings.Timers = Timers;
+	Settings.Groups = Groups;
+	Settings.PresetName = Name;
+	let Clone = function(A)
+	{
+		let N = Array(A.length);
+		for(var i = 0; i < A.length; ++i)
+		{
+			N[i] = A[i];
+		}
+		return N;
+	};
+	Settings.FunctionsInstrumented = Clone(FunctionsInstrumented);
+	Settings.FunctionsInstrumentedModule = Clone(FunctionsInstrumentedModule);
+	Settings.FunctionsInstrumentedUnmangled = Clone(FunctionsInstrumentedUnmangled);
+
+	var JsonSettings = JSON.stringify(Settings);
+	console.log('settings stored ' + JsonSettings);
+	WSSendMessage("s"+Name+","+JsonSettings);
+	ActivePreset = Name;
+	ActivePresetRO = 0;
+}
+function DrawMenuPresets()
+{
+	var Selection = null;
+	var SizeInfo = {};
+	SizeInfo.h = BoxHeight * (Presets.length * 2);
+	if(ReadOnlyPresets.length)
+	{
+		SizeInfo.h += BoxHeight * (Presets.length + 1);
+	}
+	var x = MenuItems[SubMenuPresets].x;
+	var y = MenuItems[SubMenuPresets].y;
+
+	var Width = 50;
+	var WLeft = MeasureArray(0, ["Save ", "Load ", "Save As ..", "Builtin" ]);
+	Width = MeasureArray(Width, Presets);
+	var Width = 35 + Width + WLeft;
+	SizeInfo.w = Width;
+	SizeInfo.x = x;
+	SizeInfo.y = y;
+
+	var M = CreateMenuState(SizeInfo);
+	var context = CanvasDetailedView.getContext('2d');
+
+	var SettingsCached;
+	var SettingsCachedY = 0;
+
+	for(var i = 0; i < Presets.length; ++i)
+	{
+		var Active = (ActivePresetRO == 0 && ActivePreset == Presets[i]) ? 1 : 0;
+		if(DrawMenuElementMouseIn(M))
+		{
+			SettingsCachedY = M.y;
+			SettingsCached = PresetsCache[Presets[i]];
+		}
+
+		if(DrawMenuElement(M, Active, "Load", Presets[i], 'white', 0))
+		{
+			LoadPreset(Presets[i]);
+		}
+	}
+	DrawMenuElement(M, 0, "---", "", 'white', 0);
+	if(DrawMenuElement(M, 0, "Save As..", "", 'white', 0))
+	{
+		var str = ShowPrompt('Enter Preset Name', '');
+		if(str.length>1)
+		{
+			SavePreset(str);
+		}
+
+	}
+
+	for(var i = 0; i < Presets.length; ++i)
+	{
+		var Active = (ActivePresetRO == 0 && ActivePreset == Presets[i]) ? 1 : 0;
+		if(DrawMenuElement(M, Active, "Save", Presets[i], 'white', 0))
+		{
+			SavePreset(Presets[i]);
+		}
+	}
+	if(ReadOnlyPresets && ReadOnlyPresets.length > 0)
+	{
+		DrawMenuElement(M, 0, "---", "", 'white', 0);
+		for(var i = 0; i < ReadOnlyPresets.length; ++i)
+		{
+			var Active = (ActivePresetRO && ActivePreset == ReadOnlyPresets[i]) ? 1 : 0;
+			if(DrawMenuElementMouseIn(M))
+			{
+				SettingsCachedY = M.y;
+				SettingsCached = ReadOnlyPresetsCache[ReadOnlyPresets[i]];
+			}
+			if(DrawMenuElement(M, Active, "Builtin", ReadOnlyPresets[i], 'white', 0))
+			{
+				LoadPreset(ReadOnlyPresets[i], 1);
+			}
+		}
+	}
+	SizeInfo.h = M.y - SizeInfo.y;
+
+
+	if(SettingsCached)
+	{
+		var SizeLeft = 10 * FontWidth;
+		var Timers = SettingsCached.Timers;
+		var Groups = SettingsCached.Groups;
+		var Patched = SettingsCached.Patched;
+		var W = 0;
+		var H = 0;
+		if(Timers)
+		{
+			W = MeasureArray(W, Timers);
+			H = 1 + Timers.length;
+		}
+		if(Groups)
+		{
+			W = MeasureArray(W, Groups);
+			H = 1 + Groups.length;
+		}
+		if(Patched)
+		{
+			W = MeasureArray(W, Patched);
+			H = 1 + Patched.length;
+		}
+		W += 40;
+		H = H * (FontHeight+1);
+		var M = CreateMenuState(SizeInfo);
+		M.x += M.w + 5;
+		M.y = SettingsCachedY;
+		M.w = W;
+		M.h = H;
+
+		if(Groups && Groups.length)
+		{
+			DrawMenuElement(M, 0, "Groups", "", 'white', 0);
+			for(var i = 0; i < Groups.length; ++i)
+			{
+				DrawMenuElement(M, 0, "", Groups[i], 'white', 0);
+			}
+		}
+		if(Timers && Timers.length)
+		{
+			DrawMenuElement(M, 0, "Timers", "", 'white', 0);
+			for(var i = 0; i < Timers.length; ++i)
+			{
+				DrawMenuElement(M, 0, "", Timers[i], ColorFromFullName(Timers[i], TYPE_TIMER), 0);
+			}
+		}
+		if(Patched && Patched.length)
+		{
+			DrawMenuElement(M, 0, "Patched", "", 'white', 0);
+			for(var i = 0; i < Patched.length; ++i)
+			{
+				DrawMenuElement(M, 0, "", Patched[i], 'white', 0);
+			}
+		}
+
+
+	}
+
+	return SizeInfo;
+}
+
+function DrawMenuColumns()
+{
+	var Selection = null;
+	var SizeInfo = {};
+	var BarColumnNames = GetBarColumnNames();
+	var BarColumnEnabled = GetBarColumnEnabled();
+	SizeInfo.h = BoxHeight * (BarColumnNames.length);
+	var x = MenuItems[SubMenuColumns].x;
+	var y = MenuItems[SubMenuColumns].y;
+
+	var Width = MeasureArray(0, BarColumnNames);
+	SizeInfo.w = Width;
+	SizeInfo.x = x;
+	SizeInfo.y = y;
+
+	var M = CreateMenuState(SizeInfo);
+	var context = CanvasDetailedView.getContext('2d');
+	context.fillRect(M.x, M.y, Width, SizeInfo.h);
+
+
+	for(var i = 0; i < BarColumnNames.length; ++i)
+	{
+		var Active = ActivePreset == Presets[i] ? 1 : 0;
+		if(DrawMenuElement(M, BarColumnEnabled[i], BarColumnNames[i], "", 'white', 0))
+		{
+			BarColumnEnabled[i] = !BarColumnEnabled[i];
+			for(var j = 0; j < ColumnsWidth.length; ++j)
+			{
+				ColumnsWidth[i] = 20;
+			}
+		}
+	}
+
+	SizeInfo.h = M.y - SizeInfo.y;
+	return SizeInfo;
+
+}
+
+
+function ToggleView()
+{
+	Settings.ViewActive = (Settings.ViewActive+1) % VIEW_SIZE;
+	ActivateView(Settings.ViewActive);
+}
+
+function ActivateView(idx)
+{
+	for(var i = 1; i < Views.length; ++i)
+	{
+		Views[i].visible = false;
+	}
+	if(idx == VIEW_GRAPH_SPLIT)
+	{
+		MainView.DisplayFunc = DrawGraphSplit;
+		MainView.visible = true;
+	}
+	else if(idx == VIEW_GRAPH_PERCENTILE)
+	{
+		MainView.DisplayFunc = DrawGraphPercentile;
+		MainView.visible = true;
+	}
+	else if(idx == VIEW_GRAPH_THREAD_GROUP)
+	{
+		MainView.DisplayFunc = DrawGraphThreadGroup;
+		MainView.visible = true;
+	}
+	else if(idx == VIEW_BAR)
+	{
+		MainView.DisplayFunc = DrawTableView;
+		MainView.visible = true;
+	}
+	else if(idx == VIEW_COUNTERS)
+	{
+		MainView.DisplayFunc = DrawCounterView;
+		MainView.visible = true;
+	}
+	else if(idx == VIEW_BAR_SINGLE || idx == VIEW_BAR_ALL)
+	{
+		for(var i = 0; i < X7Views.length; ++i)
+		{
+			X7Views[i].visible = true;
+		}
+		SingleTimerBars = idx == VIEW_BAR_SINGLE;
+	}
+	Settings.ViewActive = idx;
+	X7BarColumnMask = -1;
+	ViewBarMaxMsTextLength  = 0;
+	var hest = 3;
+}
+function DrawMenuViews()
+{
+	var ViewClick = function(idx, name)
+	{
+		ActivateView(idx);
+	};
+	var x = MenuItems[SubMenuViews].x;
+	var y = MenuItems[SubMenuViews].y;
+	return DrawMenuGeneric(ViewNames, Settings.ViewActive, ViewClick, x, y, ViewNames2);
+}
+
+function TweakValue(Value, Tweak, amount, Min, Max)
+{
+	var V = 0.98;
+	if(Tweak<0)
+	{
+		for(var x = 0; x < Math.abs(Tweak); ++x)
+		{
+			var newValue = Math.floor(Value*V);
+			if(newValue == Value)
+			{
+				Value--;
+			}
+			else
+			{
+				Value = newValue;
+			}
+		}
+	}
+	else
+	{
+		var RcpV = 1.0 / V;
+
+		for(var x = 0; x < Tweak; ++x)
+		{
+			var newValue = Math.ceil(Value*RcpV);
+			if(newValue == Value)
+			{
+				Value++;
+			}
+			else
+			{
+				Value = newValue;
+			}
+		}
+	}
+	if(Min!=null && Value < Min)
+		Value = Min;
+	if(Max!=null && Value > Max)
+		Value = Max;
+	return Value;
+
+}
+
+function NextValue(Presets, Value, Dir)
+{
+	var idx = 0;
+	if(Dir > 0)
+	{
+		for(idx = 0;idx < Presets.length; ++idx)
+		{
+			if(Presets[idx] > Value)
+			{
+				break;
+			}
+		}
+	}
+	else
+	{
+		for(idx = Presets.length; idx >= 0; idx -= 1)
+		{
+			if(Presets[idx] < Value)
+			{
+				break;
+			}
+		}
+	}
+	idx = (idx + Presets.length) % Presets.length;
+	return Presets[idx];
+}
+function AutoCaptureRoll(Direction, Tweak, SetDirect)
+{
+	if(SetDirect)
+	{
+		Settings.AutoCaptureTheshold = SetDirect;
+	}
+	else if(Tweak)
+	{
+		Settings.AutoCaptureTheshold = TweakValue(Settings.AutoCaptureTheshold, Tweak, 0.98, 1, 500);
+	}
+	else if(Direction)
+	{
+		Settings.AutoCaptureTheshold = NextValue(AutoCaptureThesholdPresets, Settings.AutoCaptureTheshold, Direction);
+	}
+}
+function AutoCaptureRepeatRoll(Direction, Tweak, SetDirect)
+{
+	if(SetDirect)
+	{
+		Settings.AutoCaptureRepeat = SetDirect;
+	}
+	else if(Tweak)
+	{
+		Settings.AutoCaptureRepeat = TweakValue(Settings.AutoCaptureRepeat, Tweak, 0.98, 1, 500);
+	}
+	else if(Direction)
+	{
+		Settings.AutoCaptureRepeat = NextValue(AutoCaptureRepeatPresets, Settings.AutoCaptureRepeat, Direction);
+	}
+}
+function CaptureRoll(Direction, Tweak, SetDirect)
+{
+	if(SetDirect)
+	{
+		Settings.CaptureFrames = SetDirect;
+	}
+	else if(Tweak)
+	{
+		Settings.CaptureFrames = TweakValue(Settings.CaptureFrames, Tweak, 0.98, 5, 300);
+
+	}
+	else if(Direction)
+	{
+		Settings.CaptureFrames = NextValue(CaptureFramesPresets, Settings.CaptureFrames, Direction);
+	}
+}
+function CaptureDelayRoll(Direction, Tweak, SetDirect)
+{
+	if(SetDirect)
+	{
+		Settings.CaptureDelay = SetDirect;
+	}
+	else if(Tweak)
+	{
+		Settings.CaptureDelay = TweakValue(Settings.CaptureDelay, Tweak, 0.98, 5, 300);
+
+	}
+	else if(Direction)
+	{
+		Settings.CaptureDelay = NextValue(CaptureDelayPresets, Settings.CaptureDelay, Direction);
+	}
+}
+
+function GetAutoCaptureString()
+{
+	if(AutoCaptureSourceIndex >= 0)
+	{
+		if(AutoCaptureSourceIndex >= EnabledArray.length)
+		{
+			AutoCaptureSourceIndex = -1;
+			AutoCaptureSourceIndex = -1;
+		}
+		else
+		{
+			var idx = EnabledArray[AutoCaptureSourceIndex];
+			return TimerArray[idx].name;
+		}
+	}
+	return "Frame Time";
+}
+
+function AutoCaptureSourceRoll(Direction, Tweak, SetDirect)
+{
+	if(SetDirect)
+	{
+
+	}else if(Tweak||Direction)
+	{
+		if(!Direction)
+			Direction = Tweak;
+		if(Direction<0)
+		{
+			AutoCaptureSourceIndex--;
+			if(AutoCaptureSourceIndex<-1)
+			{
+				AutoCaptureSourceIndex = EnabledArray.length-1;
+			}
+		}
+		else
+		{
+			AutoCaptureSourceIndex++;
+			if(AutoCaptureSourceIndex >= EnabledArray.length)
+			{
+				AutoCaptureSourceIndex = -1;
+			}
+		}
+
+	}
+}
+
+function ShowPrompt(Title, Value, Type)
+{
+	var v;
+	if(Type == 'int')
+	{
+		var newValue = prompt('' + Title, '' + Value);
+		v = parseInt(newValue);
+	}
+	else if(Type == 'float')
+	{
+		var newValue = prompt('' + Title, '' + Value);
+		v = parseFloat(newValue);
+	}
+	else
+	{
+		var v = prompt('' + Title, '' + Value);
+		return v;
+	}
+	if(isNaN(v))
+	{
+		return Value;
+	}
+	else
+	{
+		return v;
+	}
+
+}
+function MeasureArray(v, A, f)
+{
+	var context = CanvasDetailedView.getContext('2d');
+	for(var i = 0; i < A.length; ++i)
+	{
+		var s = A[i];
+		if(f)
+			s=f(s, i);
+		var l = context.measureText(s).width;
+		v = v < l ? l : v;
+	}
+	return v;
+}
+
+function CreateMenuState(SizeInfo)
+{
+	var MenuState = {};
+	for(var i in SizeInfo)
+	{
+		MenuState[i] = SizeInfo[i];
+	}
+	MenuState.cidx = 0;
+	return MenuState;
+}
+function DrawMenuElementMouseIn(M)
+{
+	return MouseY >= M.y && MouseY < M.y + BoxHeight;
+}
+function DrawMenuElement(M, Selected, Name, Value, color)
+{
+	var context = CanvasDetailedView.getContext('2d');
+
+	var bMouseIn = DrawMenuElementMouseIn(M);
+	var YText = M.y + BoxHeight - FontAscent;
+
+	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[M.cidx];
+	context.fillStyle = Selected?'white':bgcolor;
+	context.fillRect(M.x-2, M.y, M.w + 4, BoxHeight);
+	context.fillStyle = bgcolor;
+	context.fillRect(M.x, M.y, M.w, BoxHeight);
+	context.fillStyle = color;
+	context.fillText(Name, M.x, YText);
+	context.textAlign = 'right';
+	context.fillText('' + Value, M.x + M.w - 2, YText);
+	context.textAlign = 'left';
+	M.cidx = 1-M.cidx;
+	M.y += BoxHeight;
+	return bMouseIn && MouseReleased;
+}
+function DrawMenuRoll(M, Name, RollValue, RollExt, RollFunction, Tweak, Type)
+{
+	var context = CanvasDetailedView.getContext('2d');
+
+	var YText = M.y + BoxHeight - FontAscent;
+	var SizeMinus = context.measureText('-').width;
+	var SizePlus = context.measureText('+').width;
+
+	var bMouseIn = MouseY >= M.y && MouseY < M.y + BoxHeight;
+	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[M.cidx];
+	context.fillStyle = bgcolor;
+	context.fillRect(M.x-2, M.y, M.w+4, BoxHeight);
+	context.fillStyle = 'white';
+	context.fillText(Name, M.x, YText);
+	context.textAlign = 'right';
+	var XTemp = M.x + M.w - 3;
+
+	if(KeyShiftDown && bMouseIn)
+	{
+		if(Tweak>=0)
+		{
+			RollFunction(0, MouseX-Tweak);
+		}
+		Tweak = MouseX;
+		bMouseIn = false;
+	}
+	else
+	{
+		Tweak = -1;
+	}
+
+	var MouseReleasedUsed = false;
+	if(bMouseIn && MouseX >= XTemp - SizePlus && MouseX <= XTemp)
+	{
+		context.fillStyle = 'red';
+		if(MouseReleased)
+		{
+			RollFunction(1);
+			MouseReleasedUsed = true;
+		}
+	}
+	else
+	{
+		context.fillStyle = 'white';
+	}
+	context.fillText('+', XTemp, YText);
+	XTemp -= SizePlus + 3;
+
+
+
+	if(bMouseIn && MouseX >= XTemp - SizeMinus && MouseX <= XTemp)
+	{
+		context.fillStyle = 'red';
+		if(MouseReleased)
+		{
+			RollFunction(-1);
+			MouseReleasedUsed = true;
+		}
+	}
+	else
+	{
+		context.fillStyle = 'white';
+	}
+
+	context.fillText('-', XTemp, YText);
+	XTemp -= SizeMinus + 3;
+	var RollText = ''+RollValue + RollExt;
+	var RollWidth = context.measureText(RollText).width;
+	context.fillStyle = 'white';
+
+	context.fillText(RollText, XTemp, YText);
+	XTemp -= RollWidth;
+
+	context.textAlign = 'left';
+
+	M.cidx = 1-M.cidx;
+
+	M.y += BoxHeight;
+	if(Type && MouseReleased && bMouseIn && !MouseReleasedUsed)
+	{
+		var V = ShowPrompt(Name, RollValue, Type);
+		RollFunction(0,0,V);
+	}
+	return Tweak;
+
+}
+function CheckPopupAllowed()
+{
+	if(!PopupsAllowed && !PopupTestPending)
+	{
+		PopupTestPending = 1;
+		PopupsAllowed = 0;
+		PopupsFailed = 0;
+		let DoPopupTest = function()
+		{
+			var W = window.open("about:blank");
+			var Fail = function()
+			{
+				PopupTestPending = 0;
+				PopupsFailed = 1;
+				PopupsAllowed = 0;
+			};
+			var Check = function()
+			{
+				if(!(W.innerHeight>0))
+					Fail();
+				else
+				{
+					PopupTestPending = 0;
+					PopupsFailed = 0;
+					PopupsAllowed = 1;
+					W.close();
+				}
+			};
+			if(W)
+			{
+				if(/chrome/.test(navigator.userAgent.toLowerCase()))
+					setTimeout(Check, 200);
+				else
+					W.onload = Check;
+			}
+			else
+			{
+				Fail();
+			}
+		};
+		setTimeout(DoPopupTest, 5000);
+	}
+}
+
+function GetSubGraphReferenceTime(SubGraphSettings, TimerState)
+{
+	if(SubGraphSettings.AutomaticReference)
+	{
+	 	return TimerState.historymaxsoft ? TimerState.historymax : TimerState.historymax;
+	}
+	else
+	{
+		return SubGraphSettings.ReferenceTime;
+	}
+}
+function GetSubGraphSettingsKey(key)
+{
+	if(Settings.ViewActive == VIEW_GRAPH_PERCENTILE)
+	{
+		return "perc_"+key;
+	}
+	else
+	{
+		return key;
+	}
+}
+function GetSubGraphSettings(key)
+{
+	let k = GetSubGraphSettingsKey(key);
+	let SubGraphSettings = Settings.SubGraphSettings[k];
+	if(!SubGraphSettings)
+	{
+		SubGraphSettings = {"ReferenceTime":10.0, "TargetTime":-1, "AutomaticReference":1, "Percentile":0.0};
+		Settings.SubGraphSettings[k] = SubGraphSettings;
+	}
+	return SubGraphSettings;
+}
+
+
+function DrawMenuGraphSettings()
+{
+	let Percentile = Settings.ViewActive == VIEW_GRAPH_PERCENTILE;
+	let Selection = null;
+	let SizeInfo = {};
+	SizeInfo.h = (Percentile?3:2) * BoxHeight;
+	let Strings = ["AutoCapture Enabled", "AutoCapture Threshold", "AutoCapture Source", "Capture Length"];
+	let wLeft = MeasureArray(0, Strings);
+	let wRight = 50;
+	wRight = MeasureArray(wRight, ["Frame Time"]);
+	wRight = MeasureArray(wRight, EnabledArray, function(a){return TimerArray[a].name; } );
+	let Width = wLeft + 35 + wRight;
+	SizeInfo.w = Width;
+	SizeInfo.x = CaptureButtonX;
+	SizeInfo.y = CaptureButtonY;
+
+	let M = CreateMenuState(SizeInfo);
+	let context = CanvasDetailedView.getContext('2d');
+	context.fillRect(M.x, M.y, Width, SizeInfo.h);
+	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);
+
+
+	ReferenceTimeTweak = DrawMenuRoll(M, "Reference Time", SubGraphSettings.ReferenceTime, '', ReferenceRollSubGraph, ReferenceTimeTweak, 'int');
+	if(DrawMenuElement(M, SubGraphSettings.AutomaticReference, "Automatic Reference Time", SubGraphSettings.AutomaticReference, 'white'))
+	{
+		SubGraphSettings.AutomaticReference = 1-SubGraphSettings.AutomaticReference;
+	}
+	if(Percentile)
+	{
+		//PercentileTweak = DrawMenuRoll(M, "Percentile", SubGraphSettings.Percentile, '', PercentileRollSubGraph, PercentileTweak, 'int');
+		if(DrawMenuElement(M, 0, "Clear Aggregate", "", 'white'))
+		{
+			let TimerMap = FrameData.TimerMap;
+			if(TimerMap)
+			{
+				let TimerState = TimerMap[SubMenuGraphSettingsKey];
+				TimerState.PercentileMax = -1e38;
+				TimerState.PercentileMin = 1e38;
+				TimerState.Percentile = new Float32Array(PERCENTILE_SAMPLES);
+				TimerState.Percentile.fill(0.0);
+				TimerState.PercentileCount = 0;
+			}
+		}
+	}
+	SizeInfo.h = M.y - SizeInfo.y;
+	return SizeInfo;
+
+}
+
+function Dots()
+{
+	let t = new Date().getMilliseconds() / 200;
+	let dots = [".  ",".. ","...",".. "];
+	let x = Math.floor(t) %4;
+	return dots[x];
+}
+function DrawMenuCapture()
+{
+	let Selection = null;
+	let SizeInfo = {};
+	SizeInfo.h = 7 * BoxHeight;
+	let Strings = ["Popups Allowed", "AutoCapture Enabled", "AutoCapture Threshold", "AutoCapture Source", "Capture Length", "Capture Delay"];
+	let wLeft = MeasureArray(0, Strings);
+	let wRight = 50;
+	wRight = MeasureArray(wRight, ["Frame Time"]);
+	wRight = MeasureArray(wRight, EnabledArray, function(a){return TimerArray[a].name; } );
+	let Width = wLeft + 35 + wRight;
+	SizeInfo.w = Width;
+	SizeInfo.x = CaptureButtonX - SizeInfo.w;
+	SizeInfo.y = CaptureButtonY - SizeInfo.h;
+
+	let M = CreateMenuState(SizeInfo);
+	let context = CanvasDetailedView.getContext('2d');
+	context.fillRect(M.x, M.y, Width, SizeInfo.h);
+	let d = Dots();
+	let PopupStatus = PopupsAllowed ? "Yes" :  (PopupsFailed ? "No" : (PopupTestPending ? ("Testing"+d) : "Untested"));
+	if(DrawMenuElement(M, 0, "Popups Allowed", PopupStatus, 'white', 0))
+	{
+		CheckPopupAllowed();
+	}
+	let AutoStatus = AutoCaptureEnabled > 0 ? "on" : "off";
+	if(CaptureTriggerTime != null && CaptureTriggerTimeType == 2)
+	{
+		AutoStatus = "pending"+d;
+	}
+	if(DrawMenuElement(M, 0, "AutoCapture Enabled", AutoStatus, 'white', 0))
+	{
+		if(!AutoCaptureEnabled && CaptureTriggerTime == null)
+		{
+			if(Settings.CaptureDelay <= 0)
+			{
+				AutoCaptureEnabled = Settings.AutoCaptureRepeat > 0 ? Settings.AutoCaptureRepeat : 1;
+			}
+			else
+			{
+				CaptureTriggerTime = new Date();
+				CaptureTriggerTimeType = 2;
+			}
+		}
+		else
+		{
+			AutoCaptureEnabled = 0;
+			if(CaptureTriggerTimeType == 2)
+			{
+				CaptureTriggerTimeType = 0;
+				CaptureTriggerTime = null;
+			}
+		}
+	}
+	AutoCaptureSourceTweak = DrawMenuRoll(M, "AutoCapture Source", GetAutoCaptureString(), '', AutoCaptureSourceRoll, AutoCaptureSourceTweak);
+	AutoCaptureTweak = DrawMenuRoll(M, "AutoCapture Threshold", Settings.AutoCaptureTheshold, 'ms', AutoCaptureRoll, AutoCaptureTweak, 'int');
+	AutoCaptureRepeatTweak = DrawMenuRoll(M, "AutoCapture Repeat", Settings.AutoCaptureRepeat, '', AutoCaptureRepeatRoll, AutoCaptureRepeatTweak, 'int');
+	CaptureTweak = DrawMenuRoll(M, "Capture Length",  Settings.CaptureFrames, '', CaptureRoll, CaptureTweak, 'int');
+	CaptureDelayTweak = DrawMenuRoll(M, "Capture Delay",  Settings.CaptureDelay, '', CaptureDelayRoll, CaptureDelayTweak, 'int');
+
+	SizeInfo.h = M.y - SizeInfo.y;
+	return SizeInfo;
+
+}
+function WindowRect(x,y,w,h)
+{
+	let s = {};
+	s.x = x;
+	s.y = y;
+	s.w = w;
+	s.h = h;
+	return s;
+}
+function GetAggregateString()
+{
+	if(0 == Settings.AggregateFrames)
+		return 'infinite';
+	else
+		return Settings.AggregateFrames + '';
+}
+
+function AggregateRoll(Direction, Tweak, SetDirect)
+{
+	if(SetDirect || SetDirect == 0)
+	{
+		if(SetDirect <= 0 || SetDirect == 'infinite')
+		{
+			Settings.AggregateFrames = 0;
+		}
+		else
+		{
+			Settings.AggregateFrames = SetDirect;
+		}
+	}
+	else if(Tweak)
+	{
+		Settings.AggregateFrames = TweakValue(Settings.AggregateFrames, Tweak, 0.98, 0, 500);
+
+	}
+	else if(Direction)
+	{
+		Settings.AggregateFrames = NextValue(AggregatePresets, Settings.AggregateFrames, Direction);
+	}
+}
+function ReferenceRoll(Direction, Tweak, SetDirect)
+{
+	if(SetDirect)
+	{
+		Settings.ReferenceTime = SetDirect;
+	}
+	else if(Tweak)
+	{
+		Settings.ReferenceTime = TweakValue(Settings.ReferenceTime, Tweak, 0.98, 5, 1000);
+
+	}
+	else if(Direction)
+	{
+		Settings.ReferenceTime = NextValue(ReferencePresets, Settings.ReferenceTime, Direction);
+	}
+}
+
+function ReferenceRollSubGraph(Direction, Tweak, SetDirect)
+{
+	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);
+	if(SetDirect)
+	{
+		SubGraphSettings.ReferenceTime = SetDirect;
+	}
+	else if(Tweak)
+	{
+		SubGraphSettings.ReferenceTime = TweakValue(SubGraphSettings.ReferenceTime, Tweak, 0.98, 5, 1000);
+
+	}
+	else if(Direction)
+	{
+		SubGraphSettings.ReferenceTime = NextValue(ReferencePresets, SubGraphSettings.ReferenceTime, Direction);
+	}
+}
+
+function PercentileRollSubGraph(Direction, Tweak, SetDirect)
+{
+	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);
+	if(SetDirect)
+	{
+		SubGraphSettings.Percentile = SetDirect;
+	}
+	else if(Tweak)
+	{
+		SubGraphSettings.Percentile = TweakValue(SubGraphSettings.Percentile, Tweak, 0.98, 5, 1000);
+	}
+	else if(Direction)
+	{
+		SubGraphSettings.Percentile = NextValue(PercentilePresets, SubGraphSettings.Percentile, Direction);
+	}
+}
+
+
+function TargetRoll(Direction, Tweak, SetDirect)
+{
+	if(SetDirect)
+	{
+		Settings.TargetTime = SetDirect;
+	}
+	else if(Tweak)
+	{
+		Settings.TargetTime = TweakValue(Settings.TargetTime, Tweak, 0.98, 5, 1000);
+
+	}
+	else if(Direction)
+	{
+		Settings.TargetTime = NextValue(ReferencePresets, Settings.TargetTime, Direction);
+	}
+}
+function TargetRollSubGraph(Direction, Tweak, SetDirect)
+{
+	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);
+	if(SetDirect)
+	{
+		SubGraphSettings.TargetTime = SetDirect;
+	}
+	else if(Tweak)
+	{
+		SubGraphSettings.TargetTime = TweakValue(SubGraphSettings.TargetTime, Tweak, 0.98, 5, 1000);
+
+	}
+	else if(Direction)
+	{
+		SubGraphSettings.TargetTime = NextValue(ReferencePresets, SubGraphSettings.TargetTime, Direction);
+	}
+}
+function DrawMenuSettings()
+{
+	var context = CanvasDetailedView.getContext('2d');
+	var nColorIndex = 0;
+	var SizeInfo = AggregateMenuSize();
+	SizeInfo.x = MenuItems[SubMenuSettings].x;
+	SizeInfo.y = MenuItems[SubMenuSettings].y;
+
+	SizeInfo.w = 200;
+	var M = CreateMenuState(SizeInfo);
+
+	AggregateTweak = DrawMenuRoll(M, "Aggregate Frames", GetAggregateString(), '', AggregateRoll, AggregateTweak, 'int');
+	ReferenceTimeTweak = DrawMenuRoll(M, "Reference Time", Settings.ReferenceTime, '', ReferenceRoll, ReferenceTimeTweak, 'int');
+	TargetTimeTweak = DrawMenuRoll(M, "Target Time", Settings.TargetTime, '', TargetRoll, TargetTimeTweak, 'int');
+	if(DrawMenuElement(M, Settings.AutomaticReference, "Automatic Reference Time", Settings.AutomaticReference, 'white'))
+	{
+		Settings.AutomaticReference = 1-Settings.AutomaticReference;
+	}
+	if(DrawMenuElement(M, Settings.ViewCompressed, "Compressed View", Settings.ViewCompressed, 'white'))
+	{
+		Settings.ViewCompressed = 1-Settings.ViewCompressed;
+		ResizeCanvas();
+	}
+
+	if(Settings.AggregateFrames <= 0)
+	{
+		if(DrawMenuElement(M, 0, "Clear Aggregate", "Current[" + AggregateCurrent + "]", 'white'))
+		{
+			WSSendMessage("r");
+		}
+	}
+	if(DrawMenuElement(M, 0, "Clear Percentile Aggregate", "", 'white'))
+	{
+		let TimerMap = FrameData.TimerMap;
+		if(TimerMap)
+		{
+			for(let key in TimerMap)
+			{
+				let idx = GetTimer(key);
+				let TimerState = TimerMap[key];
+				if(!IsGroup(key) && TimerState.Percentile)
+				{
+					TimerState.PercentileMax = -1e38;
+					TimerState.PercentileMin = 1e38;
+					TimerState.Percentile = new Float32Array(PERCENTILE_SAMPLES);
+					TimerState.Percentile.fill(0.0);
+					TimerState.PercentileCount = 0;
+				}
+			}
+		}
+	}
+
+
+	if(DrawMenuElement(M, Settings.AllowHighDPI, "Allow High DPI", Settings.AllowHighDPI, 'white'))
+	{
+		Settings.AllowHighDPI = 1 - Settings.AllowHighDPI;
+		ResizeCanvas();
+	}
+	if(DrawMenuElement(M, Cookie.CodeReportMode == 0, "Code Report: Prompt", Cookie.CodeReportMode == 0 ? 1 : 0, 'white'))
+	{
+		Cookie.CodeReportMode = 0;
+		WriteCookie();
+	}
+
+	if(DrawMenuElement(M, Cookie.CodeReportMode == 1, "Code Report: Report Silently", Cookie.CodeReportMode == 1 ? 1 : 0, 'white'))
+	{
+		Cookie.CodeReportMode = 1;
+		WriteCookie();
+	}
+	if(DrawMenuElement(M, Cookie.CodeReportMode == 2, "Code Report: Never Report", Cookie.CodeReportMode == 2 ? 1 : 0, 'white'))
+	{
+		Cookie.CodeReportMode = 2;
+		WriteCookie();
+	}
+
+	SizeInfo.h = M.y - SizeInfo.y;
+	return SizeInfo;
+}
+
+function MoveFilterInputDiv(x, y, w)
+{
+	if(FilterInputDivPos.x != x || FilterInputDivPos.y != y || FilterInputDivPos.w != w)
+	{
+		FilterInputDivPos.x = x;
+		FilterInputDivPos.y = y;
+		FilterInputDivPos.w = w;
+		FilterInputDiv.style['left'] = x + 'px';
+		FilterInputDiv.style['top'] = y + 'px';
+		FilterInput.style['width'] = w + 'px';
+	}
+}
+
+function DrawMenuTimer()
+{
+	if(FilterInputValueLast != FilterInput.value)
+	{
+		nOffsetMenuTimers = 0;
+	}
+	FilterInputValueLast = FilterInput.value;
+	var FilterArray = CreateFilter(FilterInput.value);
+	var context = CanvasDetailedView.getContext('2d');
+	var nColorIndex = 0;
+	var SizeInfo = TimerMenuSize();
+	SizeInfo.x = MenuItems[SubMenuTimers].x;
+	SizeInfo.y = MenuItems[SubMenuTimers].y;
+	var Y = SizeInfo.y;
+	var Width = SizeInfo.w;
+	var Selection = null;
+	var X = SizeInfo.x;
+	MoveFilterInputDiv(SizeInfo.x, SizeInfo.y, SizeInfo.w);
+	Y += 35;
+
+	var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
+	var bMouseInClear =  MouseY >= Y && MouseY < Y + BoxHeight;
+	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+	var TextY = Y+BoxHeight-FontAscent;
+	var YClear = Y;
+	var TextYClear = TextY;
+	var YStart = Y;
+
+	var MouseTaken = bMouseIn;
+
+	Y += BoxHeight;
+	nColorIndex = 1-nColorIndex;
+
+	Y -= nOffsetMenuTimers;
+
+	for(var i = 0; i < TimerArray.length; ++i)
+	{
+		var v = TimerArray[i];
+		if(v.idtype == TYPE_TIMER
+		 //|| v.idtype == TYPE_GROUP
+		 )
+		{
+			var Name = v.name;
+			var ParentName = TimerArray[v.parent].name;
+			if(FilterMatch(FilterArray, ParentName + " " + Name) && (0 == TimersActiveOnly || v.e))
+			{
+				if(Y > YStart)
+				{
+					var ParentColor = TimerArray[v.parent].e ? 'white' : 'grey';
+					bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight && !MouseTaken;
+					bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+					TextY = Y+BoxHeight-FontAscent;
+					context.fillStyle = v.e?'white':bgcolor;
+					context.fillRect(X-2, Y, Width+4, BoxHeight);
+					context.fillStyle = bgcolor;
+					context.fillRect(X, Y, Width, BoxHeight);
+					context.fillStyle = ParentColor;
+					context.fillText(ParentName, X + 2, TextY);
+					context.fillStyle = v.color;
+					context.textAlign = 'right';
+					context.fillText(Name, X + Width - 2, TextY);
+					context.textAlign = 'left';
+					if(bMouseIn)
+					{
+						Selection = v.id;
+					}
+				}
+				Y += BoxHeight;
+				nColorIndex = 1-nColorIndex;
+			}
+		}
+	}
+
+	{
+
+		var c0 = nBackColorOffset;
+		var c1 = nBackColors[1];
+		var W = Width + 4;
+		var WHalf = W / 2;
+		var InsideClear = bMouseInClear && MouseX-X< WHalf-1;
+		var InsideActive =  bMouseInClear && MouseX-X > WHalf+1;
+		context.fillStyle = nBackColors[0];
+		context.fillRect(X-2, YClear, W, BoxHeight);
+
+		context.fillStyle = InsideClear ? c0 :c1;
+		context.fillRect(X-2, YClear, WHalf-1, BoxHeight);
+		context.fillStyle = InsideActive ? c0 :c1;
+		context.fillRect(X-2 + WHalf + 1, YClear, WHalf-1, BoxHeight);
+
+
+		context.fillStyle = 'white';
+		context.textAlign = 'center';
+		context.fillText("[clear] ", X + 2 + Width * 0.25, TextYClear);
+		context.fillStyle = TimersActiveOnly ? 'white' : 'grey';
+		context.fillText("[active only]", X + 2 + Width * 0.75, TextYClear);
+		if(MouseReleased)
+		{
+			if(InsideActive)
+			{
+				TimersActiveOnly = 1-TimersActiveOnly;
+			}
+			if(InsideClear)
+			{
+				WSSendMessage("x");
+			}
+		}
+	}
+	context.textAlign = 'left';
+	if(Selection && MouseReleased && !MouseTaken)
+	{
+		WSSendMessage("c" + Selection);
+	}
+	SizeInfo.h = Y-SizeInfo.y;
+	return SizeInfo;
+}
+
+var LoadSymbolAnim = -1;
+function LoadSymbolAnimRestart()
+{
+	if(LoadSymbolAnim > 0)
+	{
+		LoadSymbolAnim += 1;
+	}
+	else
+	{
+		LoadSymbolAnim = 1;
+	}
+}
+function LoadSymbolAnimUpdateAndGet()
+{
+	if(LoadSymbolAnim>=0)
+	{
+		LoadSymbolAnim -= 0.03;
+		if(LoadSymbolAnim < 0)
+		{
+			LoadSymbolAnim = -1;
+		}
+		else
+		{
+			return Math.sin(3.14  * LoadSymbolAnim);
+		}
+
+	}
+	return -1;
+}
+
+
+var CircleSteps = 30;
+var CircleX = Array(CircleSteps);
+var CircleY = Array(CircleSteps);
+function InitCircle()
+{
+	var twopi = 2 * Math.PI;
+	for(var i = 0; i < CircleSteps; ++i)
+	{
+		var s = (1.0*i) / CircleSteps;
+
+		var f = (1.0 * s) * twopi;
+		CircleX[i] = Math.sin(f);
+		CircleY[i] = Math.cos(f);
+	}
+}
+function SpinnerResize(Spinner, w, h)
+{
+	if(h != Spinner.CanvasH || w != Spinner.CanvasW || DPR != Spinner.CanvasDPR)
+	{
+		Spinner.Canvas.style.width = w + 'px';
+		Spinner.Canvas.style.height = h + 'px';
+		Spinner.Canvas.width = w * DPR;
+		Spinner.Canvas.height = h * DPR;
+		Spinner.Canvas.getContext('2d').scale(DPR, DPR);
+		Spinner.CanvasBack.style.width = w + 'px';
+		Spinner.CanvasBack.style.height = h + 'px';
+		Spinner.CanvasBack.width = w * DPR;
+		Spinner.CanvasBack.height = h * DPR;
+
+		Spinner.CanvasBack.getContext('2d').scale(DPR, DPR);
+		Spinner.CanvasH = h;
+		Spinner.CanvasW = w;
+		Spinner.CanvasDPR = DPR;
+	}
+}
+function SpinnerCircle(Phase0, Shift0, Phase1, Shift1, Phase2, Shift2)
+{
+	return {"Phase0" : Phase0, "Shift0": Shift0, "Phase1":Phase1, "Shift1":Shift1, "Phase2": Phase2, "Shift2": Shift2, "Q": 0, "QQ": 0, "A0":0, "A1":0, "A2":0};
+}
+
+function SpinnerInit(Blur, Color)
+{
+	var Spinner = {};
+	Spinner.x = 0;
+	Spinner.y = 0;
+	Spinner.Canvas = document.createElement('canvas');
+	Spinner.CanvasBack = document.createElement('canvas');
+	Spinner.CanvasOffscreenData;
+	Spinner.CanvasW = -1;
+	Spinner.CanvasH = -1;
+	Spinner.CanvasDPR = -1;
+	Spinner.Circles = [];
+	var x = 1 / 4;
+	var y = 0.07;
+	Spinner.Circles.push(SpinnerCircle(x, 0, y, 0, 0.0, 0.25));
+	Spinner.Circles.push(SpinnerCircle(2/4, 0, 0, 0, 0.14, 0.25));
+	Spinner.Fade = 0;
+	Spinner.Blur = Blur;
+	Spinner.Color = Color;
+	return Spinner;
+}
+
+var SpinnerCorner = SpinnerInit(0.8, 'white');
+var SpinnerLoadButton = SpinnerInit(0, 'white');
+var SpinnerText1 = SpinnerInit(0.0, 'red');
+var SpinnerText0 = SpinnerInit(0.0, 'red');
+
+
+function SpinnerShow()
+{
+	return SymbolState != null && (SymbolState.q == 1 || SymbolState.r != SymbolState.f || FunctionQueryLastRequest != FunctionQueryReceived);
+}
+
+function SpinnerDraw(Enable, context, Spinner, X, Y, w, h)
+{
+	SpinnerResize(Spinner, w, h);
+	var ContextSpinner = Spinner.Canvas.getContext('2d');
+
+
+	var now = Date.now();
+	if(!ContextSpinner.last)
+	{
+		ContextSpinner.last = now;
+	}
+	var DT = now - ContextSpinner.last;
+	ContextSpinner.last = now;
+	if(Enable)
+	{
+		Spinner.Fade += DT / 200;
+	}
+	else
+	{
+		Spinner.Fade -= DT / 1000;
+	}
+	Spinner.Fade = Math.max(0, Spinner.Fade);
+	Spinner.Fade = Math.min(1, Spinner.Fade);
+	var F = Spinner.Fade * Spinner.Fade;
+
+	if(Spinner.Fade <= 0)
+		return;
+	ContextSpinner.clearRect(0, 0, w, h);
+	if(Spinner.Blur > 0)
+	{
+		ContextSpinner.globalAlpha = Spinner.Blur;
+		ContextSpinner.drawImage(Spinner.CanvasBack, 0, 0, w, h);
+		ContextSpinner.globalAlpha = 1.0;
+	}
+	var twopi = 2 * Math.PI;
+	for(var jjj = 0; jjj < Spinner.Circles.length; ++jjj)
+	{
+		var C = Spinner.Circles[jjj];
+		InitCircle();
+		var xs = CircleX;
+		var ys = CircleY;
+		var scale = (w-2) / 2;
+		var offset = (w) / 2;
+		var SPEED = 100.0;
+
+		var angle = (C.Q / SPEED) * twopi;
+
+		var QQSPEED = 1000;
+
+		C.A0 += (twopi * DT / 1000.0) * C.Phase0;
+		if(C.A0 > twopi)
+			C.A0 -= twopi;
+		C.A1 += (twopi * DT / 1000.0) * C.Phase1;
+		if(C.A1 > twopi)
+			C.A1 -= twopi;
+		C.A2 += (twopi * DT / 1000.0) * C.Phase2;
+		if(C.A2 > twopi)
+			C.A2 -= twopi;
+
+		var A0 = C.A0 + twopi * C.Shift0;
+		var A1 = C.A1 + twopi * C.Shift1;
+		var A2 = C.A2 + twopi * C.Shift2;
+		var m = Math.cos(A0);
+		var m0 = Math.sin(A2);
+		var cs = Math.cos(A1);
+		var ss = Math.sin(A1);
+		for(var i = 0; i < xs.length; ++i)
+		{
+			var x = xs[i] * m;
+			var y = ys[i] * m0;
+			xs[i] = cs * scale * x - ss * scale * y;
+			ys[i] = ss * scale * x + cs * scale * y;
+			xs[i] += offset;
+			ys[i] += offset;
+		}
+		ContextSpinner.strokeStyle = Spinner.Color;
+		ContextSpinner.beginPath();
+		ContextSpinner.moveTo(xs[0], ys[0]);
+		for(var i = 1; i < CircleSteps; ++i)
+		{
+			ContextSpinner.lineTo(xs[i], ys[i]);
+		}
+		ContextSpinner.lineTo(xs[0], ys[0]);
+		ContextSpinner.stroke();
+
+
+	}
+	context.globalAlpha = F;
+	context.drawImage(Spinner.Canvas, X, Y, w, h);
+	context.globalAlpha = 1;
+	var tmp = Spinner.CanvasBack;
+	Spinner.CanvasBack = Spinner.Canvas;
+	Spinner.Canvas = tmp;
+}
+
+
+function DrawMenuPatched()
+{
+	if(FilterInputValueLast != FilterInput.value)
+	{
+		nOffsetMenuPatched = 0;
+	}
+
+	var FilterArray = CreateFilter(FilterInput.value);
+	var context = CanvasDetailedView.getContext('2d');
+	var nColorIndex = 0;
+	var SizeInfo = TimerMenuSize();
+	SizeInfo.x = MenuItems[SubMenuPatched].x;
+	SizeInfo.y = MenuItems[SubMenuPatched].y;
+	var Y = SizeInfo.y;
+	var Width = SizeInfo.w;
+	Width = Math.max(300, Width);
+	Width = 10+ MeasureArray(Width, FunctionsInstrumented, function(s, i){return s + " " + FunctionsInstrumentedModule[i];} );
+
+	if(Width + SizeInfo.x + 50 > nWidth)
+	{
+		Width = nWidth - (SizeInfo.x+50);
+	}
+	SizeInfo.w = Width;
+	var MaxStringLength = Math.floor(Width/(FontWidth));
+
+	var Selection = null;
+	var X = SizeInfo.x;
+	context.fillStyle = nBackColors[0];
+	TextY = Y+BoxHeight-FontAscent;
+	context.fillRect(X, Y, Width, BoxHeight);
+
+	var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight && MouseX-X < 100;
+	context.fillRect(X, Y, 99, BoxHeight);
+	context.textAlign = 'center';
+	context.fillStyle = 'white';
+	context.fillText("Patched functions", X + Width/2, TextY);
+
+	Y += BoxHeight;
+	MoveFilterInputDiv(SizeInfo.x, Y, SizeInfo.w-6);
+	Y += 45;
+
+	bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
+	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+	var TextY = Y+BoxHeight-FontAscent;
+	var YClear = Y;
+	var TextYClear = TextY;
+	var bgcolorClear = bgcolor;
+	var YStart = Y-BoxHeight*2;
+
+	nColorIndex = 1-nColorIndex;
+
+	Y -= nOffsetMenuFunctions + 10;
+	var Selection = -1;
+
+	var StringColor = function(Name)
+	{
+		var h = StringHash(Name);
+		var cidx = h % 360;
+		return cidx;
+	};
+
+	var GetColor = function(Str)
+	{
+		var cidx = StringColor(Str);
+		return "hsl(" + cidx + ",50%, 70%)";
+	};
+	for(var i = 0; i < FunctionsInstrumented.length; ++i)
+	{
+		var Name = FunctionsInstrumented[i];
+		var ModuleName = FunctionsInstrumentedModule[i];
+		if(FilterMatch(FilterArray, ModuleName + " " + Name))
+		{
+
+			var Color = GetColor(Name);
+			var ColorModule = GetColor(Name);
+			if(Y >= YStart)
+			{
+				bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
+				bgcolor = bMouseIn && MouseX > X ? nBackColorOffset : nBackColors[nColorIndex];
+				TextY = Y+BoxHeight-FontAscent;
+
+				context.fillStyle = bgcolor;
+				context.fillRect(X, Y, Width, BoxHeight);
+				context.fillStyle = Color;
+				context.textAlign = 'right';
+				context.fillText(Name, X + Width - 2, TextY);
+				context.textAlign = 'left';
+				context.fillStyle = ColorModule;
+				context.fillText(ModuleName, X, TextY);
+			}
+			Y += BoxHeight;
+			nColorIndex = 1-nColorIndex;
+		}
+	}
+	context.textAlign = 'left';
+	SizeInfo.h = Y-SizeInfo.y;
+	return SizeInfo;
+}
+
+
+function DrawMenuModules()
+{
+	if(FilterInputValueLast != FilterInput.value)
+	{
+		nOffsetMenuModules = 0;
+	}
+	FilterInputValueLast = FilterInput.value;
+	var M = ModuleState;
+	var FilterArray = CreateFilter(FilterInput.value);
+	var context = CanvasDetailedView.getContext('2d');
+	var nColorIndex = 0;
+	var SizeInfo = TimerMenuSize(); //broken, fix!
+
+	SizeInfo.x = MenuItems[SubMenuModules].x;
+	SizeInfo.y = MenuItems[SubMenuModules].y;
+	var Y = SizeInfo.y;
+	var Width = SizeInfo.w;
+	Width = Math.max(300, Width);
+	Width = 10+ MeasureArray(Width, M, function(s){return s.n + " " + s.s;} );
+
+	if(Width + SizeInfo.x + 50 > nWidth)
+	{
+		Width = nWidth - (SizeInfo.x+50);
+	}
+	SizeInfo.w = Width;
+
+
+	var MaxStringLength = Math.floor(Width/(FontWidth));
+
+
+	var X = SizeInfo.x;
+	DrawSymbolHeaderMenu(context, X, Y, Width);
+
+	Y += BoxHeight;
+	MoveFilterInputDiv(SizeInfo.x, Y, SizeInfo.w-6);
+	Y += 45;
+
+	let bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
+	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+	var TextY = Y+BoxHeight-FontAscent;
+	var YClear = Y;
+	var TextYClear = TextY;
+	var bgcolorClear = bgcolor;
+	var YStart = Y-BoxHeight*2;
+
+	nColorIndex = 1-nColorIndex;
+
+	Y -= nOffsetMenuModules + 10;
+	var Selection = -1;
+
+	var StringColor = function(Name)
+	{
+		var h = StringHash(Name);
+		var cidx = h % 360;
+		return cidx;
+	};
+
+	for(var i = 0; i < M.length; ++i)
+	{
+		var Name = M[i].n;
+		var Count = M[i].s;
+		var Prc = M[i].p;
+		if(Prc<0||Prc>1)
+			Prc = 0;
+		let cidx = StringColor(Name);
+		let Color = "hsl(" + cidx + ",50%, 70%)";
+		let C1 = "hsl(" + cidx + ",30%, 40%)";
+		var N = Name;
+		if(N.length > MaxStringLength)
+		{
+			N = N.substring(N.length - MaxStringLength);
+		}
+		if(FilterMatch(FilterArray, Name))
+		{
+
+			if(Y >= YStart)
+			{
+				bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
+				bgcolor = bMouseIn && MouseX > X ? nBackColorOffset : nBackColors[nColorIndex];
+				TextY = Y+BoxHeight-FontAscent;
+
+				context.fillStyle = bgcolor;
+				context.fillRect(X, Y, Width, BoxHeight);
+				if(Prc>0 && Prc <= 1)
+				{
+					context.fillStyle = C1;
+					context.fillRect(X, Y, Prc*Width, BoxHeight);
+				}
+				context.fillStyle = 'white';
+				context.textAlign = 'right';
+				context.fillText(Count + '', X + Width - 2, TextY);
+				context.textAlign = 'left';
+				context.fillStyle = Color;
+				context.fillText(N, X, TextY);
+				if(bMouseIn)
+				{
+					Selection = i;
+				}
+			}
+			Y += BoxHeight;
+			nColorIndex = 1-nColorIndex;
+		}
+	}
+	context.textAlign = 'left';
+	if(Selection != -1 && MouseReleased)
+	{
+		WSSendMessage("L" + M[Selection].n);
+	}
+	SizeInfo.h = Y-SizeInfo.y;
+	return SizeInfo;
+}
+function DrawSymbolHeaderMenu(context, X, Y, Width)
+{
+	context.fillStyle = nBackColors[0];
+	let TextY = Y+BoxHeight-FontAscent;
+	context.fillRect(X+100, Y, Width-100, BoxHeight);
+	let bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight && MouseX-X < 100;
+	if(bMouseIn)
+	{
+		context.fillStyle = nBackColorOffset;
+	}
+
+	context.fillRect(X, Y, 99, BoxHeight);
+
+
+	let NumSymbols = 0;
+	let SymbolStateString = "Load all";
+	let SymbolButtonActive = 1;
+	let SymbolSpinnerActive = 0;
+	let FinishedSymbols = 0;
+	if(SymbolState)
+	{
+		FinishedSymbols = SymbolState.f;
+		var s = SymbolState.s;
+		NumSymbols = SymbolState.l;
+		SymbolButtonActive = 1;
+		if(SymbolState.q == 1 || FunctionQueryLastRequest != FunctionQueryReceived)
+		{
+			SymbolStateString = "Querying";
+			SymbolButtonActive = 0;
+			SymbolSpinnerActive = 1;
+		}
+		else if(SymbolState.f != SymbolState.r)
+		{
+			SymbolButtonActive = 0;
+			SymbolSpinnerActive = 1;
+			SymbolStateString = "Loading";
+		}
+		else if(SymbolState.f == ModuleState.length)
+		{
+			SymbolButtonActive = 0;
+			SymbolStateString = "Loaded";
+		}
+	}
+	let LoadButtonAnimation  = LoadSymbolAnimUpdateAndGet();
+
+	context.textAlign = 'right';
+	context.fillStyle = 'white';
+	context.fillText(NumSymbols + " Symbols " + FinishedSymbols + "/" + ModuleState.length + " Modules", X+Width-2, TextY);
+	context.textAlign = 'center';
+
+	if(LoadButtonAnimation>0)
+	{
+		var c = "hsl(0,0%," + (LoadButtonAnimation * 100)+"%)";
+		context.fillStyle = c;
+	}
+	if(SymbolButtonActive)
+	{
+		if(bMouseIn && MouseReleased)
+		{
+			WSSendMessage("S"); //load symbols
+		}
+		context.fillText(SymbolStateString, X + 50, TextY);
+	}
+	else
+	{
+		context.fillStyle = 'grey';
+		context.fillText(SymbolStateString, X + 50, TextY);
+	}
+	SpinnerDraw(SymbolSpinnerActive, context, SpinnerLoadButton, X+2, Y,  FontHeight, FontHeight );
+
+
+}
+
+function DrawMenuFunctions()
+{
+	if(FilterInputValueLast != FilterInput.value)
+	{
+		nOffsetMenuFunctions = 0;
+		var m = FilterInput.value.trim();
+		if(m != "")
+		{
+			if(SymbolState && SymbolState.r == SymbolState.f)
+			{
+				var Req = ++FunctionQueryLastRequest;
+				var Q = "q" + Req + "x" + m;
+				WSSendMessage(Q);
+				FunctionQueryPending = null;
+			}
+			else
+			{
+				FunctionQueryPending = m;
+				if(SymbolState) //wtf?
+				{
+					LoadSymbolAnimRestart();
+				}
+			}
+		}
+	}
+
+	FilterInputValueLast = FilterInput.value;
+	var FF = FunctionQueryArray;
+	var FilterArray = CreateFilter(FilterInput.value);
+	var context = CanvasDetailedView.getContext('2d');
+	var nColorIndex = 0;
+	var SizeInfo = TimerMenuSize(); //broken, fix
+	SizeInfo.x = MenuItems[SubMenuFunctions].x;
+	SizeInfo.y = MenuItems[SubMenuFunctions].y;
+	var Y = SizeInfo.y;
+	var Width = SizeInfo.w;
+	Width = Math.max(300, Width);
+	Width = 10+ MeasureArray(Width, FF, function(s){return s.n + " " + s.m;} );
+
+	if(Width + SizeInfo.x + 50 > nWidth)
+	{
+		Width = nWidth - (SizeInfo.x+50);
+	}
+	SizeInfo.w = Width;
+	var MaxStringLength = Math.floor(Width/(FontWidth));
+
+	var Selection = null;
+	var X = SizeInfo.x;
+
+	{
+		DrawSymbolHeaderMenu(context, X, Y, Width);
+	}
+
+
+	Y += BoxHeight;
+	MoveFilterInputDiv(SizeInfo.x, Y, SizeInfo.w-6);
+	Y += 45;
+
+	let bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
+	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+	var TextY = Y+BoxHeight-FontAscent;
+	var YClear = Y;
+	var TextYClear = TextY;
+	var bgcolorClear = bgcolor;
+	var YStart = Y-BoxHeight*2;
+
+	nColorIndex = 1-nColorIndex;
+
+	Y -= nOffsetMenuFunctions + 10;
+	var Selection = -1;
+
+	var StringColor = function(Name)
+	{
+		var h = StringHash(Name);
+		var cidx = h % 360;
+		return cidx;
+	};
+
+	for(var i = 0; i < FF.length; ++i)
+	{
+		if(true)
+		{
+			var Name = FF[i].n;
+			var ShortName = FF[i].sn;
+			var Color = FF[i].c;
+			var ColorModule = FF[i].cm;
+			var ModuleName = FF[i].m;
+			if(!Color || !ColorModule)
+			{
+				var cidx = StringColor(ShortName);
+				FF[i].c = "hsl(" + cidx + ",50%, 70%)";
+				FF[i].rgb = ConvertHslToRGB(cidx/ 360, 0.5, 0.7);
+				var cidxModule = StringColor(ModuleName);
+				FF[i].cm = "hsl(" + cidxModule + ",50%, 70%)";
+				FF[i].rgbm = ConvertHslToRGB(cidxModule/ 360, 0.5, 0.7);
+				Color = FF[i].c;
+				ColorModule = FF[i].cm;
+			}
+			var UseAlt = 0;
+			var N = UseAlt ? Name : ShortName;
+			if(N.length > MaxStringLength)
+			{
+				N = N.substring(N.length - MaxStringLength);
+			}
+			var E = false;
+			if(true)
+			{
+
+				if(Y >= YStart)
+				{
+					bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
+					bgcolor = bMouseIn && MouseX > X ? nBackColorOffset : nBackColors[nColorIndex];
+					TextY = Y+BoxHeight-FontAscent;
+
+					context.fillStyle = bgcolor;
+					context.fillRect(X, Y, Width, BoxHeight);
+					context.fillStyle = Color;
+					context.textAlign = 'right';
+					context.fillText(N, X + Width - 2, TextY);
+					context.textAlign = 'left';
+					context.fillStyle = ColorModule;
+					context.fillText(ModuleName, X, TextY);
+					if(bMouseIn)
+					{
+						context.fillStyle = Color;
+						var bgcolorin = bMouseIn && MouseX < X ? nBackColorOffset : nBackColors[nColorIndex];
+
+						Selection = i;
+						var W = context.measureText('>>').width;
+						W = Math.max(W, BoxHeight) + 2;
+						var Corner = X - W - 1;
+						if(Corner < SizeInfo.x)
+						{
+							SizeInfo.w += SizeInfo.x - Corner;
+							SizeInfo.x = Corner;
+						}
+						context.fillStyle = bgcolorin;
+						context.fillRect(Corner, Y, W, BoxHeight);
+						context.fillStyle = Color;
+						context.textAlign = 'center';
+						context.fillText(">>", Corner + Math.floor(W / 2), TextY);
+
+						context.textAlign = 'left';
+					}
+				}
+				Y += BoxHeight;
+				nColorIndex = 1-nColorIndex;
+			}
+		}
+	}
+
+	context.textAlign = 'left';
+	if(Selection != -1 && MouseReleased)
+	{
+		if(KeyShiftDown || MouseX < X)
+		{
+			WSSendMessage("I" + FF[Selection].a + ' ' + FF[Selection].rgb + ' ' + FF[Selection].m + '!' + FF[Selection].n);
+		}
+		else
+		{
+			WSSendMessage("i" + FF[Selection].a + ' ' + FF[Selection].rgb + ' ' + FF[Selection].m + '!' + FF[Selection].n);
+		}
+	}
+	SizeInfo.h = Y-SizeInfo.y;
+	return SizeInfo;
+}
+
+function DrawMenuGeneric(Elements, Active, OnClick, x, y, Elements2)
+{
+	var context = CanvasDetailedView.getContext('2d');
+	var nColorIndex = 0;
+	if(Elements2.length != Elements.length)
+	{
+		Elements2 = null;
+	}
+
+	var h = FontHeight * Elements.length;
+	var w = 20;
+	var w2 = 0;
+	for(var i = 0; i < Elements.length; ++i)
+	{
+		var m = context.measureText(Elements[i]).width;
+		w = w > m ? w : m;
+		if(Elements2)
+		{
+			m = context.measureText(Elements2[i]).width;
+			w2 = w2 > m ? w2 : m;
+		}
+	}
+	w += 10 + w2;
+	var SizeInfo = MenuSize(w);
+	SizeInfo.x = x;
+	SizeInfo.y = y;
+	var X = x;
+	var Y = y;
+
+
+	for(var i = 0; i < Elements.length; ++i)
+	{
+		var Selected = Active == i;
+		var Name = Elements[i];
+		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
+		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+		var TextY = Y+BoxHeight-FontAscent;
+		context.fillStyle = Selected?'white':bgcolor;
+		context.fillRect(X-2, Y, w+4, BoxHeight);
+		context.fillStyle = bgcolor;
+		context.fillRect(X, Y, w, BoxHeight);
+		context.fillStyle = 'white';
+		context.fillText(Name, X + 2, TextY);
+		if(Elements2)
+		{
+			context.textAlign = "right";
+			context.fillText(Elements2[i], X + w , TextY);
+			context.textAlign = "left";
+		}
+		context.fillText(Name, X + 2, TextY);
+		if(bMouseIn && MouseReleased)
+		{
+			OnClick(i, Name);
+		}
+		Y += BoxHeight;
+		nColorIndex = 1-nColorIndex;
+	}
+	SizeInfo.h = Y - SizeInfo.y;
+	return SizeInfo;
+}
+
+function DrawMenuGroup()
+{
+	if(FilterInputValueLast != FilterInput.value)
+	{
+		nOffsetMenuGroup = 0;
+	}
+	FilterInputValueLast = FilterInput.value;
+
+	var context = CanvasDetailedView.getContext('2d');
+	var nColorIndex = 0;
+	var Selection = null;
+	var SizeInfo = GroupMenuSize();
+	SizeInfo.x = MenuItems[SubMenuGroup].x;
+	SizeInfo.y = MenuItems[SubMenuGroup].y;
+	var Y = SizeInfo.y;
+	var X = SizeInfo.x;
+	var Width = SizeInfo.w;
+	var FilterArray = CreateFilter(FilterInput.value);
+	MoveFilterInputDiv(SizeInfo.x-2, SizeInfo.y, SizeInfo.w-1);
+	var YStart = Y+20;
+	Y += 35;
+	Y -= nOffsetMenuGroup;
+
+
+	function DrawMenuElement(Selected, Name, color, Indent)
+	{
+		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
+		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+		context.fillStyle = Selected?'white':bgcolor;
+		context.fillRect(X-2, Y, Width+4, BoxHeight);
+		context.fillStyle = bgcolor;
+		context.fillRect(X, Y, Width, BoxHeight);
+		context.fillStyle = color;
+		if(!Indent) Indent = 0;
+		context.fillText(Name, X + Indent*FontWidth, Y+BoxHeight-FontAscent);
+		nColorIndex = 1-nColorIndex;
+		Y += BoxHeight;
+		return bMouseIn;
+	}
+	function DrawMenuRecursive(Index, Indent, categorymatch)
+	{
+		ProfileEnter("DrawMenuRecursive");
+		var v = TimerArray[Index];
+		if(v.idtype == TYPE_TIMER || v.idtype == TYPE_COUNTER)
+		{
+			return;
+		}
+		if(v.idtype == TYPE_GROUP && !categorymatch)
+		{
+			if(!FilterMatch(FilterArray, v.name))
+			{
+				return;
+			}
+		}
+		var catmatch = 0;
+		if(v.idtype == TYPE_CATEGORY)
+		{
+			if(FilterMatch(FilterArray, v.name))
+			{
+				catmatch = 1;
+			}
+		}
+		var Closed = 0;
+		if(Index > 0)
+		{
+			if(Y > YStart)
+			{
+				if(DrawMenuElement(v.e, v.name, v.color, Indent))
+				{
+					Selection = v.id;
+				}
+			}
+			else
+			{
+				Y += BoxHeight;
+			}
+		}
+
+		if(!Closed)
+		{
+			var ChildIndex = v.firstchild;
+			while(ChildIndex != -1)
+			{
+				DrawMenuRecursive(ChildIndex, Indent + 1, catmatch);
+				ChildIndex = TimerArray[ChildIndex].sibling;
+			}
+		}
+		ProfileLeave();
+	}
+	DrawMenuRecursive(0, -1);
+	if(Selection && MouseReleased)
+	{
+		WSSendMessage("c" + Selection);
+	}
+	SizeInfo.h = Y - SizeInfo.y;
+	return SizeInfo;
+}
+
+function ShowMenu()
+{
+	if(!Settings.ViewCompressed)
+		return true;
+	else
+	{
+		var Time = new Date();
+		var Delta = Time - MouseMoveTime;
+		console.log('delta time is ' + Delta);
+		return Delta < 2000;
+	}
+}
+
+function DrawMenu()
+{
+	if(WSConnected && WS && WS.readyState == 1)
+	{
+		var context = CanvasDetailedView.getContext('2d');
+		var nColorIndex = 0;
+		var Y = 50;
+		var Width = 300;
+		var Selection = null;
+		if(!ShowMenu())
+		{
+			return;
+		}
+		ProfileEnter("DrawMenu");
+		DrawTopMenu();
+		var MenuRect = WindowRect(0,0,nWidth,nHeight);
+		if(SubMenuActive != -1)
+		{
+			MouseMoveTime = new Date();
+		}
+		if(SubMenuActive == SubMenuGroup)
+		{
+			MenuRect = DrawMenuGroup();
+		}
+		else if(SubMenuActive == SubMenuTimers)
+		{
+			MenuRect = DrawMenuTimer();
+		}
+		else if(SubMenuActive == SubMenuModules)
+		{
+			MenuRect = DrawMenuModules();
+		}
+		else if(SubMenuActive == SubMenuFunctions)
+		{
+			MenuRect = DrawMenuFunctions();
+		}
+		else if(SubMenuActive == SubMenuPatched)
+		{
+			MenuRect = DrawMenuPatched();
+		}
+		else if(SubMenuActive == SubMenuSettings)
+		{
+			MenuRect = DrawMenuSettings();
+		}
+		else if(SubMenuActive == SubMenuViews)
+		{
+			MenuRect = DrawMenuViews();
+		}
+		else if(SubMenuActive == SubMenuPresets)
+		{
+			MenuRect = DrawMenuPresets();
+		}
+		else if(SubMenuActive == SubMenuColumns)
+		{
+			MenuRect = DrawMenuColumns();
+		}
+		else if(SubMenuActive == SubMenuCapture)
+		{
+			MenuRect = DrawMenuCapture();
+		}
+		else if(SubMenuActive == SubMenuGraphSettings)
+		{
+			MenuRect = DrawMenuGraphSettings();
+		}
+		var Grow = 10;
+		MenuRect.x -= Grow;
+		MenuRect.y -= Grow;
+		MenuRect.h += 2*Grow;
+		MenuRect.w += 2*Grow;
+		var MouseMoved = MouseX != SubMenuMouseX || MouseY != SubMenuMouseY;
+
+		if(MouseInRect(MenuRect) || !MouseMoved)
+		{
+			SubMenuTimeout = new Date();
+			SubMenuMouseX = MouseX;
+			SubMenuMouseY = MouseY;
+		}
+		else
+		{
+			var Time = new Date() - SubMenuTimeout;
+			var Dest = SubMenuTimeoutBase * 1000;
+			if(Time > Dest)
+			{
+				EnableMenu(-1);
+			}
+		}
+		if(0)//debugging of menu extents. dont delete
+		{
+			context.strokeStyle = 'red';
+			context.beginPath();
+			context.moveTo(MenuRect.x,MenuRect.y);
+			context.lineTo(MenuRect.x + MenuRect.w,MenuRect.y);
+			context.lineTo(MenuRect.x + MenuRect.w,MenuRect.y+MenuRect.h);
+			context.lineTo(MenuRect.x,MenuRect.y+MenuRect.h);
+			context.lineTo(MenuRect.x,MenuRect.y);
+			context.stroke();
+		}
+		SpinnerDraw(SpinnerShow(), context, SpinnerCorner, 0, nHeight-20,  20, 20);
+		ProfileLeave();
+	}
+}
+
+function DrawConnectionStatus()
+{
+	if(WSConnected && WS && WS.readyState == 1)
+	{
+		if(!ProfileMode)
+			return;
+	}
+	var Strings = new Array();
+	Strings.push("Status");
+	if(WSConnected && WS && WS.readyState == 1)
+	{
+		Strings.push("[X]");
+	}
+	else
+	{
+		ConnectionIdx = (ConnectionIdx + 1 ) % ConnectionStr.length;
+		Strings.push("[" + ConnectionStr[ConnectionIdx]+"]");
+	}
+	Strings.push("Port");
+	Strings.push("" + WSPort);
+	Strings.push("Path");
+	Strings.push("" + WSPath);
+	Strings.push("Sends");
+	Strings.push("" + WSSend);
+	Strings.push("Receives");
+	Strings.push("" + WSReceive);
+	Strings.push("SendBytes");
+	Strings.push("" + WSSendBytes);
+	Strings.push("ReceiveBytes");
+	Strings.push("" + WSReceiveBytes);
+	Strings.push("Seconds");
+	Strings.push("" + WSSeconds);
+	DrawToolTip(Strings, CanvasDetailedView, 50000, 0);
+}
+function DrawActiveToolTip()
+{
+	if(SubMenuActive == -1)
+	{
+		if(ToolTipCallback && SubMenuActive == -1)
+		{
+			var Strings = ToolTipCallback(CanvasDetailedView, MouseX, MouseY);
+			if(Strings)
+			{
+				DrawToolTip(Strings, CanvasDetailedView, MouseX, MouseY);
+			}
+		}
+	}
+	ToolTipCallback = null;
+}
+function UpdateSettings()
+{
+	if(Settings.AutomaticReference)
+	{
+		if( Math.abs(ReferenceGraph - ReferenceGraphAutomatic) > 0.02 ||
+			Math.abs(ReferenceHistory - ReferenceHistoryAutomatic) > 0.02)
+		{
+			RequestDraw();
+		}
+		ReferenceGraph = 0.9 * ReferenceGraph + 0.1 * ReferenceGraphAutomatic;
+		ReferenceHistory = 0.9 * ReferenceHistory + 0.1 * ReferenceHistoryAutomatic;
+		ReferenceBar = 0.9 * ReferenceBar + 0.1 * ReferenceBarAutomatic;
+		var TimerMap = FrameData.TimerMap;
+		if(!TimerMap)
+			return;
+
+
+		for(var key in TimerMap)
+		{
+			var TimerState = TimerMap[key];
+			if(!TimerState.historymaxsoft)
+			{
+				TimerState.historymaxsoft = TimerState.historymax;
+			}
+			else
+			{
+				TimerState.historymaxsoft = 0.9 * TimerState.historymaxsoft + 0.1 * TimerState.historymax;
+			}
+		}
+
+	}
+	else
+	{
+		ReferenceGraph = Settings.ReferenceTime;
+		ReferenceHistory = Settings.ReferenceTime;
+		ReferenceBar = Settings.ReferenceTime;
+	}
+	if(Settings.AggregateFrames != AggregateFrames)
+	{
+		WSSendMessage("a" + Settings.AggregateFrames);
+		AggregateFrames = Settings.AggregateFrames;
+	}
+}
+
+var PendingDraw = 0;
+
+function Draw()
+{
+	CaptureUpdate();
+	PendingDraw = 0;
+	ProfileEnter("Total");
+
+	UpdateSettings();
+
+	if(WSConnected && WS && WS.readyState == 1)
+	{
+		DrawViews();
+		DrawMessage();
+		DrawMenu();
+	}
+	else
+	{
+		var context = CanvasDetailedView.getContext('2d');
+		context.clearRect(0, 0, nWidth, nHeight);
+		DrawMessage();
+	}
+
+	DrawConnectionStatus();
+	DrawPlotf(CanvasDetailedView);
+	DrawActiveToolTip();
+
+
+	ProfileLeave();
+	ProfileModeDraw(CanvasDetailedView);
+	ProfileModeClear();
+
+
+	PlotfClear();
+
+	MouseReleased = false;
+}
+function RequestDraw()
+{
+	if(!PendingDraw)
+	{
+		PendingDraw = 1;
+		requestAnimationFrame(Draw);
+	}
+}
+
+
+
+
+function WSOpen(event)
+{
+	SetMessage("Connected!", 1000);
+	WSSend = 0;
+	WSReceive = 0;
+	WSSendBytes = 0;
+	WSReceiveBytes = 0;
+	WSIsOpen = 1;
+
+	Empty = {"id":0, "w":0, "depth":0, "sibling":-1,"parent":-1,"firstchild":-1};
+	TimerArray = [];
+	TimerArray.push(Empty);
+	WidthArray = [];
+	CounterArray = [];
+	WidthArray[TYPE_NONE] = 0;
+	WidthArray[TYPE_TIMER] = 0;
+	WidthArray[TYPE_GROUP] = 0;
+	WidthArray[TYPE_CATEGORY] = 0;
+	WidthTree = FontWidth;
+	SymbolState = null;
+	FunctionQueryPending = 0;
+	FunctionQueryReceived = 0;
+	FunctionQueryLastRequest = 0;
+	FunctionsInstrumented = [];
+	FunctionsInstrumentedModule = [];
+	FunctionsInstrumentedUnmangled = [];
+
+	FilterInputTimersValue = "";
+	FilterInputGroupsValue = "";
+	FilterInputFunctionsValue = "";
+	FilterInput.value = "";
+	FunctionQueryArray = [];
+	ModuleState = [];
+
+	ResetFrameData();
+	window.document.title = "MP:" + WSHost;
+
+	if(PresetToLoad && PresetToLoad != "")
+	{
+		LoadPreset(PresetToLoad, PresetToLoadRO);
+	}
+}
+
+function SplitIdTop(v)
+{
+	return v >> 24; // todo: verify
+}
+
+function SplitIdBottom(v)
+{
+	return v & 0xffffff; // todo: verify
+}
+
+function GetTimer(id)
+{
+	for(var i = 0; i < TimerArray.length; ++i)
+	{
+		if(TimerArray[i].id == id)
+		{
+			return i;
+		}
+	}
+	return null;
+}
+function IsGroup(id)
+{
+	var idx = GetTimer(id);
+	return TimerArray[idx].idtype == TYPE_GROUP;
+}
+
+function UpdateActive()
+{
+	GroupsEnabled = 0;
+	TimersEnabled = 0;
+	for(var i = 0; i < TimerArray.length; ++i)
+	{
+		var T = TimerArray[i];
+		if(T.e)
+		{
+			switch(T.idtype)
+			{
+				case TYPE_GROUP:
+					GroupsEnabled++;
+				break;
+				case TYPE_TIMER:
+					TimersEnabled++;
+				break;
+			}
+		}
+	}
+}
+function UpdateEnabledTimer(idx)
+{
+	UpdateActive();
+	var type = TimerArray[idx].idtype;
+	var enabled = TimerArray[idx].e;
+	if(TimerArray[idx].idtype != TYPE_TIMER)
+	{
+		return;
+	}
+	var AutoCaptureSourceValue = null;
+	if(AutoCaptureSourceIndex >= 0 && AutoCaptureSourceIndex < EnabledArray.length)
+	{
+		AutoCaptureSourceValue = EnabledArray[AutoCaptureSourceIndex];
+	}
+
+	var i = EnabledArray.indexOf(idx);
+	if(enabled)
+	{
+		if(i == -1)
+		{
+			EnabledArray.unshift(idx);
+		}
+	}
+	else
+	{
+		if(i != -1)
+		{
+			EnabledArray.splice(i, 1);
+		}
+	}
+	var NewIndex = AutoCaptureSourceValue != null ? EnabledArray.indexOf(AutoCaptureSourceValue) : -1;
+	AutoCaptureSourceIndex = NewIndex;
+}
+
+
+function EnableTimer(T)
+{
+	var idx = GetTimer(T.id);
+	if(idx != null && idx>=0)
+	{
+		TimerArray[idx].e = T.e;
+		UpdateEnabledTimer(idx);
+	}
+	else
+	{
+		console.log('unknown enable message');
+	}
+}
+function MeasureWidth(str)
+{
+	var context = CanvasDetailedView.getContext('2d');
+	return context.measureText(str).width;
+}
+function AddTimer(T)
+{
+	if(!T.color || T.color == "")
+	{
+		T.color = ColorFromString(T.name, 40, 50);
+	}
+	console.log("Added timer", T.name);
+	var idx = TimerArray.length;
+	var existing = GetTimer(T.id);
+	if(existing)
+	{
+		idx = existing;
+	}
+	else
+	{
+		TimerArray[idx] = T;
+	}
+	TimerArray[idx].time = 0;
+	TimerArray[idx].excl = 0;
+	TimerArray[idx].average = 0;
+	TimerArray[idx].max = 0;
+	TimerArray[idx].min = 0;
+	TimerArray[idx].total = 0;
+	TimerArray[idx].exclaverage = 0;
+	TimerArray[idx].exclmax = 0;
+	TimerArray[idx].excltotal = 0;
+	TimerArray[idx].spike = 0;
+	TimerArray[idx].callaverage = 0;
+	TimerArray[idx].callexclaverage = 0;
+	TimerArray[idx].callcount = 0;
+	var w = MeasureWidth(T.name);
+	var idtype = SplitIdTop(T.id);
+	var idelement = SplitIdBottom(T.id);
+	TimerArray[idx].idtype = idtype;
+	TimerArray[idx].idelement = idelement;
+	TimerArray[idx].w = w;
+	TimerArray[idx].wtree = w;
+	if(!existing)
+	{
+		TimerArray[idx].sibling = -1;
+		TimerArray[idx].parent = -1;
+		TimerArray[idx].firstchild = -1;
+	}
+	if(w > WidthArray[idtype])
+	{
+		WidthArray[idtype] = w;
+	}
+	UpdateEnabledTimer(idx);
+	var wparent = 0;
+	var pidx = GetTimer(T.pid);
+	if(pidx >= 0 && !existing)
+	{
+		TimerArray[idx].parent = pidx;
+		var Parent = TimerArray[pidx];
+		var Sibling = Parent.firstchild;
+		wparent = MeasureWidth(Parent.name);
+		Parent.firstchild = idx;
+		if(Sibling != -1)
+		{
+			if(TimerArray[Sibling].sibling == idx)
+			{
+				debugger;
+			}
+		}
+		TimerArray[idx].sibling = Sibling;
+		TimerArray[idx].wtree += Parent.depth * FontWidth;
+		TimerArray[idx].depth = Parent.depth + 1;
+		if(TimerArray[idx].wtree > WidthTree)
+		{
+			WidthTree = TimerArray[idx].wtree;
+		}
+		TimerArray[idx].sortkey = Parent.name + " __ " + T.name;
+	}
+	else
+	{
+		TimerArray[idx].sortkey = T.name;
+	}
+	TimerArray[idx].wparent = wparent;
+	TimerArray[idx].wtotal = wparent + w;
+
+	if(idtype == TYPE_COUNTER)
+	{
+		if(idelement != CounterArray.length)
+		{
+			debugger;
+		}
+		CounterArray.push(idx);
+		TimerArray[idx].formattedlimit = FormatCounter(TimerArray[idx].format, TimerArray[idx].limit);
+		CounterLimitWidth = Math.max(CounterLimitWidth, TimerArray[idx].formattedlimit.length * (FontWidth+1));
+		CounterNameWidth = Math.max(CounterNameWidth, (TimerArray[idx].name.length + 1 + TimerArray[idx].depth) * (FontWidth+1));
+		TimerArray[idx].counterhistory = {};
+		TimerArray[idx].counterhistory.history = AllocClearedArray(120);
+		TimerArray[idx].counterhistory.prc = AllocClearedArray(120);
+	}
+	if(idtype == TYPE_TIMER)
+	{
+		if(T.color == "#000000")
+		{
+			T.color = ColorFromString(T.name + "x" + Parent.name, 40, 50);
+		}
+
+	}
+	RequestDraw();
+}
+
+function AllocClearedArray(Size)
+{
+	var A = new Array(Size);
+	for(var i = 0; i < Size; ++i)
+	{
+		A[i] = 0;
+	}
+	return A;
+}
+function PushIntoArray(A, v)
+{
+	A.shift();
+	A.push(v);
+}
+function ResetFrameData()
+{
+	FrameData = {};
+	FrameData.TimerMap = {};
+	FrameData.Time = AllocClearedArray(FRAME_COUNT);
+	FrameData.Ids = AllocClearedArray(FRAME_COUNT);
+	FrameData.Frozen = AllocClearedArray(FRAME_COUNT);
+	FrameData.ThreadTime = {};
+}
+function GetFrameData(id)
+{
+	if(FrameData.TimerMap[id])
+	{
+		return FrameData.TimerMap[id];
+	}
+	else
+	{
+		var FD = {};
+		FD.Count = AllocClearedArray(FRAME_COUNT);
+		FD.Time = AllocClearedArray(FRAME_COUNT);
+		FD.TimeExcl = AllocClearedArray(FRAME_COUNT);
+		FD.TimeMax = AllocClearedArray(AggregateHistorySize);
+		FD.TimeMin = AllocClearedArray(AggregateHistorySize);
+		FD.TimeAvg = AllocClearedArray(AggregateHistorySize);
+		FD.TimeExclMax = AllocClearedArray(AggregateHistorySize);
+		FD.TimeExclMin = AllocClearedArray(AggregateHistorySize);
+		FD.TimeExclAvg = AllocClearedArray(AggregateHistorySize);
+		FD.TimeCallAvg = AllocClearedArray(AggregateHistorySize);
+		FD.TimeCallExclAvg = AllocClearedArray(AggregateHistorySize);
+		FD.TimeTotal = AllocClearedArray(AggregateHistorySize);
+		FD.TimeExclTotal = AllocClearedArray(AggregateHistorySize);
+		FD.CallCount = AllocClearedArray(AggregateHistorySize);
+		FD.Percentile = new Float32Array(PERCENTILE_SAMPLES);
+		FD.Percentile.fill(0.0);
+		FD.PercentileMax = -1e38;
+		FD.PercentileMin = 1e38;
+		FD.PercentileCount = 0;
+		FD.EmptyFrames = 0;
+
+
+		FD.AggregateFrames = 0;
+		FD.FrameTime = 0.0;
+		FD.Aggregate = 0;
+		FD.AggregateTime = 0.0;
+		FD.AggregateSum = 0;
+		FD.AggregateMax = 0;
+		FD.AggregateMin = C_HUGE;
+		FD.AggregateExclSum = 0;
+		FD.AggregateExclMax = 0;
+		FD.AggregateCount = 0;
+		FD.AggregateExclMin = C_HUGE;
+
+
+
+		FrameData.TimerMap[id] = FD;
+		return FD;
+	}
+}
+
+function ProcessCounters(C)
+{
+	for(var i = 0; i < CounterArray.length; ++i)
+	{
+		if(i > C.length)
+		{
+			debugger;
+		}
+		var idx = CounterArray[i];
+		var value = C[i];
+		var T = TimerArray[idx];
+		T.value = value;
+		if(T.minvalue == undefined)
+			T.minvalue = value;
+		else
+			T.minvalue = Math.min(T.minvalue, value);
+		if(T.maxvalue == undefined)
+			T.maxvalue = value;
+		else
+			T.maxvalue = Math.max(T.maxvalue, value);
+		T.formatted = FormatCounter(T.format, value);
+		var boxprc = 1.0;
+		var counterprc = 0;
+		if(T.limit)
+		{
+			counterprc = value / T.limit;
+			if(counterprc > 1.0)
+			{
+				boxprc = 1.0 / counterprc;
+				counterprc = 1.0;
+			}
+			counterprc = Math.max(counterprc, 0.0);
+
+		}
+		T.boxprc = boxprc;
+		T.counterprc = counterprc;
+		PushIntoArray(T.counterhistory.history, value);
+		var prc = T.maxvalue > T.minvalue ? (value - T.minvalue) / (T.maxvalue - T.minvalue) : 0.0;
+		PushIntoArray(T.counterhistory.prc, prc);
+		CounterValueWidth = Math.max(CounterValueWidth, T.formatted.length * (FontWidth+1));
+	}
+
+}
+
+
+function ProcessFrame(F, Inactive)
+{
+	ProfileEnter("ProcessFrame");
+	if(F.s)
+	{
+		if(F.s.l == F.s.r)
+		{
+			if(FunctionQueryPending)
+			{
+				var Req = ++FunctionQueryLastRequest;
+				var Q = "q" + Req + "x" + FunctionQueryPending;
+				WSSendMessage(Q);
+				FunctionQueryPending = null;
+			}
+		}
+		SymbolState = F.s;
+		if(F.M)
+		{
+			ModuleState = F.M;
+		}
+		MenuItems[SubMenuFunctions].visible = function(){return true;};
+		MenuItems[SubMenuModules].visible = function(){return true;};
+	}
+	else
+	{
+		MenuItems[SubMenuFunctions].visible = function(){return false;};
+		MenuItems[SubMenuModules].visible = function(){return false;};
+	}
+	if(F.fr)
+	{
+		IsFrozen = 10;//allow it to stabilize after freezing
+		ProfileLeave();
+		return;
+	}
+	if(IsFrozen)
+	{
+		IsFrozen--;
+	}
+	if(!Inactive)
+	{
+		var TriggerAutoCapture = 0;
+		PushIntoArray(FrameData.Time, F.t);
+		PushIntoArray(FrameData.Ids, F.f);
+		PushIntoArray(FrameData.Frozen, IsFrozen ? 1 : 0);
+		var CaptureId = null;
+		var AutoCapture = AutoCaptureEnabled && !IsFrozen;
+		AggregateCurrent = F.a;
+		if(F.m != Settings.ViewActive)
+		{
+			WSSendMessage("v" + Settings.ViewActive);
+		}
+		if(AutoCapture > 0 && null == CaptureTriggerTime && AutoCaptureCooldown < 0)
+		{
+			if(AutoCaptureSourceIndex == -1 && F.t > Settings.AutoCaptureTheshold)
+			{
+				AutoCaptureEnabled -= 1;
+				TriggerAutoCapture = 1;
+			}
+			else if(AutoCaptureSourceIndex >= 0 && AutoCaptureSourceIndex < EnabledArray.length)
+			{
+				var id = TimerArray[EnabledArray[AutoCaptureSourceIndex]].id;
+				var Data = F.x[id];
+				if(Data && Data[0])
+				{
+				 	if(Data[0] > Settings.AutoCaptureTheshold)
+				 	{
+				 		TriggerAutoCapture = 1;
+				 		AutoCaptureEnabled -= 1;
+						console.log('trigger capture! ', Data[0], ' ', Settings.AutoCaptureTheshold);
+				 	}
+				}
+			}
+		}
+		AutoCaptureCooldown = AutoCaptureCooldown - 1;
+
+		var GraphTimeMax = 0;
+		var GraphTimeGroupMax = 0;
+		var HistoryTimeMax = 0;
+
+		for(var i = 0; i < FrameData.Time.length; ++i)
+		{
+			if(0 == FrameData.Frozen[i])
+			{
+				HistoryTimeMax = HistoryTimeMax > FrameData.Time[i] ? HistoryTimeMax : FrameData.Time[i];
+			}
+		}
+		var FindMaxTime = function(A, bIsGroup)
+		{
+			var MaxTime = 0;
+			for(var i = 0; i < A.length; ++i)
+			{
+				if(0 == FrameData.Frozen[i])
+				{
+					MaxTime = MaxTime > A[i] ? MaxTime : A[i];
+				}
+			}
+			if(bIsGroup)
+				GraphTimeGroupMax = MaxTime > GraphTimeGroupMax ? MaxTime : GraphTimeGroupMax;
+			else
+				GraphTimeMax = MaxTime > GraphTimeMax ? MaxTime : GraphTimeMax;
+			return MaxTime;
+		};
+		function SetAggregateTimersInArray(FD, id)
+		{
+			var idx = GetTimer(id);
+			var Pos = AggregateHistorySize-1;
+			var T = TimerArray[idx];
+
+			T.max = FD.TimeMax[Pos];
+			T.total = FD.TimeTotal[Pos];
+			T.excltotal = FD.TimeExclTotal[Pos];
+			T.min = FD.TimeMin[Pos];
+			T.spike = (T.average == 0 || T.max == 0) ? 0 : (100*T.max/T.average);
+			T.callaverage = FD.TimeCallAvg[Pos];
+			T.callcount = FD.CallCount[Pos];
+			T.callexclaverage = FD.TimeCallExclAvg[Pos];
+			T.exclaverage = FD.TimeExclAvg[Pos];
+			T.exclmax = FD.TimeExclMax[Pos];
+			T.exclmin = FD.TimeExclMin[Pos];
+			T.average = FD.TimeAvg[Pos];
+		};
+		function SetTimersInArray(FD, id)
+		{
+			var idx = GetTimer(id);
+			var Pos = FD.Time.length-1;
+			var T = TimerArray[idx];
+			T.time = FD.Time[Pos];
+			T.excl = FD.TimeExcl[Pos];
+			T.count = FD.Count[Pos];
+
+		};
+
+		let UpdateFrameDataInternal = function(id, Time, TimeExcl, Count, bIsGroup)
+		{
+
+			let FD = GetFrameData(id);
+			if(!IsFrozen)
+			{
+				ProfileEnter("PercentileAccum");
+				FD.PercentileMax = Math.max(FD.PercentileMax, Time);
+				FD.PercentileMin = Math.min(FD.PercentileMin, Time);
+				FD.PercentileCount += 1;
+				if(Time > FD.Percentile[0])
+				{
+					FD.Percentile[0] = Time;
+					FD.Percentile.sort( function(a,b){return a - b;} );
+				}
+				ProfileLeave();
+			}
+			PushIntoArray(FD.Time, Time);
+			PushIntoArray(FD.TimeExcl, TimeExcl);
+			PushIntoArray(FD.Count, Count);
+			FD.historymax = FindMaxTime(FD.Time, bIsGroup);
+
+			if((FD.Aggregate > Settings.AggregateFrames && Settings.AggregateFrames > 0) || AggregateCurrent == 0)
+			{
+				SetAggregateTimersInArray(FD, id);
+				FD.Aggregate = 0;
+				FD.AggregateSum = 0;
+				FD.AggregateMax = 0;
+				FD.AggregateMin = C_HUGE;
+				FD.AggregateExclSum = 0;
+				FD.AggregateExclMax = 0;
+				FD.AggregateExclMin = C_HUGE;
+				FD.AggregateCount = 0;
+
+				FD.TimeMax.shift();
+				FD.TimeMax.push(0);
+
+				FD.TimeMin.shift();
+				FD.TimeMin.push(0);
+
+				FD.TimeAvg.shift();
+				FD.TimeAvg.push(0);
+
+				FD.TimeCallAvg.shift();
+				FD.TimeCallAvg.push(0);
+
+				FD.TimeCallExclAvg.shift();
+				FD.TimeCallExclAvg.push(0);
+
+				FD.CallCount.shift();
+				FD.CallCount.push(0);
+
+				FD.TimeTotal.shift();
+				FD.TimeTotal.push(0);
+
+				FD.TimeExclTotal.shift();
+				FD.TimeExclTotal.push(0);
+
+				FD.TimeExclMax.shift();
+				FD.TimeExclMax.push(0);
+
+				FD.TimeExclMin.shift();
+				FD.TimeExclMin.push(0);
+
+				FD.TimeExclAvg.shift();
+				FD.TimeExclAvg.push(0);
+			}
+
+			FD.Aggregate += 1;
+			FD.AggregateSum += Time;
+			FD.AggregateMax = FD.AggregateMax > Time ? FD.AggregateMax : Time;
+			FD.AggregateMin = FD.AggregateMin < Time ? FD.AggregateMin : Time;
+			FD.AggregateExclSum += TimeExcl;
+			FD.AggregateExclMax = FD.AggregateExclMax > TimeExcl ? FD.AggregateExclMax : TimeExcl;
+			FD.AggregateExclMin = FD.AggregateExclMin < TimeExcl ? FD.AggregateExclMin : TimeExcl;
+			FD.AggregateCount += Count;
+			var UpdatePos = AggregateHistorySize-1;
+			if(UpdatePos != FD.TimeMax.length - 1)
+			{
+				debugger;
+			}
+
+			FD.TimeMax[UpdatePos] = FD.AggregateMax;
+			FD.TimeMin[UpdatePos] = FD.AggregateMin;
+			FD.TimeAvg[UpdatePos] = FD.AggregateSum / FD.Aggregate;
+			FD.TimeCallAvg[UpdatePos] = FD.AggregateCount ? FD.AggregateSum / FD.AggregateCount : 0;
+			FD.TimeCallExclAvg[UpdatePos] = FD.AggregateCount ? FD.AggregateExclSum / FD.AggregateCount : 0;
+			FD.TimeTotal[UpdatePos] = FD.AggregateSum;
+			FD.TimeExclTotal[UpdatePos] = FD.AggregateExclSum;
+			FD.CallCount[UpdatePos] = FD.AggregateCount;
+			FD.TimeExclAvg[UpdatePos] = FD.Aggregate ? FD.AggregateExclSum / FD.Aggregate : 0;
+			FD.TimeExclMax[UpdatePos] = FD.AggregateExclMax;
+			FD.TimeExclMin[UpdatePos] = FD.AggregateExclMin;
+
+			if(Settings.AggregateFrames <= 0)
+			{
+				SetAggregateTimersInArray(FD, id);
+			}
+			SetTimersInArray(FD, id);
+		};
+
+		for(var id in F.x)
+		{
+			var Data = F.x[id];
+			var Time = Data[0];
+			var TimeExcl = Data[1];
+			var Count = Data[2];
+			UpdateFrameDataInternal(id, Data[0], Data[1], Data[2]);
+		}
+
+		var groups = {};
+		for(var i = 0; i < F.g.length; ++i)
+		{
+			var id = F.gi[i];
+			groups[id] = 1;
+			var t = F.g[i];
+			UpdateFrameDataInternal(id, t[0], t[1], t[2], 1);
+		}
+
+		let UpdateThreadInfo = function(o)
+		{
+			let sn = SanitizeString(o.n);
+			let TI = ThreadInfo[sn];
+			if(!TI)
+			{
+				TI = { ids:o.gi, a:[], n:o.n, sn:sn };
+				for(let i = 0; i < TI.ids.length; ++i)
+				{
+					TI.a.push(AllocClearedArray(FRAME_COUNT));
+				}
+				ThreadInfo[sn] = TI;
+			}
+			for(let i = 0; i < o.gi.length; ++i)
+			{
+				let id = o.gi[i];
+				let t = o.g[i][1];
+				let te = FrameData.Time[FrameData.Time.length-1];
+				if(t > te)
+				{
+					console.log("fail!");
+					// debugger;
+				}
+				let idx = TI.ids.indexOf(id);
+				if(-1 == idx)
+				{
+					TI.ids.push(id);
+					let a = AllocClearedArray(FRAME_COUNT);
+					a[a.length-1] = o.g[i][1];
+					TI.a.push(a);
+				}
+				else
+				{
+					let l = TI.a[idx].length;
+					TI.a[idx][l-1] = o.g[i][1];
+				}
+			}
+		};
+		if(F.gt && F.gt.length)
+		{
+			for(let key in ThreadInfo)
+			{
+				let TI = ThreadInfo[key];
+				for(let i = 0; i < TI.a.length; ++i)
+				{
+					PushIntoArray(TI.a[i], 0);
+				}
+			}
+
+
+			for(let i = 0; i < F.gt.length; ++i)
+			{
+				let o = F.gt[i];
+				UpdateThreadInfo(o);
+			}
+		}
+
+
+
+		var ToDelete = new Array();
+		for(var id in FrameData.TimerMap)
+		{
+			let FD = FrameData.TimerMap[id];
+			if(!F.x[id] && !groups[id])
+			{
+				PushIntoArray(FD.Time,0.0);
+				PushIntoArray(FD.TimeExcl, 0.0);
+				PushIntoArray(FD.Count, 0);
+				FindMaxTime(FD.Time);
+				FD.EmptyFrames++;
+			}
+			else
+			{
+				FD.EmptyFrames = 0;
+			}
+			FD.FrameTime = FD.Time[FD.Time.length-1]; //Fix her..?
+			FD.AggregateTime = FD.Time[FD.Time.length-1];
+
+			if(FD.EmptyFrames == FD.Time.length)
+			{
+				ToDelete.push(id);
+			}
+		}
+		for(var i = 0; i < ToDelete.length; ++i)
+		{
+			delete FrameData.TimerMap[ToDelete[i]];
+		}
+		FramePending++;
+
+
+		if(TriggerAutoCapture)
+		{
+			Capture();
+		}
+		ReferenceGraphAutomaticGroup = 1.05 * GraphTimeGroupMax;
+		ReferenceGraphAutomatic = 1.05 * GraphTimeMax;
+		ReferenceHistoryAutomatic = 1.05 * HistoryTimeMax;
+	}
+	RequestDraw();
+	ProfileLeave();
+}
+
+function WSMessage(event)
+{
+	// console.log(event.data);
+	var Obj = JSON.parse(event.data);
+	WSReceive++;
+	WSReceiveBytes += event.data.length;
+	var k = Obj.k;
+	if(k == MSG_TIMER_TREE)
+	{
+		AddTimer(Obj.v);
+	}
+	else if(k == MSG_ENABLED)
+	{
+		EnableTimer(Obj.v);
+	}
+	else if(k == MSG_FRAME)
+	{
+		ProcessFrame(Obj.v);
+	}
+	else if(k == MSG_LOADSETTINGS)
+	{
+		OnLoadPreset(Obj.v, 1, Obj.ro);
+	}
+	else if(k == MSG_CURRENTSETTINGS)
+	{
+		OnLoadPreset(Obj.v, 0, Obj.ro);
+	}
+	else if(k == MSG_PRESETS)
+	{
+		AddPresets(Obj.v);
+	}
+	else if(k == MSG_COUNTERS)
+	{
+		ProcessCounters(Obj.v);
+	}
+	else if(k == MSG_FUNCTION_RESULTS)
+	{
+		FunctionQueryPending = null;
+		if(FunctionQueryReceived< Obj.q)
+		{
+			FunctionQueryArray = Obj.v;
+			FunctionQueryReceived = Obj.q;
+			console.log('got result from query ' + Obj.q);
+		}
+		else
+		{
+			console.log('ignored result from query ' + Obj.q);
+		}
+
+
+	}
+	else if(k == MSG_INACTIVE_FRAME)
+	{
+		ProcessFrame(Obj.v, 1);
+	}
+	else if(k == MSG_FUNCTION_NAMES)
+	{
+		for(var i = 0; i < Obj.v.length; ++i)
+		{
+			FunctionsInstrumented.push(Obj.v[i][0]);
+			FunctionsInstrumentedModule.push(Obj.v[i][1]);
+			FunctionsInstrumentedUnmangled.push(Obj.v[i][2]);
+
+		}
+	}
+	else if(k == MSG_INSTRUMENT_ERROR)
+	{
+		var D = Obj.v.data;
+		var F = Obj.v.functions;
+		var ASM_SERVER = "http://microprofileasm.zapto.org";
+		var url = ASM_SERVER + "/add/" + Obj.v.version + "/";
+		console.log(JSON.stringify(D));
+		console.log(JSON.stringify(F));
+		for(var i = 0; i < D.length; ++i)
+		{
+			url = url + D[i].code + "/";
+		}
+		var s = "Failed to instrument the following functions:\n";
+
+		for(var i = 0; i < F.length; ++i)
+		{
+			s = s + F[i] + "\n";
+		}
+		s = s + "\n\nPlease click \"OK\"to report the failed code segments\n"
+		s = s + "this will open the following url in a hidden frame\n"
+		s = s + url;
+		s = s + "\n-No additional data will be sent\n-No symbol names will be sent";
+		s = s + "\n[this popup can be auto-denied or auto-accepted from the settings menu]";
+		if(Cookie.CodeReportMode != 2)
+		{
+			if(Cookie.CodeReportMode == 1 || confirm(s))
+			{
+				var iframe = document.createElement("iframe");
+				iframe.onload = function(){document.body.removeChild(iframe); console.log("removed iframe");};
+				console.log("opening url " + url);
+				iframe.setAttribute("src", url);
+				iframe.style.width = "100x";
+				iframe.style.height = "100px";
+				document.body.appendChild(iframe);
+			}
+		}
+		console.log("got error "+ JSON.stringify(Obj.v));
+	}
+	// else if(k == MSG_MODULE_NAME)
+	// {
+	// 	console.log("MODULENAME..\n");
+	// 	console.log(JSON.stringify(Obj.v));
+	// 	ModuleState = Obj.v;
+
+	// }
+	else
+	{
+		console.log('hest!');
+	}
+
+}
+function WSError(event)
+{
+	console.log('WSError');
+}
+function WSClose(event)
+{
+	console.log('WSClose');
+	WSIsOpen = 0;
+	window.document.title = "MicroProfile Live";
+	FilterInputDiv.style['display'] = 'none';
+}
+function WSSendMessage(msgid)
+{
+	if(WSIsOpen)
+	{
+		var str = '' + msgid;
+		WSSend++;
+		WSSendBytes += str.length;
+		WS.send(str);
+	}
+	else
+	{
+		if(msgid[0] == 'c')
+		{
+			console.log('failing to send ' + msgid);
+		}
+	}
+}
+
+
+function Connect()
+{
+	if(WS && (WS.readyState == 1 || WS.readyState == 0))
+	{
+		WSConnected = WS.readyState == 1;
+		WSFail = 0;
+		WSSeconds = 0;
+	}
+	else
+	{
+		WSConnected = 0;
+		WSSeconds = (new Date() - WSOpenTime);
+		if(!WS || WSSeconds > 2000)
+		{
+			if(WS)
+			{
+				WS.close();
+				WS = null;
+			}
+			WSOpenTime = new Date();
+			WSPath = "ws://" + WSHost + ":" + WSPort + "/ws";
+			SetMessage('Connecting to ' + WSPath,5 * 1000, 1);
+			WS = new WebSocket(WSPath);
+			WS.onopen = WSOpen;
+			WS.onmessage = WSMessage;
+			WS.onerror = WSError;
+			WS.onclose = WSClose;
+			WSFail = 0;
+		}
+		else
+		{
+			WSFail++;
+		}
+	}
+	RequestDraw();
+}
+
+
+function MouseDragPan()
+{
+	return MouseDragButton == 1 || MouseDragKeyShift;
+}
+function MouseDragSelectRange()
+{
+	return MouseDragState == MouseDragMove && (MouseDragButton == 3 || (MouseDragKeyShift&&MouseDragKeyCtrl));
+}
+
+function MouseHandleDrag()
+{
+	if(MouseDragTarget == CanvasDetailedView)
+	{
+		if(SubMenuActive == -1)
+		{
+			if(MouseDragSelectRange() && SubMenuActive == -1)
+			{
+				var xStart = MouseDragXStart;
+				var xEnd = MouseDragX;
+				if(xStart > xEnd)
+				{
+					var Temp = xStart;
+					xStart = xEnd;
+					xEnd = Temp;
+				}
+				if(xEnd - xStart > 1)
+				{
+					MouseDragActiveXStart = xStart;
+					MouseDragActiveXEnd = xEnd;
+				}
+			}
+			else if(MouseDragPan())
+			{
+				var X = MouseDragX - MouseDragXLast;
+				var Y = MouseDragY - MouseDragYLast;
+				if(X && MouseDragActiveXStart < MouseDragActiveXEnd)
+				{
+					MouseDragActiveXStart += X;
+					MouseDragActiveXEnd += X;
+				}
+			}
+			if(Settings.ViewActive == VIEW_BAR)
+			{
+				if(MouseDragKeyShift || MouseDragButton == 1)
+				{
+					var X = MouseDragX - MouseDragXLast;
+					var Y = MouseDragY - MouseDragYLast;
+					nOffsetBarsY -= Y;
+					nOffsetBarsX -= X;
+					if(nOffsetBarsY < 0)
+					{
+						nOffsetBarsY = 0;
+					}
+					if(nOffsetBarsX < 0)
+					{
+						nOffsetBarsX = 0;
+					}
+				}
+			}
+			if(Settings.ViewActive == VIEW_COUNTERS)
+			{
+				if(MouseDragKeyShift || MouseDragButton == 1)
+				{
+					var Y = MouseDragY - MouseDragYLast;
+					nOffsetCountersY -= Y;
+					if(nOffsetCountersY < 0)
+					{
+						nOffsetCountersY = 0;
+					}
+				}
+			}
+		}
+		else if(SubMenuActive == SubMenuTimers || SubMenuActive == SubMenuGroup || SubMenuActive == SubMenuFunctions)
+		{
+			if(MouseDragKeyShift || MouseDragButton == 1)
+			{
+				var Y = MouseDragY - MouseDragYLast;
+				if(SubMenuActive == SubMenuTimers)
+				{
+					nOffsetMenuTimers -= Y;
+					if(nOffsetMenuTimers < 0)
+					{
+						nOffsetMenuTimers = 0;
+					}
+				}
+				else if(SubMenuActive == SubMenuFunctions)
+				{
+					nOffsetMenuFunctions -= Y;
+					if(nOffsetMenuFunctions < 0)
+					{
+						nOffsetMenuFunctions = 0;
+					}
+				}
+				else
+				{
+					nOffsetMenuGroup -= Y;
+					if(nOffsetMenuGroup < 0)
+					{
+						nOffsetMenuGroup = 0;
+					}
+				}
+			}
+		}
+	}
+	MouseDragXLast = MouseDragX;
+	MouseDragYLast = MouseDragY;
+}
+function MouseHandleDragEnd()
+{
+	if(MouseDragTarget == CanvasDetailedView)
+	{
+
+	}
+}
+
+function MouseHandleDragClick()
+{
+	if(SubMenuActive == -1)
+	{
+		if(nHoverCounter != -1)
+		{
+			if(TimerArray[nHoverCounter].firstchild != -1)
+			{
+				TimerArray[nHoverCounter].closed = !TimerArray[nHoverCounter].closed;
+			}
+			else
+			{
+				TimerArray[nHoverCounter].Expanded = !TimerArray[nHoverCounter].Expanded;
+			}
+			Draw(1);
+		}
+	}
+	if(MouseInCaptureButton)
+	{
+		TriggerCapture();
+	}
+}
+
+function MapMouseButton(event)
+{
+	if(event.button == 1 || event.which == 1)
+	{
+		return 1;
+	}
+	else if(event.button == 3 || event.which == 3)
+	{
+		return 3;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+function MouseDragReset()
+{
+	MouseDragState = MouseDragOff;
+	MouseDragTarget = 0;
+	MouseDragKeyShift = 0;
+	MouseDragKeyCtrl = 0;
+	MouseDragButton = 0;
+}
+function MouseDragKeyUp()
+{
+	if((MouseDragKeyShift && !KeyShiftDown) || (MouseDragKeyCtrl && !KeyCtrlDown))
+	{
+		MouseHandleDragEnd();
+		MouseDragReset();
+	}
+}
+function MouseDrag(Source, Event)
+{
+	if(Source == MouseDragOff || (MouseDragTarget && MouseDragTarget != Event.target))
+	{
+		MouseDragReset();
+		return;
+	}
+
+	var LocalRect = Event.target.getBoundingClientRect();
+	MouseDragX = Event.clientX - LocalRect.left;
+	MouseDragY = Event.clientY - LocalRect.top;
+	if(MouseDragState == MouseDragMove)
+	{
+		var dx = Math.abs(MouseDragX - MouseDragXStart);
+		var dy = Math.abs(MouseDragY - MouseDragYStart);
+		if((Source == MouseDragUp && MapMouseButton(Event) == MouseDragButton) ||
+			(MouseDragKeyCtrl && !KeyCtrlDown) ||
+			(MouseDragKeyShift && !KeyShiftDown))
+		{
+			MouseHandleDragEnd();
+			MouseDragReset();
+			return;
+		}
+		else
+		{
+			MouseHandleDrag();
+		}
+	}
+	else if(MouseDragState == MouseDragOff)
+	{
+		if(Source == MouseDragDown || KeyShiftDown || KeyCtrlDown)
+		{
+			MouseDragTarget = Event.target;
+			MouseDragButton = MapMouseButton(Event);
+			MouseDragState = MouseDragDown;
+			MouseDragXStart = MouseDragX;
+			MouseDragYStart = MouseDragY;
+			MouseDragKeyCtrl = 0;
+			MouseDragKeyShift = 0;
+
+			if(KeyShiftDown || KeyCtrlDown)
+			{
+				MouseDragKeyShift = KeyShiftDown;
+				MouseDragKeyCtrl = KeyCtrlDown;
+				MouseDragState = MouseDragMove;
+			}
+		}
+	}
+	else if(MouseDragState == MouseDragDown)
+	{
+		if(Source == MouseDragUp)
+		{
+			MouseHandleDragClick();
+			MouseDragReset();
+		}
+		else if(Source == MouseDragMove)
+		{
+			var dx = Math.abs(MouseDragX - MouseDragXStart);
+			var dy = Math.abs(MouseDragY - MouseDragYStart);
+			if(dx+dy>1)
+			{
+				MouseDragState = MouseDragMove;
+			}
+		}
+	}
+	MouseDragXLast = MouseDragX;
+	MouseDragYLast = MouseDragY;
+}
+
+
+function MouseMove(evt)
+{
+    evt.preventDefault();
+	var rect = evt.target.getBoundingClientRect();
+	var x = evt.clientX - rect.left;
+	var y = evt.clientY - rect.top;
+	MouseX = x;
+	MouseY = y;
+	MouseMoveTime = new Date();
+    MouseDrag(MouseDragMove, evt);
+    RequestDraw();
+}
+
+
+function MouseSortClick()
+{
+	if(SubMenuActive == -1)
+	{
+		if(SortColumnMouseOverNext)
+		{
+			if(SortColumnMouseOverNext == Settings.SortColumnName)
+			{
+				Settings.SortColumnOrderFlip =  1 - Settings.SortColumnOrderFlip;
+			}
+			else
+			{
+				Settings.SortColumnOrderFlip = 0;
+			}
+
+			Settings.SortColumnName = SortColumnMouseOverNext;
+			SortColumnMouseOverNext = null;
+		}
+	}
+}
+
+
+function MouseButton(bPressed, evt)
+{
+    evt.preventDefault();
+	MouseReleased = !bPressed;
+	MouseDrag(bPressed ? MouseDragDown : MouseDragUp, evt);
+	if(!bPressed)
+		MouseSortClick();
+    RequestDraw();
+}
+
+function MouseOut(evt)
+{
+	MouseDrag(MouseDragOff, evt);
+	KeyCtrlDown = 0;
+	KeyShiftDown = 0;
+	// MouseDragButton = 0;
+	// nHoverToken = -1;
+	// RangeCpu = RangeInit();
+}
+
+function MouseWheel(e)
+{
+//     var e = window.event || e;
+//     var delta = (e.wheelDelta || e.detail * (-120));
+//     ZoomGraph((-4 * delta / 120.0) | 0);
+//     Draw(1);
+}
+
+function KeyUp(evt)
+{
+	var k = evt.keyCode;
+	var InputActive = SubMenuActive == SubMenuTimers || SubMenuActive == SubMenuGroup || SubMenuActive == SubMenuFunctions || SubMenuActive == SubMenuPatched || SubMenuActive == SubMenuModules;
+	if(!InputActive)
+	{
+		if(k == 220)
+		{
+			ProfileMode = !ProfileMode;
+		}
+		if(k == 191)
+		{
+			WSPort++;
+			if(WSPort > 1338+2)
+			{
+				WSPort = 1338;
+			}
+			if(WS)
+			{
+				WS.close();
+				WS = null;
+			}
+		}
+		if(k == 32)
+		{
+			if(0) //for debugging.
+			{
+				console.log("FrameData =");
+				console.log(JSON.stringify(FrameData));
+				console.log("TimerArray =");
+				console.log(JSON.stringify(TimerArray));
+			}
+			WSSendMessage("f");
+		}
+		if(k == 88)
+		{
+			ToggleView();
+		}
+		if(k == 13)
+		{
+			TriggerCapture();
+		}
+		if(k == 72)
+		{
+			ShowHelp(0, 1);
+		}
+
+
+	}
+	if(k == 27)
+	{
+		if(FilterInput.value.trim() != "")
+		{
+			FilterInput.value = "";
+		}
+		else
+		{
+			EnableMenu(-1);
+		}
+
+		MouseDragActiveXStart = MouseDragActiveXEnd = -1;
+		Settings.SortColumnName = "";
+		ShowHelp(0);
+	}
+	if(k == 192)
+	{
+		Settings.ViewCompressed = Settings.ViewCompressed ? 0 : 1;
+		ResizeCanvas();
+	}
+
+	if(evt.keyCode == 17)
+	{
+		KeyCtrlDown = 0;
+		MouseDragKeyUp();
+	}
+	if(evt.keyCode == 16)
+	{
+		KeyShiftDown = 0;
+		MouseDragKeyUp();
+	}
+}
+
+function KeyDown(evt)
+{
+	// console.log("keydow ", k);
+	if(evt.keyCode == 17)
+	{
+		KeyCtrlDown = 1;
+		MouseDragKeyUp();
+	}
+	if(evt.keyCode == 16)
+	{
+		KeyShiftDown = 1;
+		MouseDragKeyUp();
+	}
+}
+
+
+function SetupEvents()
+{
+	var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel"; //FF doesn't recognize mousewheel as of
+	CanvasDetailedView.addEventListener('mousemove', MouseMove, false);
+	CanvasDetailedView.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
+	CanvasDetailedView.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
+	CanvasDetailedView.addEventListener('mouseout', MouseOut);
+	CanvasDetailedView.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
+	CanvasDetailedView.addEventListener(mousewheelevt, MouseWheel, false);
+	window.addEventListener('keydown', KeyDown);
+	window.addEventListener('keyup', KeyUp);
+	window.addEventListener('resize', ResizeCanvas, false);
+}
+
+function DrawToolTip(StringArray, Canvas, x, y)
+{
+	if(!ShowMenu())
+	{
+		return;
+	}
+	let colors;
+	let a = StringArray;
+	if(StringArray.c)
+	{
+		a = StringArray.a;
+		colors = StringArray.c;
+	}
+	var context = Canvas.getContext('2d');
+	context.font = Font;
+	var WidthArray = Array(a.length);
+	var nMaxWidth = 0;
+	var nHeight = 0;
+	for(var i = 0; i < a.length; i += 2)
+	{
+		var nWidth0 = context.measureText(a[i]).width;
+		var nWidth1 = context.measureText(a[i+1]).width;
+		var nSum = nWidth0 + nWidth1;
+		WidthArray[i] = nWidth0;
+		WidthArray[i+1] = nWidth1;
+		if(nSum > nMaxWidth)
+		{
+			nMaxWidth = nSum;
+		}
+		nHeight += BoxHeight;
+	}
+	nMaxWidth += 15;
+	//bounds check.
+	x = Math.max(0, x - 10 - nMaxWidth);
+	var CanvasRect = Canvas.getBoundingClientRect();
+	if(y + nHeight > CanvasRect.height)
+	{
+		y = CanvasRect.height - nHeight;
+		x += 20;
+	}
+	if(x + nMaxWidth > CanvasRect.width)
+	{
+		x = CanvasRect.width - nMaxWidth;
+	}
+
+	context.fillStyle = 'black';
+	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
+	context.fillStyle = 'white';
+
+	var XPos = x;
+	var XPosRight = x + nMaxWidth;
+	var YPos = y + BoxHeight-2;
+	context.fillStyle = 'white';
+	for(i = 0; i < a.length; i += 2)
+	{
+		if(colors)
+			context.fillStyle = colors[i];
+		context.fillText(a[i], XPos, YPos);
+		if(colors)
+			context.fillStyle = colors[i+1];
+		context.fillText(a[i+1], XPosRight - WidthArray[i+1], YPos);
+		YPos += BoxHeight;
+	}
+	context.fillStyle = 'white';
+}
+
+function DrawPlotf(Canvas)
+{
+	return;
+	var context = Canvas.getContext('2d');
+	context.font = Font;
+	var WidthArray = Array(PlotfArray.length);
+	var nMaxWidth = 0;
+	var nHeight = 0;
+
+	context.font = Font;
+	for(i = 0; i < PlotfArray.length; i++)
+	{
+		var nWidth = context.measureText(PlotfArray[i]).width;
+		WidthArray[i] = nWidth;
+		if(nWidth > nMaxWidth)
+		{
+			nMaxWidth = nWidth;
+		}
+		nHeight += BoxHeight;
+	}
+	nMaxWidth += 15;
+	var x = 0;
+	var y = 0;
+
+	context.fillStyle = 'black';
+	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
+	context.fillStyle = 'white';
+
+	var XPos = x;
+	var XPosRight = x + nMaxWidth;
+	var YPos = y + BoxHeight-2;
+	for(i = 0; i < PlotfArray.length; i++)
+	{
+		context.fillText(PlotfArray[i], XPos, YPos);
+		YPos += BoxHeight;
+	}
+}
+
+
+function ShiftRight10(v)
+{
+	if(v > 1024)
+	{
+		return v / 1024.0;
+	}
+	else
+	{
+		return v >> 10;
+	}
+}
+
+function FormatCounter(Format, Counter)
+{
+	if(!Counter)
+	{
+		return '0';
+	}
+	var Negative = 0;
+	if(Counter < 0)
+	{
+		Counter = -Counter;
+		Negative = 1;
+		if(Counter < 0) // handle INT_MIN
+		{
+			Counter = -(Counter+1);
+			if(Counter < 0)
+			{
+				return '?';
+			}
+		}
+	}
+	var str = Negative ? '-' :'' ;
+	if(Format == FormatCounterDefault)
+	{
+		var Seperate = 0;
+		var result = '';
+		while (Counter)
+		{
+			if (Seperate)
+			{
+				result += '.';
+			}
+			Seperate = 1;
+			for (var i = 0; Counter && i < 3; ++i)
+			{
+				var Digit = Math.floor(Counter % 10);
+				Counter = Math.floor(Counter / 10);
+				result += '' + Digit;
+			}
+		}
+
+		for(var i = 0; i < result.length; ++i)
+		{
+			str += result[result.length-1-i];
+		}
+		return str;
+	}
+	else if(Format == FormatCounterBytes)
+	{
+		var Shift = 0;
+		var Divisor = 1;
+		var CountShifted = ShiftRight10(Counter);
+		while(CountShifted)
+		{
+			Divisor <<= 10;
+			CountShifted = ShiftRight10(CountShifted);
+			Shift++;
+		}
+		if(Shift)
+		{
+			return str + (Counter / Divisor).toFixed(2) + '' + FormatCounterBytesExt[Shift];
+		}
+		else
+		{
+			return str + Counter.toFixed(2) + '' + FormatCounterBytesExt[0];
+		}
+	}
+	return '?';
+}
+function DrawCounterView(View, LocalMouseX, LocalMouseY, SubIndex)
+{
+	var TimerMap = FrameData.TimerMap;
+	if(!TimerMap)
+		return;
+
+
+	ProfileEnter("DrawCounterView");
+
+	var Canvas = View.Canvas[View.BackBuffer];
+	var context = Canvas.getContext('2d');
+	context.clearRect(0, 0, View.w, View.h);
+
+
+
+	var Height = BoxHeight;
+	var Width = nWidth;
+	var nTotalRows = CounterArray.length;
+	var nTotalRowPixels = nTotalRows * Height;
+	var nFrameRows = nHeight - BoxHeight;
+	if(nOffsetCountersY + nFrameRows > nTotalRowPixels && nTotalRowPixels > nFrameRows)
+	{
+		nOffsetCountersY = nTotalRowPixels - nFrameRows;
+	}
+	var CounterWidth = 150;
+	var Y = -nOffsetCountersY + BoxHeight;
+	var X = 0;
+	var nColorIndex = 0;
+	context.fillStyle = 'white';
+	context.font = Font;
+	var bMouseIn = 0;
+	function DrawHeaderSplitSingle(Header, Width)
+	{
+		context.fillStyle = 'white';
+		context.fillText(Header, X, Height-FontAscent);
+		X += Width;
+		context.fillStyle = nBackColorOffset;
+		context.fillRect(X-3, 0, 1, nHeight);
+	}
+	function DrawHeaderSplitSingleRight(Header, Width)
+	{
+		X += Width;
+		context.fillStyle = 'white';
+		context.textAlign  = 'right';
+		context.fillText(Header, X - FontWidth, Height-FontAscent);
+		context.fillStyle = nBackColorOffset;
+		context.fillRect(X, 0, 1, nHeight);
+		context.textAlign  = 'left';
+	}
+	var TimerLen = 6;
+	var TimerWidth = TimerLen * FontWidth;
+	nHoverCounter = -1;
+	function CounterIndent(Level)
+	{
+		return Level * 4 * FontWidth;
+	}
+	function Max(a, b)
+	{
+		return a > b ? a : b;
+	}
+
+	function DrawCounterRecursive(Index)
+	{
+		var Counter = TimerArray[Index];
+		if(Counter.idtype == TYPE_COUNTER)
+		{
+			var Indent = CounterIndent(Counter.depth-1);
+			var X = 0;
+			nColorIndex = 1-nColorIndex;
+			var HeightExpanded = Counter.Expanded ? Height * 5 : Height;
+
+			bMouseIn = LocalMouseY >= Y && LocalMouseY < Y + HeightExpanded;
+			if(bMouseIn)
+			{
+				nHoverCounter = Index;
+			}
+			var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
+			context.fillStyle = bgcolor;
+			context.fillRect(0, Y, Width, HeightExpanded);
+			context.fillStyle = 'white';
+			var c = Counter.closed ? '*' : ' ';
+			context.fillText(c + Counter.name, Indent, Y+Height-FontAscent);
+			X += CounterNameWidth;
+			X += CounterValueWidth - FontWidth;
+			context.textAlign = 'right';
+			context.fillText(Counter.formatted, X, Y+Height-FontAscent);
+			context.textAlign = 'left';
+			X += FontWidth * 4;
+			var Y0 = Y + 1;
+			if(Counter.limit != 0)
+			{
+				context.fillText(Counter.formattedlimit, X, Y+Height-FontAscent);
+				X += CounterLimitWidth;
+				var X0 = X + 1;
+				context.fillStyle = 'white';
+				context.fillRect(X0, Y0, Counter.boxprc * (CounterWidth-2), Height-2);
+				context.fillStyle = bgcolor;
+				context.fillRect(X0+1, Y0+1, Counter.boxprc * (CounterWidth-4), Height-4);
+				context.fillStyle = 'cyan';
+				context.fillRect(X0+1, Y0+1, Counter.counterprc * (CounterWidth-4), Height-4);
+				X += CounterWidth + 10;
+			}
+			else
+			{
+				X += CounterLimitWidth;
+				X += CounterWidth + 10;
+			}
+
+			if(Counter.minvalue != Counter.maxvalue)
+			{
+				var CounterHistory = Counter.counterhistory;
+				var Prc = CounterHistory.prc;
+				context.fillStyle = 'cyan';
+				context.strokeStyle = 'cyan';
+				context.globalAlpha = 0.5;
+				context.beginPath();
+				var x = X;
+				var YBase = Y0 + HeightExpanded-1;
+				var YOffset = -(HeightExpanded-2);
+
+				context.moveTo(X, Y0);
+				for(var i = 0; i < Prc.length; ++i)
+				{
+					context.moveTo(x, YBase);
+					context.lineTo(x, YBase + Prc[i] * YOffset);
+					x += 1;
+				}
+				context.stroke();
+
+				x = X;
+				context.globalAlpha = 1.0;
+				context.beginPath();
+				context.moveTo(X, YBase);
+
+				for(var i = 0; i < Prc.length; ++i)
+				{
+					context.lineTo(x, YBase + Prc[i] * YOffset);
+					x += 1;
+				}
+				context.stroke();
+				if(bMouseIn)
+				{
+					var MouseGraphX = Math.floor(LocalMouseX - X);
+					if(MouseGraphX >= 0 && MouseGraphX < CounterHistory.history.length)
+					{
+						context.fillStyle = 'white';
+						var Formatted = FormatCounter(Counter.format, CounterHistory.history[MouseGraphX]);
+						context.fillText(Formatted, X, Y+Height-FontAscent);
+					}
+					context.strokeStyle = 'orange';
+					context.beginPath();
+					var CrossX = X + MouseGraphX;
+					var CrossY = YBase + Prc[MouseGraphX] * YOffset;
+					context.moveTo(CrossX-2, CrossY-2);
+					context.lineTo(CrossX+2, CrossY+2);
+					context.moveTo(CrossX+2, CrossY-2);
+					context.lineTo(CrossX-2, CrossY+2);
+					context.stroke();
+
+				}
+				X += Prc.length + 5;
+				context.fillStyle = 'white';
+				context.fillText( FormatCounter(Counter.format, Counter.minvalue), X, Y + Height - FontAscent);
+				X += CounterWidth + 5;
+				context.fillText( FormatCounter(Counter.format, Counter.maxvalue), X, Y + Height - FontAscent);
+				X += CounterWidth + 5;
+			}
+			Y += HeightExpanded;
+		}
+
+		if(Index == 0 || (!Counter.closed && Counter.idtype == TYPE_COUNTER))
+		{
+			var ChildIndex = Counter.firstchild;
+			while(ChildIndex != -1)
+			{
+				DrawCounterRecursive(ChildIndex);
+				ChildIndex = TimerArray[ChildIndex].sibling;
+			}
+		}
+	}
+
+	DrawCounterRecursive(0);
+
+	X = 0;
+	context.fillStyle = nBackColorOffset;
+	context.fillRect(0, 0, Width, Height);
+	context.fillStyle = 'white';
+	DrawHeaderSplitSingle('Name', CounterNameWidth);
+	DrawHeaderSplitSingleRight('Value', CounterValueWidth + (FontWidth+1));
+	DrawHeaderSplitSingle('Limit', CounterLimitWidth + CounterWidth + 3 * (FontWidth+1));
+	ProfileLeave();
+}
+
+function ShowHelp(Show, Toggle)
+{
+	var HelpWindow = document.getElementById('helpwindow');
+	if(Toggle)
+	{
+		if(HelpWindow.style['display'] == 'block')
+		{
+			HelpWindow.style['display'] = 'none';
+		}
+		else
+		{
+			HelpWindow.style['display'] = 'block';
+		}
+	}
+	else
+	{
+		if(Show)
+		{
+			HelpWindow.style['display'] = 'block';
+		}
+		else
+		{
+			HelpWindow.style['display'] = 'none';
+		}
+	}
+}
+
+function ParseUrl()
+{
+	var path = window.location.pathname;
+	var idx = path.indexOf('/');
+	if(idx < 0)
+		return;
+	var StrCommand = path.substring(idx+1);
+	idx = StrCommand.indexOf('/');
+	if(idx < 0)
+		return;
+	var StrSettings = StrCommand.substring(idx+1);
+	PresetToLoad = StrSettings;
+	PresetToLoadRO = StrCommand[0] == 'b';
+}
+
+
+function GetCookie()
+{
+	var result = document.cookie.match(/fisk=([^;]+)/);
+	if(result && result.length > 0)
+	{
+		var Obj = JSON.parse(result[1]);
+		if(!Obj.offline)
+		{
+			var C = {};
+			C.offline = Obj;
+			Obj = C;
+		}
+		return Obj;
+	}
+	else
+	{
+		return {offline:{},live:{}};
+	}
+}
+
+function ReadCookie()
+{
+	var C = GetCookie().live;
+	for(var i in C)
+	{
+		Cookie[i] = C[i];
+	}
+}
+function WriteCookie()
+{
+	var C = GetCookie();
+	C.live = {};
+	for(var i in Cookie)
+	{
+		C.live[i] = Cookie[i];
+	}
+
+	var date = new Date();
+	date.setFullYear(2099);
+	var cookie = 'fisk=' + JSON.stringify(C) + ';expires=' + date;
+	document.cookie = cookie;
+}
+
+let CSVSets = {};
+let CSVIndex = 0;
+function CreateCSVSetFile(Set, Filename)
+{
+	let File = {};
+	File.Name = Filename;
+	File.DataSorted = [];
+	File.Data = [];
+	File.ColumnToIndex = {};
+	File.ColumnsSorted = {};
+	File.Columns = {};
+	return File;
+
+}
+function CreateCSVSet()
+{
+	let Index = ++CSVIndex;
+	let Name = "Drop_" + Index;
+	let Set = {};
+	Set.Name = Name;
+	Set.Files = {};
+	Set.Columns = {};
+	Set.ColumnNames = {};
+	Set.ColumnIndex = 0;
+	Set.PendingCount = 0;
+	Set.FinishedCount = 0;
+	return Set;
+}
+function ParseCSVCheckFinished(Name)
+{
+	let Set = CSVSets[Name];
+	console.log("Finished parsing ", Set.FinishedCount, ":", Set.PendingCount);
+	if(Set.FinishedCount == Set.PendingCount)
+	{
+		if(Set.FinishedCount == 0)
+		{
+			console.error("No CSV files were parsable");
+			CSVSets[Name] = null;
+		}
+		else
+		{
+			for(let CName in Set.ColumnNames)
+			{
+				let aggr = {};
+				let MaxCount = 0;
+				console.log("aggr for ", CName);
+				for(let F in Set.Files)
+				{
+					let File = Set.Files[F];
+					if(File.Columns[CName])
+						MaxCount = Math.max(MaxCount, File.Columns[CName].length);
+				}
+				let count = new Array(MaxCount);
+				let sum = new Array(MaxCount);
+				let min = new Array(MaxCount);
+				let max = new Array(MaxCount);
+				let avg = new Array(MaxCount);
+				for(let i = 0; i < MaxCount; ++i)
+				{
+					count[i] = 0;
+					sum[i] = 0;
+					min[i] = 1e28;
+					max[i] = -1e28;
+				}
+				for(let F in Set.Files)
+				{
+					let File = Set.Files[F];
+					if(File.Columns[CName])
+					{
+						let c = File.Columns[CName];
+						for(let i = 0; i < c.length; ++i)
+						{
+							count[i]++;
+							sum[i] += c[i];
+							min[i] = Math.min(c[i], min[i]);
+							max[i] = Math.max(c[i], max[i]);
+
+						}
+					}
+				}
+				for(let i = 0; i < MaxCount; ++i)
+				{
+					if(count[i])
+					{
+						avg[i] = sum[i] / count[i];
+						console.log(".. ", avg[i], " min ", min[i]);
+					}
+					else
+					{
+						min[i] = 0;
+						max[i] = 0;
+					}
+				}
+			}
+		}
+	}
+}
+function ParseCSVLine(Line)
+{
+	let Pos = 0;
+	let Start = 0;
+	let Len = Line.length;
+	let InBrackets = 0;
+	let Out = new Array();
+	let BracketStart = -1;
+	let BracketEnd = -1;
+	let push = function()
+	{
+		if(BracketStart >= 0)
+		{
+			console.assert(BracketEnd >= 0);
+			Out.push(Line.slice(BracketStart+1, BracketEnd));
+		}
+		else
+		{
+			Out.push(Line.slice(Start, Pos).trim());
+
+		}
+		Start = Pos+1;
+		InBrackets = 0;
+		BracketStart = -1;
+		BracketEnd = -1;
+	};
+	while(Pos != Len)
+	{
+		let Char = Line[Pos];
+		if(InBrackets)
+		{
+			if(Char == "\"")
+			{
+				BracketEnd = Pos;
+				InBrackets = 0;
+			}
+		}
+		else
+		{
+			if(Char == "\"")
+			{
+				BracketStart = Pos;
+				InBrackets = 1;
+			}
+			else if(Char == ",")
+			{
+				push();
+			}
+		}
+		Pos++;
+	}
+	push();
+	return Out;
+
+}
+
+function ParseCSVFile(Set, Result, Name)
+{
+	let File = CreateCSVSetFile(Set, Name);
+	let Lines = Result.split(/\r?\n/);
+	let Headers, Data, DataSorted;
+	let Columns = 0;
+	for(let i = 0; i < Lines.length; ++i)
+	{
+		let LineData = ParseCSVLine(Lines[i]);
+		if(i == 0)
+		{
+			Headers = LineData;
+			Columns = Headers.length;
+
+			Data = new Array(Columns);
+			DataSorted = new Array(Columns);
+			File.Data = Data;
+			File.DataSorted = DataSorted;
+			for(let j = 0; j < Columns; ++j)
+			{
+				Data[j] = new Array();
+				DataSorted[j] = new Array();
+
+				let ColumnName = Headers[j];
+				File.ColumnToIndex[Headers[j]] = j;
+				File.Columns[ColumnName] = Data[j];
+				File.ColumnsSorted[ColumnName] = DataSorted[j];
+				Set.ColumnNames[ColumnName] = 1;
+			}
+		}
+		else
+		{
+			if(LineData.length != Columns)
+			{
+				console.error("Failed to parse csv file ", Name);
+				Set.PendingCount--;
+				Set.FinishedCount--;
+				ParseCSVCheckFinished(Set.Name);
+				debugger;
+
+			}
+			for(let j = 0; j < Columns; ++j)
+			{
+				Data[j].push(parseFloat(LineData[j]));
+				DataSorted[j].push(parseFloat(LineData[j]));
+			}
+		}
+	}
+	for(let j = 0; j < Columns; ++j)
+	{
+		DataSorted[j].sort();
+
+	}
+	Set.Files[Name] = File;
+	Set.FinishedCount++;
+	ParseCSVCheckFinished(Set.Name);
+
+}
+
+function ReadCSVFile(Set, File)
+{
+	if(!File)
+		return;
+	let Reader = new FileReader();
+	Reader.onload = function(e) {
+		ParseCSVFile(Set, e.target.result, File.name);
+	};
+	Reader.onprogress = function(e)
+	{
+		var m = e.loaded + ":" + e.total + " :: " + e.lengthComputable;
+		console.log(m);
+	};
+	Set.PendingCount++;
+	Reader.readAsText(File);
+
+}
+
+// magic from stack-overflow somewhere..
+function WindowDragEnter(e)
+{
+    LastDropTarget = e.target;
+    document.querySelector(".dropzone").style.visibility = "";
+    document.querySelector(".dropzone").style.opacity = 1;
+};
+
+function WindowDragLeave(e)
+{
+    if(e.target === LastDropTarget || e.target === document)
+    {
+        document.querySelector(".dropzone").style.visibility = "hidden";
+        document.querySelector(".dropzone").style.opacity = 0;
+    }
+};
+function DropHandler(ev)
+{
+	document.querySelector(".dropzone").style.visibility = "hidden";
+	document.querySelector(".dropzone").style.opacity = 0;
+	LastDropTarget = null;
+
+	let Set = CreateCSVSet();
+	Set.PendingCount++;
+	CSVSets[Set.Name] = Set;
+	for(let i = 0; i < ev.dataTransfer.files.length; ++i)
+	{
+		let File = ev.dataTransfer.files[i];
+		let Name = File.name;
+		let ExtMatch = Name.match(/\.[0-9a-zA-Z]+$/);
+		let Ext = ExtMatch ? ExtMatch[0] : "";
+		if(Ext.toLowerCase() == ".csv")
+		{
+			ReadCSVFile(Set, File);
+		}
+		else
+		{
+			console.log("Not a .csv file!\n" + Name);
+		}
+	}
+	if(0 == Set.PendingCount)
+	{
+		window.alert("No dropped CSV files. Please drop one or more csv files to use csv viewer");
+	}
+	Set.FinishedCount++;
+	ParseCSVCheckFinished(Set.Name);
+  	ev.preventDefault();
+}
+
+function DragOverHandler(ev)
+{
+  ev.preventDefault();
+}
+
+
+
+ReadCookie();
+ParseUrl();
+ResizeCanvas();
+SetupEvents();
+InitMenu();
+window.addEventListener("dragenter", WindowDragEnter);
+window.addEventListener("dragleave", WindowDragLeave);
+setInterval(Connect, 100);
+RequestDraw();
+
+
+</script>
+</body>
+</html>
